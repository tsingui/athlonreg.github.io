{"meta":{"title":"Canvas's Blog","subtitle":"套陆的博客","description":"日常生活中的整理的一些玩机小技巧，欢迎各位拍砖！","author":"Canvas/套陆","url":"https://iamzhl.top","root":"/"},"pages":[{"title":"关于","date":"2019-04-16T04:00:39.272Z","updated":"2019-03-30T10:34:31.690Z","comments":false,"path":"about/index.html","permalink":"https://iamzhl.top/about/index.html","excerpt":"","text":"一个Linux运维热爱者，同时也是一个PC极客发烧友"},{"title":"分类","date":"2019-04-16T04:00:39.273Z","updated":"2019-03-30T10:34:31.691Z","comments":false,"path":"categories/index.html","permalink":"https://iamzhl.top/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2019-04-16T04:00:39.272Z","updated":"2019-03-30T10:34:31.692Z","comments":false,"path":"tags/index.html","permalink":"https://iamzhl.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CentOS 安装配置 GitLab","slug":"Setup-gitlab-to-support-frame","date":"2019-02-01T02:55:52.000Z","updated":"2019-03-11T16:21:49.900Z","comments":true,"path":"Setup-gitlab-to-support-frame.html","link":"","permalink":"https://iamzhl.top/Setup-gitlab-to-support-frame.html","excerpt":"","text":"CentOS 安装 GitLab安装依赖1234# yum -y install curl# yum -y install postfix# systemctl start postfix# systemctl enable postfix下载 GitLab 的 RPM 包1# wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-11.7.0-ce.0.el7.x86_64.rpm在https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/找自己需要的版本，下载到本地，然后安装即可1# rpm -ivh gitlab-ce-11.7.0-ce.0.el7.x86_64.rpm也可以这样1# yum localinstall gitlab-ce-11.7.0-ce.0.el7.x86_64.rpm配置 gitlab repo为了后续升级方便，建议添加gitlab的repo源1# curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sh端口修改1# vi /etc/gitlab/gitlab.rb修改下面的属性123external_url &apos;http://devops.iamzhl.top:8090&apos;unicorn[&apos;port&apos;] = 8070nginx[&apos;listen_port&apos;] = 8090请根据个人需要进行定制重新部署并重启12# gitlab-ctl reconfigure# gitlab-ctl restart设置页面嵌套支持1# vi /var/opt/gitlab/nginx/conf/gitlab-http.conf如图，添加标注的属性设置后重启GitLab1# gitlab-ctl restart","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"GitLab","slug":"GitLab","permalink":"https://iamzhl.top/tags/GitLab/"},{"name":"frame","slug":"frame","permalink":"https://iamzhl.top/tags/frame/"}]},{"title":"高效利用有道云笔记","slug":"How-to-use-youdao-note-in-a-special-way","date":"2019-01-20T13:12:25.000Z","updated":"2019-03-11T16:21:49.892Z","comments":true,"path":"How-to-use-youdao-note-in-a-special-way.html","link":"","permalink":"https://iamzhl.top/How-to-use-youdao-note-in-a-special-way.html","excerpt":"","text":"前言先说几个博主和其他的码字农民工比较头疼的问题云同步现在是云的时代，没有云同步的码文环境不是一个好的环境，可能每个人都有不止一个码文平台，比如工作配的机器和私人的机器，我在其中一台机器写好的文章还要再写一份到另外的机器。。。简直不要太lower。可能有人说我们用某度网盘。。。What’s that？已经放弃好久，本文不做赘述，想用的就用吧。。。跨平台这里假设上面的环境成立，你有两台机器，私人的是Mac环境，工作机器是Windows，那么问题来了，之前我在Mac非常喜欢MWeb，因为它的图床集成让我着迷 ，截图粘贴一张引用外链的图片就这么完成了，就是这么快，但是现在也已经放弃了，因为Windows平台人家不做，不要问我为什么，我不想喷Windows太垃圾🌝🌝但是无奈单位只有Windows，于是我要用两套环境。。。记住两套快捷键。。。MarkDown关于MarkDown的介绍这里不赘述。于我而言，不支持MarkDown解析的编辑器，我是绝对不会用的，Word就工作用用。。。为何呢？因为MarkDown太优雅了，在我看来，Word和MarkDown就像50岁的大妈和20岁的妙龄少女，写文档发博文用Word简直是遭罪，用MarkDown简直是享受，当然啦，纯属个人看法，不喜勿喷。。。图床说完了MarkDown和云的问题，有一个问题很明显，云上的数据文字可以，图片甚至视频怎么办？难道我还要买个云存储甚至是云服务器？当然不用啦！国内有些大公司还是相当良心的，先神秘一下，具体用什么，下面详细说😄环境准备编辑器Typora截图工具Windows：SnipmacOS：Xnip图床Sina Weobo账号(Sina的微博平台提供了一个图床服务，自带cdn)PicGo云同步有道云笔记配置PicGo其他的都没什么好说的，说一下PicGo的配置吧！首先在新浪微博官网登录微博账号，然后打开minipublish页面，如下图所示然后打开调试窗口，Chrome快捷键为F12，然后调到网络选项卡，如下图所示点击minipublish，查看一下Cookie值如下图所示选中Cookie后面那一串字符，拷贝一下，打开PicGo窗口，找到图床设置 -&gt; 新浪图床，在Cookie后面的输入框粘贴刚才的字符串，勾选cookie模式，点击确定 -&gt; 设为默认图床，如下图这时候，用前文所说的截图工具或者自己喜欢的工具截图，然后按下刚刚设置的快捷键，图片就会上传到新浪微博的图床服务器，然后将图片的外链返回给剪贴板了。在有道云随便建一个MarkDown文档，粘贴一下，如图文档保存后，有道云笔记会自动帮我们进行云同步，从此不必担心其3G的空间不够用了。当然啦，快捷键根据个人习惯在PicGo设置里面自行定义吧。","categories":[{"name":"高效利用有道云笔记","slug":"高效利用有道云笔记","permalink":"https://iamzhl.top/categories/高效利用有道云笔记/"}],"tags":[{"name":"有道云笔记","slug":"有道云笔记","permalink":"https://iamzhl.top/tags/有道云笔记/"},{"name":"Picbed","slug":"Picbed","permalink":"https://iamzhl.top/tags/Picbed/"},{"name":"图床","slug":"图床","permalink":"https://iamzhl.top/tags/图床/"}]},{"title":"TestLink 整合 LDAP 和 CAS 单点登录","slug":"TestLink-integrate-with-ldap-and-CAS","date":"2018-12-04T06:55:56.000Z","updated":"2019-03-11T16:21:49.903Z","comments":true,"path":"TestLink-integrate-with-ldap-and-CAS.html","link":"","permalink":"https://iamzhl.top/TestLink-integrate-with-ldap-and-CAS.html","excerpt":"","text":"背景介绍TestLink 版本：2.18TestLink URL：http://devops.iamzhl.top/testlinkopenLDAP 服务：ldap://devops.iamzhl.top:389CAS 服务：http://devops.iamzhl.top:8080/cas整合 LDAP修改TestLink配置文件1# vi /var/www/html/testlink/custom_config.inc.php添加LDAP配置文件123456789101112131415161718$tlCfg-&gt;authentication['method'] = 'LDAP';$tlCfg-&gt;authentication['ldap'] = array();$tlCfg-&gt;authentication['ldap'][1]['ldap_server'] = 'devops.iamzhl.top';$tlCfg-&gt;authentication['ldap'][1]['ldap_port'] = '389';$tlCfg-&gt;authentication['ldap'][1]['ldap_version'] = '3';$tlCfg-&gt;authentication['ldap'][1]['ldap_root_dn'] = 'dc=iamzhl,dc=top';$tlCfg-&gt;authentication['ldap'][1]['ldap_bind_dn'] = 'cn=Manager,dc=iamzhl,dc=top';$tlCfg-&gt;authentication['ldap'][1]['ldap_bind_passwd'] = '123456';$tlCfg-&gt;authentication['ldap'][1]['ldap_tls'] = false;$tlCfg-&gt;authentication['ldap'][1]['ldap_organization'] = '';$tlCfg-&gt;authentication['ldap'][1]['ldap_uid_field'] = 'uid';$tlCfg-&gt;authentication['ldap'][1]['ldap_email_field'] = 'mail';$tlCfg-&gt;authentication['ldap'][1]['ldap_firstname_field'] = 'givenname';$tlCfg-&gt;authentication['ldap'][1]['ldap_surname_field'] = 'sn';$tlCfg-&gt;authentication['ldap_automatic_user_creation'] = true;$tlCfg-&gt;authentication['ldap_email_field'] = 'mail';$tlCfg-&gt;authentication['ldap_firstname_field'] = 'givenname';$tlCfg-&gt;authentication['ldap_surname_field'] = 'sn';测试打开TestLink网址http://devops.iamzhl.top/testlink如图，正常跳转到TestLink登录界面，输入LDAP服务器中的用户名密码后点击Log in如图所示，登陆成功后正常的获取到了用户名，点击左上角的登出按钮，正常退出后跳转到了TestLink的登录界面至此，TestLink整合LDAP完成。整合CAS单点登录添加依赖的phpCAS库文件123456# wget https://github.com/apereo/phpCAS/archive/1.3.6.tar.gz# mv 1.3.6.tar.gz phpCAS-1.3.6.tar.gz# tar zxvf phpCAS-1.3.6.tar.gz# chown -R apache:apache phpCAS-1.3.6# cp -arf phpCAS-1.3.6/source/CAS.php /var/www/html/testlink/lib/functions/# cp -arf phpCAS-1.3.6/source/CAS /var/www/html/testlink/lib/functions/修改TestLink配置文件1# vi /var/www/html/testlink/custom_config.inc.php添加CAS配置项12345678/** CAS server parameters */$tlCfg-&gt;authentication['cas_enable'] = true;$tlCfg-&gt;authentication['cas_server_name'] = 'devops.iamzhl.top';$tlCfg-&gt;authentication['cas_server_port'] = 8080;$tlCfg-&gt;authentication['cas_server_path'] = 'cas';$tlCfg-&gt;authentication['cas_debug_enable'] = true;$tlCfg-&gt;authentication['cas_debug_file'] = '/var/logs/testlink/phpCAS.log';$tlCfg-&gt;authentication['cas_server_protocol'] = '2.0';修改登录界面1# vi /var/www/html/testlink/login.php在switch($args-&gt;action)分支选择语句段内找到case &#39;loginform&#39;部分，添加CAS的认证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115switch($args-&gt;action) &#123; case 'doLogin': case 'ajaxlogin': doSessionStart(true); // When doing ajax login we need to skip control regarding session already open // that we use when doing normal login. // If we do not proceed this way we will enter an infinite loop $options = array('doSessionExistsCheck' =&gt; ($args-&gt;action=='doLogin')); $op = doAuthorize($db,$args-&gt;login,$args-&gt;pwd,$options); $doAuthPostProcess = true; $gui-&gt;draw = true; break; case 'ajaxcheck': processAjaxCheck($db); break; case 'oauth': //If code is empty then break if (!isset($_GET['code']))&#123; renderLoginScreen($gui); die(); &#125; //Switch between oauth providers if (!include_once('lib/functions/oauth_providers/'.$_GET['oauth'].'.php')) &#123; die(\"Oauth client doesn't exist\"); &#125; $oau = config_get('OAuthServers'); foreach ($oau as $oprov) &#123; if (strcmp($oprov['oauth_name'],$_GET['oauth']) == 0)&#123; $oauth_params = $oprov; break; &#125; &#125; $user_token = oauth_get_token($oauth_params, $_GET['code']); if($user_token-&gt;status['status'] == tl::OK) &#123; doSessionStart(true); $op = doAuthorize($db,$user_token-&gt;options-&gt;user,'oauth',$user_token-&gt;options); $doAuthPostProcess = true; &#125; else &#123; $gui-&gt;note = $user_token-&gt;status['msg']; renderLoginScreen($gui); die(); &#125; break; case 'loginform': //zhanghl start if($authCfg['cas_enable']) &#123; if($authCfg['cas_debug_enable']) &#123; phpCAS::setDebug($authCfg['cas_debug_file']); &#125; // Initialize phpCAS phpCAS::client($authCfg['cas_server_protocol'], $authCfg['cas_server_name'], $authCfg['cas_server_port'], $authCfg['cas_server_path']); // For production use set the CA certificate that is the issuer of the cert // on the CAS server and uncomment the line below // phpCAS::setCasServerCACert($cas_server_ca_cert_path); // For quick testing you can disable SSL validation of the CAS server. // THIS SETTING IS NOT RECOMMENDED FOR PRODUCTION. // VALIDATING THE CAS SERVER IS CRUCIAL TO THE SECURITY OF THE CAS PROTOCOL! phpCAS::setNoCasServerValidation(); // Override the validation url for any (ST and PT) CAS 2.0 validation //phpCAS::setServerProxyValidateURL('http://devops.iamzhl.top:8080/cas/proxyValidate'); // Override the validation url for any CAS 1.0 validation //phpCAS::setServerServiceValidateURL('http://devops.iamzhl.top:8080/cas/serviceValidate'); phpCAS::handleLogoutRequests(); phpCAS::forceAuthentication(); $options = array('doSessionExistsCheck' =&gt; ($args-&gt;action=='doLogin')); $op = doCASAuthorize($db,$options); $doAuthPostProcess = true; &#125; else &#123; //zhanghl end $doRenderLoginScreen = true; $gui-&gt;draw = true; $op = null; // unfortunatelly we use $args-&gt;note in order to do some logic. if( ($args-&gt;note=trim($args-&gt;note)) == \"\" ) &#123; if( $gui-&gt;authCfg['SSO_enabled'] ) &#123; doSessionStart(true); $doAuthPostProcess = true; switch ($gui-&gt;authCfg['SSO_method']) &#123; case 'CLIENT_CERTIFICATE': $op = doSSOClientCertificate($db,$_SERVER,$gui-&gt;authCfg); break; case 'WEBSERVER_VAR': //DEBUGsyslogOnCloud('Trying to execute SSO using SAML'); $op = doSSOWebServerVar($db,$gui-&gt;authCfg); break; &#125; &#125; &#125; //zhanghl start &#125; //zhanghl end break;&#125;在init_gui函数内找到switch($args-&gt;note)分支语句，在expired分支下添加一行重定向调用123456789101112131415161718192021222324252627switch($args-&gt;note) &#123; case 'expired': if(!isset($_SESSION)) &#123; session_start(); &#125; session_unset(); session_destroy(); $gui-&gt;note = lang_get('session_expired'); $gui-&gt;reqURI = null; // 添加重定向调用 redirect(TL_BASE_HREF .\"login.php?destination=\".$args-&gt;destination); break; case 'first': $gui-&gt;note = lang_get('your_first_login'); $gui-&gt;reqURI = null; break; case 'lost': $gui-&gt;note = lang_get('passwd_lost'); $gui-&gt;reqURI = null; break; default: $gui-&gt;note = ''; break; &#125;修改登出界面1# /var/www/html/testlink/logout.php在$authCfg = config_get(&#39;authentication&#39;);语句之后添加CAS的登出处理1234567891011if($authCfg['cas_enable'])&#123; if($authCfg['cas_debug_enable']) &#123; phpCAS::setDebug($authCfg['cas_debug_file']); &#125; // Initialize phpCAS phpCAS::client($authCfg['cas_server_protocol'], $authCfg['cas_server_name'], $authCfg['cas_server_port'], $authCfg['cas_server_path']); phpCAS::logout();&#125;redirect(\"login.php?note=logout\");修改common.php全局引用文件1# vi /var/www/html/testlink/lib/functions/common.php在require_once(&#39;tlsmarty.inc.php&#39;);引用的前面增加对CAS的引用1234567/** TestLink CAS Authentication Ref */$authCfg = config_get('authentication');if($authCfg['cas_enable'])&#123; // Load the CAS lib require_once 'CAS.php';&#125;修改认证函数1# vi /var/www/html/testlink/lib/functions/doAuthorize.php在开头require_once语句的后面添加CAS认证函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// zhanghl startfunction doCASAuthorize(&amp;$db,$options=null)&#123; global $g_tlLogger; $result = array('status' =&gt; tl::ERROR, 'msg' =&gt; null); $user = new tlUser(); $user-&gt;login = $_SESSION['phpCAS']['user']; $login_exists = ($user-&gt;readFromDB($db,tlUser::USER_O_SEARCH_BYLOGIN) &gt;= tl::OK); if(!$login_exists) &#123; $user = new tlUser(); $user-&gt;login = $_SESSION['phpCAS']['user']; $user-&gt;isActive = true; $user-&gt;authentication = 'LDAP'; // force for auth_does_password_match $user-&gt;setPassword($user-&gt;login); // write password on DB anyway &#125; //$user-&gt;emailAddress = $_SESSION['phpCAS']['attributes']['mail']; //$user-&gt;firstName = $_SESSION['phpCAS']['attributes']['sn']; //$user-&gt;lastName = $_SESSION['phpCAS']['attributes']['givenName']; $doLogin = ($user-&gt;writeToDB($db) == tl::OK); if( $doLogin ) &#123; // Need to do set COOKIE following Mantis model $auth_cookie_name = config_get('auth_cookie'); $expireOnBrowserClose=false; setcookie($auth_cookie_name,$user-&gt;getSecurityCookie(),$expireOnBrowserClose,'/'); // Disallow two sessions within one browser if (isset($_SESSION['currentUser']) &amp;&amp; !is_null($_SESSION['currentUser'])) &#123; $result['msg'] = lang_get('login_msg_session_exists1') . ' &lt;a style=\"color:white;\" href=\"logout.php\"&gt;' . lang_get('logout_link') . '&lt;/a&gt;' . lang_get('login_msg_session_exists2'); &#125; else &#123; // Setting user's session information $_SESSION['currentUser'] = $user; $_SESSION['lastActivity'] = time(); $g_tlLogger-&gt;endTransaction(); $g_tlLogger-&gt;startTransaction(); setUserSession($db,$user-&gt;login, $user-&gt;dbID,$user-&gt;globalRoleID,$user-&gt;emailAddress,$user-&gt;locale,null); $result['status'] = tl::OK; &#125; &#125; return $result;&#125;// zhanghl end修改全局配置文件 (可选)1# vi /var/www/html/testlink/config.inc.php增加CAS认证属性12345678/** CAS server properties */$tlCfg-&gt;authentication['cas_enable'] = false;$tlCfg-&gt;authentication['cas_server_name'] = '';$tlCfg-&gt;authentication['cas_server_port'] = 8080;$tlCfg-&gt;authentication['cas_server_path'] = 'cas';$tlCfg-&gt;authentication['cas_debug_enable'] = true;$tlCfg-&gt;authentication['cas_debug_file'] = '';$tlCfg-&gt;authentication['cas_server_protocol'] = '';Note：此选项用以设置默认属性值，主要用来日后查阅，可以不写，/var/www/html/testlink/custom_config.inc.php文件相同的属性配置会覆盖生效。修改CAS的Client.php启用http连接(根据个人CAS服务器来定)1# vi /var/www/html/testlink/lib/functions/CAS/Client.php将如下几个函数中的https改为http即可1234567891011121314private function _getServerBaseURL()&#123; // the URL is build only when needed if ( empty($this-&gt;_server['base_url']) ) &#123; // $this-&gt;_server['base_url'] = 'https://' . $this-&gt;_getServerHostname(); $this-&gt;_server['base_url'] = 'http://' . $this-&gt;_getServerHostname(); if ($this-&gt;_getServerPort()!=443) &#123; $this-&gt;_server['base_url'] .= ':' .$this-&gt;_getServerPort(); &#125; $this-&gt;_server['base_url'] .= $this-&gt;_getServerURI(); &#125; return $this-&gt;_server['base_url'];&#125;12345678910111213141516private function _getCallbackURL()&#123; // the URL is built when needed only if ( empty($this-&gt;_callback_url) ) &#123; $final_uri = ''; // remove the ticket if present in the URL // $final_uri = 'https://'; $final_uri = 'http://'; $final_uri .= $this-&gt;_getClientUrl(); $request_uri = $_SERVER['REQUEST_URI']; $request_uri = preg_replace('/\\?.*$/', '', $request_uri); $final_uri .= $request_uri; $this-&gt;_callback_url = $final_uri; &#125; return $this-&gt;_callback_url;&#125;12345678910111213141516171819202122232425262728293031public function getURL()&#123; phpCAS::traceBegin(); // the URL is built when needed only if ( empty($this-&gt;_url) ) &#123; $final_uri = ''; // remove the ticket if present in the URL // $final_uri = ($this-&gt;_isHttps()) ? 'https' : 'http'; $final_uri = ($this-&gt;_isHttps()) ? 'http' : 'http'; $final_uri .= '://'; $final_uri .= $this-&gt;_getClientUrl(); $request_uri = explode('?', $_SERVER['REQUEST_URI'], 2); $final_uri .= $request_uri[0]; if (isset($request_uri[1]) &amp;&amp; $request_uri[1]) &#123; $query_string= $this-&gt;_removeParameterFromQueryString('ticket', $request_uri[1]); // If the query string still has anything left, // append it to the final URI if ($query_string !== '') &#123; $final_uri .= \"?$query_string\"; &#125; &#125; phpCAS::trace(\"Final URI: $final_uri\"); $this-&gt;setURL($final_uri); &#125; phpCAS::traceEnd($this-&gt;_url); return $this-&gt;_url;&#125;测试新建debug调试目录12# mkdir /var/log/testlink# chown -R apache:apache /var/log/testlink打开TestLink网址http://devops.iamzhl.top/testlink如图所示，正常跳转到CAS的登录界面，地址变成了http://devops.iamzhl.top:8080/cas/login?service=http%3A%2F%2Fdevops.iamzhl.top%2Ftestlink%2Flogin.php，输入用户名密码后点击登录如图登陆成功后正常获取用户名，点击左上角的登出按钮后，正常退出到CAS登出页面至此，TestLink整合CAS单点登录完成。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"},{"name":"LDAP","slug":"LDAP","permalink":"https://iamzhl.top/tags/LDAP/"},{"name":"TestLink","slug":"TestLink","permalink":"https://iamzhl.top/tags/TestLink/"}]},{"title":"MantisBT 整合 LDAP 和 CAS 单点登录","slug":"MantisBT-integrate-with-ldap-and-CAS","date":"2018-12-03T07:07:11.000Z","updated":"2019-03-11T16:21:49.897Z","comments":true,"path":"MantisBT-integrate-with-ldap-and-CAS.html","link":"","permalink":"https://iamzhl.top/MantisBT-integrate-with-ldap-and-CAS.html","excerpt":"","text":"背景介绍MantisBT 版本：2.18Mantis URL：http://devops.iamzhl.top/mantisopenLDAP 服务：ldap://devops.iamzhl.top:389CAS 服务：http://devops.iamzhl.top:8080/cas整合 LDAP修改MantisBT配置文件添加以下配置项1234567891011121314# MantisBT Authentication and LDAP Settings #$g_login_method = LDAP;$g_reauthentication = ON;$g_reauthentication_expiry = TOKEN_EXPIRY_AUTHENTICATED;$g_ldap_server = 'ldap://devops.iamzhl.top:389';$g_ldap_root_dn = 'ou=People,dc=iamzhl,dc=top';$g_ldap_protocol_version = 3;$g_ldap_organization = '';$g_ldap_bind_dn = 'cn=Manager,dc=iamzhl,dc=top';$g_ldap_bind_passwd = '123456';$g_ldap_uid_field = 'uid';$g_ldap_realname_field = 'cn';$g_use_ldap_realname = ON;$g_use_ldap_email = ON;打开MantisBT网址，输入用户名密码点击登录登陆成功后，正常获取用户名点击右上角的用户名 -&gt; 注销，会正常退出并跳转到登录界面至此，MantisBT整合LDAP完成。整合 CAS 单点登录下载phpCAS放到MantisBT下12345# wget https://github.com/apereo/phpCAS/archive/1.3.6.tar.gz# mv 1.3.6.tar.gz phpCAS-1.3.6.tar.gz# tar zxvf phpCAS-1.3.6.tar.gz# chown -R apache:apache phpCAS-1.3.6# cp -arf phpCAS-1.3.6 /var/www/html/mantis/phpCAS修改MantisBT配置文件1# vi /var/www/html/mantis/config/config_inc.php添加CAS认证需要的变量(请按照自己的LDAP服务器进行修改)1234567891011121314151617# MantisBT Authentication With CAS Settings #$g_login_method = CAS;$g_cas_server = 'devops.iamzhl.top';$g_cas_port = 8080;$g_cas_uri = '/cas';$g_cas_validate = '';$g_cas_version = '2.0';$g_cas_debug = '/var/www/html/mantis/cas.log';$g_cas_saml_attributes = OFF;$g_cas_saml_map = array( 'name' =&gt; '', 'mail' =&gt; '' );$g_cas_use_ldap = ON;$g_ldap_mantis_uid = 'uid';$g_cas_ldap_update = OFF;$g_cas_ldap_update_fields = '';$g_cas_ldap_update_map = '';$g_ldap_language_field = '';$g_ldap_language_keys = '';修改登录页面1# vi /var/www/html/mantis/login_page.php123456// 在文件开头的 require_once 部分增加对 phpCAS 的引入require_once( '/var/www/html/mantis/phpCAS/login_cas.php' );// 在 $f_username 变量的定义之前添加判断语句，当检测到用户已经认证时，跳转到主页if( auth_is_user_authenticated() &amp;&amp; !current_user_is_anonymous() ) &#123; print_header_redirect( config_get( 'default_home_page' ) );&#125;1# vi /var/www/html/mantis/login.php1234567// 在判断变量 f_install 的判断语句之后添加下面的判断语句来判断验证方式，若为 CAS ，则利用 auth_cas_get_name 函数来处理if ( CAS == config_get( 'login_method' ) ) &#123; # This will detour to the CAS login page if needed $f_password = ''; $f_username = auth_cas_get_name(); # User is always authenticated by this point&#125;1# vi /var/www/html/mantis/login_password_page.php12345678910// 在 $f_username 变量的定义之前添加判断语句，当检测到用户已经认证时，跳转到主页if( auth_is_user_authenticated() &amp;&amp; !current_user_is_anonymous() ) &#123; print_header_redirect( config_get( 'default_home_page' ) );&#125;$f_username = gpc_get_string( 'username', '' );# zhanghl startif( $f_username == '' ) &#123; $f_username = $staffid;&#125;# zhanghl end修改登出页面1# vi /var/www/html/mantis/logout_page.php12345678910111213// 在文件开头的 require_once 部分增加对 phpCAS 的引入require_once( '/var/www/html/mantis/phpCAS/login_cas.php' );# Cache the current logout redirect page as it will be cleared by auth_logout()//$t_logout_redirect = auth_logout_redirect_page();//auth_logout();phpCAS::setDebug();phpCAS::setVerbose(true);phpCAS::handleLogoutRequests();phpCAS::logout();//print_header_redirect( $t_logout_redirect, true, false );print_header_redirect( config_get( 'logout_redirect_page' ), true, false );修改验证逻辑1# vi /var/www/html/mantis/core/authentication_api.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// 在变量 g_cache_current_user_id 的定义后面添加以下函数，定义 CAS 的登录逻辑/*** Initialize phpCAS.*/function auth_cas_init() &#123; # phpCAS must be installed in the include path # or in the Mantis directory. require_once('/var/www/html/mantis/phpCAS/CAS.php'); static $s_initialized=false; if (! $s_initialized ) &#123; phpCAS::setDebug( config_get( 'cas_debug' ) ); ## These should be set in config_inc.php $t_server_version = config_get( 'cas_version' ); $t_server_cas_server = config_get( 'cas_server' ); $t_server_port = config_get( 'cas_port' ); $t_server_uri = config_get( 'cas_uri' ); $t_start_session = (boolean)FALSE; # Mantis takes care of its own session phpCAS::client($t_server_version, $t_server_cas_server, $t_server_port, $t_server_uri, $t_start_session); if ($t_server_version == \"S1\") phpCAS::setServerSamlValidateURL( config_get( 'cas_validate' ) ); else phpCAS::setServerProxyValidateURL( config_get( 'cas_validate' ) ); if (method_exists('phpCAS', 'setNoCasServerValidation')) &#123; // no SSL validation for the CAS server phpCAS::setNoCasServerValidation(); &#125; $s_initialized = true; &#125;&#125;/*** Fetches the user's CAS name, authenticating if needed.* Can translate CAS login name to Mantis username through LDAP.*/function auth_cas_get_name()&#123; # Get CAS username from phpCAS auth_cas_init(); phpCAS::forceAuthentication(); $t_cas_id = phpCAS::getUser(); $t_cas_attribs = phpCAS::getAttributes(); # If needed, translate the CAS username through LDAP $t_username = $t_cas_id; if (config_get( 'cas_use_ldap', false )) &#123; $t_username = auth_cas_ldap_translate( $t_cas_id ); &#125; elseif (config_get( 'cas_saml_attributes', false )) &#123; $t_cas_attribmap = config_get( 'cas_saml_map', array() ); $t_cas_attrib_name = $t_cas_attribs[$t_cas_attribmap['name']]; $t_cas_attrib_mail = $t_cas_attribs[$t_cas_attribmap['mail']]; if ( user_get_id_by_name($t_cas_id) == false ) &#123; user_create( $t_cas_id, '', $t_cas_attrib_mail, null, false, true, $t_cas_attrib_name ); &#125; &#125; return $t_username;&#125;/*** Takes an ID string, and looks up the LDAP directory to find* the matching username for Mantis.** Optionally, also update the user information in the Mantis user* table.** @param $p_cas_id string Typically, the username given by phpCAS.* @param $p_update_user bool Whether or not to update user details from LDAP.*/function auth_cas_ldap_translate( $p_cas_id, $p_update_user='' )&#123; # Please make sure the Mantis CAS and LDAP settings are set in config_inc.php $t_ldap_organization = config_get( 'ldap_organization' ); $t_ldap_root_dn = config_get( 'ldap_root_dn' ); # Required fields in LDAP for CAS $t_ldap_language_field = config_get( 'ldap_language_field', '' ); $t_ldap_uid_field = config_get( 'ldap_uid_field', 'uid' ) ; $t_ldap_mantis_uid = config_get( 'ldap_mantis_uid', 'uid' ); $t_ldap_required = array( $t_ldap_uid_field, $t_ldap_mantis_uid, 'dn' ); if ($t_ldap_language_field) &#123; // Add language field to attributes list only if it is configured. $t_ldap_required[] = $t_ldap_language_field; &#125; $t_ldap_required = array_combine( $t_ldap_required, $t_ldap_required ); # User-defined fields to fetch from LDAP... $t_ldap_fields = explode( ',', config_get( 'cas_ldap_update_fields' ) ); $t_ldap_fields = array_combine( $t_ldap_fields, $t_ldap_fields ); # ...which are mapped to Mantis user fields $t_ldap_map = explode( ',', config_get( 'cas_ldap_update_map' ) ); $t_ldap_map = array_combine( $t_ldap_map, $t_ldap_map ); # Build LDAP search filter, attribute list from CAS ID $t_search_filter = \"(&amp;$t_ldap_organization($t_ldap_uid_field=$p_cas_id))\"; $t_search_attrs = array_values($t_ldap_required + $t_ldap_fields); # array union # Use Mantis ldap_api to connect to LDAP $t_ds = ldap_connect_bind(); $t_sr = ldap_search( $t_ds, $t_ldap_root_dn, $t_search_filter, $t_search_attrs ); $t_info = ldap_get_entries( $t_ds, $t_sr ); # Parse the LDAP entry to find the Mantis username if ( $t_info ) &#123; # Get Mantis username $t_username = $t_info[0][$t_ldap_mantis_uid][0]; # @@@ The fact that we got here means the user is authenticated # @@@ by CAS, and has an LDAP entry. # @@@ We might as well update other user details since we are here. # If no argument given, check settings if ( '' == $p_update_user ) &#123; $p_update_user = config_get( 'cas_ldap_update', FALSE ); &#125; # If there's a user record, then update it if ( $p_update_user ) &#123; # Only proceed if the field map arrays are the same length $t_field_map = array_combine( $t_ldap_fields, $t_ldap_map ); if ($t_field_map) &#123; # If user is new, then we must create their account before updating it # @@@ ( make sure $g_allow_blank_email == ON ) $t_userid = user_get_id_by_name($t_username); if ( false == $t_userid ) &#123; user_create( $t_username, '' ); # @@@ Wow, this is pretty lame $t_userid = user_get_id_by_name($t_username); &#125; # @@@ maybe we can optimize this to write all fields at once? foreach ( $t_field_map as $key=&gt;$t_userfield ) &#123; if (isset($t_info[0][$key][0])) &#123; user_set_field( $t_userid, $t_userfield, $t_info[0][$key][0] ); &#125; &#125; &#125; // Update user's overall language preference if ($t_ldap_language_field) &#123; $t_language = $t_info[0][$t_ldap_language_field][0]; // Map the LDAP language field to Mantis' language field if needed $t_language_keys = config_get( 'ldap_language_keys', ''); $t_language_values = config_get( 'ldap_language_values', ''); $t_language_map = array_combine( explode(',', $t_language_keys), explode(',', $t_language_values) ); if (isset($t_language_map[$t_language])) &#123; $t_language = $t_language_map[$t_language]; &#125; user_pref_set_pref($t_userid, 'language', $t_language); &#125; &#125; &#125; ldap_free_result( $t_sr ); ldap_unbind( $t_ds ); return $t_username;&#125;/*** Logs out of CAS, redirecting to Mantis on re-login.* User should already be logged out of Mantis by the time this is called.* @see auth_logout()*/function auth_cas_logout()&#123; $t_path = config_get('path'); auth_cas_init(); if (method_Exists('phpCAS', 'logoutWithUrl')) &#123; phpCAS::logoutWithUrl($t_path); &#125; else &#123; phpCAS::logout($t_path); &#125;&#125;// zhanghl end1234567891011121314151617181920212223242526272829303132333435// 修改 auth_auto_create_user 函数实现 CAS 自动创建用户function auth_auto_create_user( $p_username, $p_password ) &#123; $t_login_method = config_get_global( 'login_method' ); // if( $t_login_method == BASIC_AUTH ) &#123; if ( in_array( $t_login_method, array( BASIC_AUTH, CAS ) ) ) &#123; # attempt to create the user if using BASIC_AUTH or CAS $t_auto_create = true; &#125; else if( $t_login_method == LDAP &amp;&amp; ldap_authenticate_by_username( $p_username, $p_password ) ) &#123; $t_auto_create = true; &#125; else &#123; $t_auto_create = false; &#125; if ( CAS == config_get( 'login_method' ) ) &#123; # Redirect to CAS page to logout auth_cas_logout(); &#125; if( $t_auto_create ) &#123; # attempt to create the user $t_cookie_string = user_create( $p_username, md5( $p_password ) ); if( $t_cookie_string === false ) &#123; # it didn't work return false; &#125; # ok, we created the user, get the row again return user_get_id_by_name( $p_username ); &#125; session_clean(); return false;&#125;1234567891011121314151617181920212223242526272829303132function auth_attempt_login( $p_username, $p_password, $p_perm_login = false ) &#123; $t_user_id = auth_get_user_id_from_login_name( $p_username ); $t_login_method = config_get( 'login_method' ); if( $t_user_id === false ) &#123; if ( in_array( $t_login_method, array( BASIC_AUTH, CAS ) ) ) &#123; # attempt to create the user if using BASIC_AUTH or CAS # ( note: CAS must have $g_allow_blank_email == ON ) $t_auto_create = true; &#125; $t_user_id = auth_auto_create_user( $p_username, $p_password ); if( $t_user_id === false ) &#123; return false; &#125; &#125; # max. failed login attempts achieved... if( !user_is_login_request_allowed( $t_user_id ) ) &#123; return false; &#125; # check for anonymous login if( !user_is_anonymous( $t_user_id ) ) &#123; # anonymous login didn't work, so check the password if( !auth_does_password_match( $t_user_id, $p_password ) ) &#123; user_increment_failed_login_count( $t_user_id ); return false; &#125; &#125; return auth_login_user( $t_user_id, $p_perm_login );&#125;123456789101112131415161718192021222324function auth_logout() &#123; global $g_cache_current_user_id, $g_cache_cookie_valid; # clear cached userid user_clear_cache( $g_cache_current_user_id ); current_user_set( null ); $g_cache_cookie_valid = null; # clear cookies, if they were set if( auth_clear_cookies() ) &#123; helper_clear_pref_cookies(); &#125; if( HTTP_AUTH == config_get_global( 'login_method' ) ) &#123; auth_http_set_logout_pending( true ); &#125; elseif ( CAS == config_get( 'login_method' ) ) &#123; # Redirect to CAS page to logout auth_cas_logout(); &#125; session_clean();&#125;12345678910function auth_automatic_logon_bypass_form() &#123; switch( config_get( 'login_method' ) ) &#123; case HTTP_AUTH: return true; case CAS: return true; &#125; return false; //return config_get_global( 'login_method' ) == HTTP_AUTH;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function auth_does_password_match( $p_user_id, $p_test_password ) &#123; $t_configured_login_method = config_get_global( 'login_method' ); if( LDAP == $t_configured_login_method ) &#123; return ldap_authenticate( $p_user_id, $p_test_password ); &#125; elseif ( CAS == $t_configured_login_method ) &#123; return true; &#125; if( !auth_can_use_standard_login( $p_user_id ) ) &#123; return false; &#125; $t_password = user_get_field( $p_user_id, 'password' ); $t_login_methods = array( MD5, CRYPT, PLAIN, BASIC_AUTH, CAS, ); foreach( $t_login_methods as $t_login_method ) &#123; # pass the stored password in as the salt if( auth_process_plain_password( $p_test_password, $t_password, $t_login_method ) == $t_password ) &#123; # Do not support migration to PLAIN, since this would be a crazy thing to do. # Also if we do, then a user will be able to login by providing the MD5 value # that is copied from the database. See #8467 for more details. if( ( $t_configured_login_method != PLAIN &amp;&amp; $t_login_method == PLAIN ) || ( $t_configured_login_method != BASIC_AUTH &amp;&amp; $t_login_method == BASIC_AUTH ) ) &#123; continue; &#125; # Check for migration to another login method and test whether the password was encrypted # with our previously insecure implementation of the CRYPT method if( ( $t_login_method != $t_configured_login_method ) || (( CRYPT == $t_configured_login_method ) &amp;&amp; mb_substr( $t_password, 0, 2 ) == mb_substr( $p_test_password, 0, 2 ) ) ) &#123; user_set_password( $p_user_id, $p_test_password, true ); &#125; return true; &#125; &#125; return false;&#125;12345678910111213141516171819202122232425262728293031323334353637function auth_reauthenticate() &#123; //if( !auth_reauthentication_enabled() || BASIC_AUTH == config_get_global( 'login_method' ) || HTTP_AUTH == config_get_global( 'login_method' ) ) &#123; if( !auth_reauthentication_enabled() || in_array(config_get('login_method'), array(BASIC_AUTH, HTTP_AUTH, CAS)) ) &#123; return true; &#125; $t_auth_token = token_get( TOKEN_AUTHENTICATED ); if( null != $t_auth_token ) &#123; token_touch( $t_auth_token['id'], auth_reauthentication_expiry() ); return true; &#125; else &#123; $t_anon_account = auth_anonymous_account(); $t_anon_allowed = auth_anonymous_enabled(); $t_user_id = auth_get_current_user_id(); $t_username = user_get_username( $t_user_id ); # check for anonymous login if( ON == $t_anon_allowed &amp;&amp; $t_anon_account == $t_username ) &#123; return true; &#125; $t_request_uri = string_url( $_SERVER['REQUEST_URI'] ); $t_query_params = http_build_query( array( 'reauthenticate' =&gt; 1, 'username' =&gt; $t_username, 'return' =&gt; $t_request_uri, ), '', '&amp;' ); # redirect to login page print_header_redirect( auth_credential_page( $t_query_params ) ); &#125;&#125;新建login_cas.php处理拦截利用CAS认证登录1# vi /var/www/html/mantis/phpCAS/login_cas.php123456789101112131415161718&lt;?phprequire_once( 'CAS.php' );define('CAS_ENABLE', true);$cas_host = 'devops.iamzhl.top';$cas_context = '/cas';$cas_port = 8080;$cas_real_hosts = array ( 'devops.iamzhl.top');phpCAS::setDebug();phpCAS::setVerbose(true);phpCAS::client(CAS_VERSION_2_0, $cas_host, $cas_port, $cas_context);phpCAS::setNoCasServerValidation();phpCAS::handleLogoutRequests(true, $cas_real_hosts);phpCAS::forceAuthentication();?&gt;修改CAS的Client.php启用http连接(根据个人CAS服务器来定)1# vi /var/www/html/mantis/phpCAS/source/CAS/Client.php将如下几个函数中的https改为http即可1234567891011121314private function _getServerBaseURL() &#123; // the URL is build only when needed if ( empty($this-&gt;_server['base_url']) ) &#123; //$this-&gt;_server['base_url'] = 'https://' . $this-&gt;_getServerHostname(); $this-&gt;_server['base_url'] = 'http://' . $this-&gt;_getServerHostname(); if ($this-&gt;_getServerPort()!=443) &#123; $this-&gt;_server['base_url'] .= ':' .$this-&gt;_getServerPort(); &#125; $this-&gt;_server['base_url'] .= $this-&gt;_getServerURI(); &#125; return $this-&gt;_server['base_url']; &#125;12345678910111213141516private function _getCallbackURL() &#123; // the URL is built when needed only if ( empty($this-&gt;_callback_url) ) &#123; $final_uri = ''; // remove the ticket if present in the URL //$final_uri = 'https://'; $final_uri = 'http://'; $final_uri .= $this-&gt;_getClientUrl(); $request_uri = $_SERVER['REQUEST_URI']; $request_uri = preg_replace('/\\?.*$/', '', $request_uri); $final_uri .= $request_uri; $this-&gt;_callback_url = $final_uri; &#125; return $this-&gt;_callback_url; &#125;12345678910111213141516171819202122232425262728293031public function getURL() &#123; phpCAS::traceBegin(); // the URL is built when needed only if ( empty($this-&gt;_url) ) &#123; $final_uri = &apos;&apos;; // remove the ticket if present in the URL //$final_uri = ($this-&gt;_isHttps()) ? &apos;https&apos; : &apos;http&apos;; $final_uri = ($this-&gt;_isHttps()) ? &apos;http&apos; : &apos;http&apos;; $final_uri .= &apos;://&apos;; $final_uri .= $this-&gt;_getClientUrl(); $request_uri = explode(&apos;?&apos;, $_SERVER[&apos;REQUEST_URI&apos;], 2); $final_uri .= $request_uri[0]; if (isset($request_uri[1]) &amp;&amp; $request_uri[1]) &#123; $query_string= $this-&gt;_removeParameterFromQueryString(&apos;ticket&apos;, $request_uri[1]); // If the query string still has anything left, // append it to the final URI if ($query_string !== &apos;&apos;) &#123; $final_uri .= &quot;?$query_string&quot;; &#125; &#125; phpCAS::trace(&quot;Final URI: $final_uri&quot;); $this-&gt;setURL($final_uri); &#125; phpCAS::traceEnd($this-&gt;_url); return $this-&gt;_url; &#125;测试新建log目录12# mkdir /var/log/mantis# chown -R apache:apache /var/log/mantis打开MantisBT网址，正常跳转至CAS登录界面，网址是http://devops.iamzhl.top:8080/cas/login?service=http%3A%2F%2Fdevops.iamzhl.top%2Fmantis%2Flogin_page.php如图，输入用户名密码后点击登录，正常登陆后跳转至MantisBT主页，并且正常获取用户名点击右上角的用户名 -&gt; 注销，会正常退出并跳转到CAS的登出界面","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"},{"name":"LDAP","slug":"LDAP","permalink":"https://iamzhl.top/tags/LDAP/"},{"name":"MantisBT","slug":"MantisBT","permalink":"https://iamzhl.top/tags/MantisBT/"}]},{"title":"Gerrit 整合 ldap 和 CAS 单点登录","slug":"Gerrit-integrate-with-ldap-and-CAS","date":"2018-12-03T01:42:41.000Z","updated":"2019-03-11T16:21:49.891Z","comments":true,"path":"Gerrit-integrate-with-ldap-and-CAS.html","link":"","permalink":"https://iamzhl.top/Gerrit-integrate-with-ldap-and-CAS.html","excerpt":"","text":"背景介绍Gerrit 版本：2.16Gerrit URL：http://devops.iamzhl.top:82openLDAP 服务：ldap://devops.iamzhl.top:389CAS 服务：http://devops.iamzhl.top:8080/cas整合 LDAP修改 gerrit.config1# vi /usr/local/review_site/etc/gerrit.config请根据自己的LDAP服务器信息进行定制123456789[auth] type = LDAP[ldap] server = ldap://devops.iamzhl.top:389 username = cn=Manager,dc=iamzhl,dc=top password = passwd accountBase = ou=People,dc=iamzhl,dc=top groupBase = ou=People,dc=iamzhl,dc=top accountFullName = uid重启服务1# gerrit restart测试打开网址http://devops.iamzhl.top:8081，进入到Gerrit主页面点击右上角Sign in，进入登录界面，输入LDAP服务器中的用户名和密码，然后点击Sign in登录成功后跳转到用户主页面，正常获取用户名点击用户名 -&gt; Sign Out，正常退出至此，Gerrit整合LDAP完成。整合 CAS修改 gerrit.config1# vi /usr/local/review_site/etc/gerrit.config修改[auth]部分1234[auth] type = HTTP httpHeader = X-Forwarded-Gerrit logoutUrl = http://devops.iamzhl.top:8080/cas/logoutmod_auth_cas修改然后安装mod_auth_cas1# yum -y install mod_auth_cas配置mod_auth_cas1# vi /etc/httpd/conf.d/auth_cas.conf修改CAS的Cookie存储位置以及登录地址和验证地址等参数如下123456789LogLevel DebugCASDebug OnCASVersion 2CASTimeout 1740CASIdleTimeout 1740CASSSOEnabled OnCASCookiePath /var/cache/httpd/mod_auth_cas/CASLoginURL http://devops.iamzhl.top:8080/cas/loginCASValidateURL http://devops.iamzhl.top:8080/cas/serviceValidate修改 apache 配置文件1# vi /etc/httpd/conf/httpd.conf添加反向代理12345678910111213141516171819202122232425262728293031323334353637# 添加一个监听端口 82 用作 Gerrit 的代理主机Listen 82# 加载 mod_auth_cas 模块，如果已经加载请忽略LoadModule auth_cas_module modules/mod_auth_cas.so# 设置 Gerrit 的虚拟主机&lt;VirtualHost *:82&gt; ServerName devops.iamzhl.top ServerAdmin 15563836030@163.com CASRootProxiedAs http://devops.iamzhl.top:82 ProxyRequests Off ProxyVia Off ProxyPreserveHost On &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;Location &quot;/login/&quot;&gt; AuthType CAS AuthName &quot;Welcome To Gerrit Code Review&quot; Require valid-user CASAuthNHeader X-Forwarded-Gerrit &lt;/Location&gt; AllowEncodedSlashes On ProxyPass / http://devops.iamzhl.top:8081/ ProxyPassReverse / http://devops.iamzhl.top:8081 ErrorLog /var/log/gerrit/error.log CustomLog /var/log/gerrit/access.log common&lt;/VirtualHost&gt;重启服务123# mkdir /var/log/gerrit# gerrit restart# systemctl restart httpd测试打开网址http://devops.iamzhl.top:82，发现自动跳转到了CAS的登录界面，网址是http://devops.iamzhl.top:8080/cas/login?service=http%3a%2f%2fdevops.iamzhl.top%3a82%2f输入用户名密码后，点击登录，登陆成功，地址是http://devops.iamzhl.top:82//#/dashboard/self点击用户名 -&gt; Sign Out，就会登出登出界面如下，地址是http://devops.iamzhl.top:8080/cas/logout至此，Gerrit整合CAS单点登录完成。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"},{"name":"Gerrit","slug":"Gerrit","permalink":"https://iamzhl.top/tags/Gerrit/"},{"name":"ldap","slug":"ldap","permalink":"https://iamzhl.top/tags/ldap/"}]},{"title":"SonarQube 整合 LDAP 和 CAS 单点登录","slug":"SonarQube-integrate-with-ldap-and-CAS","date":"2018-11-30T05:23:17.000Z","updated":"2019-03-11T16:21:49.901Z","comments":true,"path":"SonarQube-integrate-with-ldap-and-CAS.html","link":"","permalink":"https://iamzhl.top/SonarQube-integrate-with-ldap-and-CAS.html","excerpt":"","text":"背景介绍SonarQube版本：7.4SonarQube URL: http://devops.iamzhl.top:9000openLDAP 服务：ldap://devops.iamzhl.top:389CAS 服务：http://devops.iamzhl.top:8080/cas整合LDAP修改sonar配置文件sonar.properties1$ vi /usr/local/sonarqube-7.4/conf/sonar.properties找到下面的部分修改LDAP配置1234567891011121314151617181920#--------------------------------------------------------------------------------------------------# LDAP CONFIGURATION# Enable the LDAP feature# sonar.security.realm=LDAP# Set to true when connecting to a LDAP server using a case-insensitive setup.# sonar.authenticator.downcase=true# URL of the LDAP server. Note that if you are using ldaps, then you should install the server certificate into the Java truststore.# ldap.url=ldap://localhost:10389# Bind DN is the username of an LDAP user to connect (or bind) with. Leave this blank for anonymous access to the LDAP directory (optional)# ldap.bindDn=cn=sonar,ou=users,o=mycompany# Bind Password is the password of the user to connect with. Leave this blank for anonymous access to the LDAP directory (optional)# ldap.bindPassword=secret# Possible values: simple | CRAM-MD5 | DIGEST-MD5 | GSSAPI See http://java.sun.com/products/jndi/tutorial/ldap/security/auth.html (default: simple)# ldap.authentication=simple修改如下(请将具体信息按照自己的LDAP服务器信息进行修改):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#--------------------------------------------------------------------------------------------------# LDAP CONFIGURATION# Enable the LDAP featuresonar.security.realm=LDAP# Set to true when connecting to a LDAP server using a case-insensitive setup.# sonar.authenticator.downcase=true# URL of the LDAP server. Note that if you are using ldaps, then you should install the server certificate into the Java truststore.ldap.url=ldap://devops.iamzhl.top:389# Bind DN is the username of an LDAP user to connect (or bind) with. Leave this blank for anonymous access to the LDAP directory (optional)ldap.bindDn=cn=Manager,dc=iamzhl,dc=top# Bind Password is the password of the user to connect with. Leave this blank for anonymous access to the LDAP directory (optional)ldap.bindPassword=passwd# Possible values: simple | CRAM-MD5 | DIGEST-MD5 | GSSAPI See http://java.sun.com/products/jndi/tutorial/ldap/security/auth.html (default: simple)ldap.authentication=simple# See :# * http://java.sun.com/products/jndi/tutorial/ldap/security/digest.html# * http://java.sun.com/products/jndi/tutorial/ldap/security/crammd5.html# (optional)# ldap.realm=example.org# Context factory class (optional)# ldap.contextFactoryClass=com.sun.jndi.ldap.LdapCtxFactory# Enable usage of StartTLS (default : false)# ldap.StartTLS=true# Follow or not referrals. See http://docs.oracle.com/javase/jndi/tutorial/ldap/referral/jndi.html (default: true)# ldap.followReferrals=false# USER MAPPING# Distinguished Name (DN) of the root node in LDAP from which to search for users (mandatory)ldap.user.baseDn=ou=People,dc=iamzhl,dc=top# LDAP user request. (default: (&amp;(objectClass=inetOrgPerson)(uid=&#123;login&#125;)) )# ldap.user.request=(&amp;(objectClass=user)(sAMAccountName=&#123;login&#125;))ldap.user.request=(&amp;(objectClass=inetOrgPerson)(uid=&#123;login&#125;))# Attribute in LDAP defining the user’s real name. (default: cn)# ldap.user.realNameAttribute=nameldap.user.realNameAttribute=cn# Attribute in LDAP defining the user’s email. (default: mail)# ldap.user.emailAttribute=emailldap.user.emailAttribute=mail# GROUP MAPPING# Distinguished Name (DN) of the root node in LDAP from which to search for groups. (optional, default: empty)# ldap.group.baseDn=cn=groups,dc=example,dc=orgldap.group.baseDn=ou=People,dc=iamzhl,dc=top# LDAP group request (default: (&amp;(objectClass=groupOfUniqueNames)(uniqueMember=&#123;dn&#125;)) )# ldap.group.request=(&amp;(objectClass=group)(member=&#123;dn&#125;))ldap.group.request=(&amp;(objectClass=posixGroup)(memberUid=&#123;uid&#125;))# Property used to specifiy the attribute to be used for returning the list of user groups in the compatibility mode. (default: cn)# ldap.group.idAttribute=sAMAccountName修改完成后，重启sonar1$ sonar restart打开sonar网址，输入LDAP中的用户名和密码后点击登录登陆成功后，正常获取用户名至此，SonarQube整合LDAP完成整合CAS单点登录介绍SonarQube提供了一种SSO机制，可以用来作为单点登录的实现方式，就是使用HTTP header的方式，而CAS也提供了一种用于apache服务的认证方式，这就是mod_auth_cas，思路很简单，我们利用apache反向代理，做一个端口用于虚拟主机来转发SonarQube服务，然后在这个虚拟主机内部加入mod_auth_cas提供的认证拦截，同时在里面指定一个HTTP header用于发送认证后的请求到SonarQube，然后，SonarQube接收到这个请求后，发现正是自己设定的HTTP header，于是予以通过认证。这就是整个认证流程，下面开始介绍整合方法。SonarQube修改1$ vi /usr/local/sonarqube-7.4/conf/sonar.properties修改如下部分(就是将SSO AUTHENTICATION部分的参数取消注释，令其生效)12345678910111213141516171819202122232425#--------------------------------------------------------------------------------------------------# SSO AUTHENTICATION# Enable authentication using HTTP headerssonar.web.sso.enable=true# Name of the header to get the user login.# Only alphanumeric, &apos;.&apos; and &apos;@&apos; characters are allowedsonar.web.sso.loginHeader=X-Forwarded-Login# Name of the header to get the user namesonar.web.sso.nameHeader=X-Forwarded-Name# Name of the header to get the user email (optional)sonar.web.sso.emailHeader=X-Forwarded-Email# Name of the header to get the list of user groups, separated by comma (optional).# If the sonar.sso.groupsHeader is set, the user will belong to those groups if groups exist in SonarQube.# If none of the provided groups exists in SonarQube, the user will only belong to the default group.# Note that the default group will always be set.sonar.web.sso.groupsHeader=X-Forwarded-Groups# Interval used to know when to refresh name, email and groups.# During this interval, if for instance the name of the user is changed in the header, it will only be updated after X minutes.sonar.web.sso.refreshIntervalInMinutes=5修改app.d5dba530.chunk.js，解决登出问题，不同的版本不同，7.2.1的在main开头的一个js文件中。1# vi /usr/local/sonarqube-7.4/web/js/app.d5dba530.chunk.js修改如下1234t.handleLogout = function(e) &#123; // e.preventDefault(), t.context.router.push(\"/sessions/logout\") t.context.router.push(\"/sessions/logout\") //去掉e.preventDefault()方法&#125;12345r.createElement(\"li\", null, r.createElement(\"a\", &#123; //href: \"#\", href: \"http://192.168.6.99:8080/cas/logout\", //将此注销按钮的href改为CAS服务器的登出页面 onClick: this.handleLogout&#125;mod_auth_cas修改然后安装mod_auth_cas1# yum -y install mod_auth_cas配置mod_auth_cas1# vi /etc/httpd/conf.d/auth_cas.conf修改CAS的Cookie存储位置以及登录地址和验证地址等参数如下123456789LogLevel DebugCASDebug OnCASVersion 2CASTimeout 1740CASIdleTimeout 1740CASSSOEnabled OnCASCookiePath /var/cache/httpd/mod_auth_cas/CASLoginURL http://devops.iamzhl.top:8080/cas/loginCASValidateURL http://devops.iamzhl.top:8080/cas/serviceValidateapache修改1# vi /etc/httpd/conf/httpd.conf添加虚拟主机12345678910111213141516171819202122232425262728293031323334353637# 添加一个监听端口 83 用作 SonarQube 的代理主机Listen 83# 加载 mod_auth_cas 模块，如果已经加载请忽略LoadModule auth_cas_module modules/mod_auth_cas.so# 设置 SonarQube 的虚拟主机&lt;VirtualHost *:83&gt; ServerName devops.iamzhl.top ServerAdmin 15563836030@163.com CASRootProxiedAs http://devops.iamzhl.top:83 ProxyPreserveHost On ProxyPass / http://devops.iamzhl.top:9000/ ProxyPassReverse / http://devops.iamzhl.top:9000/ ProxyPass /sessions/logout http://devops.iamzhl.top:8080/cas/logout ProxyPassReverse /sessions/logout http://devops.iamzhl.top:8080/cas/logout ProxyPass /api/authentication/logout http://devops.iamzhl.top:8080/cas/logout ProxyPassReverse /api/authentication/logout http://devops.iamzhl.top:8080/cas/logout ErrorLog /var/log/sonar/error.log CustomLog /var/log/sonar/access.log common &lt;Location /&gt; AuthName &quot;Welcome to devops sonar&quot; CASAuthNHeader X-Forwarded-Login Authtype CAS require valid-user &lt;/Location&gt; &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt;&lt;/VirtualHost&gt;重启服务123456# mkdir /var/log/sonar# chown -R apache:apache /var/log/sonar# su sonar$ sonar restart# su # systemctl restart httpd测试打开网址http://devops.iamzhl.top:83，发现自动跳转到了CAS的登录界面，网址是http://devops.iamzhl.top:8080/cas/login?service=http%3a%2f%2fdevops.iamzhl.top%3a83%2f输入用户名密码后点击登录如图所示，登陆成功，地址是http://devops.iamzhl.top:83/projects如上图所示，点击注销，就会登出并跳转至CAS的登出界面至此，SonarQube整合CAS单点登录完成。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"},{"name":"LDAP","slug":"LDAP","permalink":"https://iamzhl.top/tags/LDAP/"},{"name":"SonarQube","slug":"SonarQube","permalink":"https://iamzhl.top/tags/SonarQube/"}]},{"title":"Jenkins 整合 LDAP 以及 CAS 单点登录","slug":"Jenkins-integrate-with-ldap-and-CAS","date":"2018-11-30T02:17:09.000Z","updated":"2019-03-11T16:21:49.895Z","comments":true,"path":"Jenkins-integrate-with-ldap-and-CAS.html","link":"","permalink":"https://iamzhl.top/Jenkins-integrate-with-ldap-and-CAS.html","excerpt":"","text":"背景介绍Jenkins 版本：2.138.3Jenkins 安装方式： Tomcat 容器部署 war 包Jenkins 地址：http://devops.iamzhl.top:8080/jenkinsopenLDAP 服务：ldap://devops.iamzhl.top:389CAS 服务：http://devops.iamzhl.top:8080/cas整合 openLDAP首先去 Jenkins 插件官网下载 LDAP 和 CAS 插件LDAP：https://updates.jenkins.io/download/plugins/ldap/CAS：https://updates.jenkins.io/download/plugins/cas-plugin/如图，点击系统管理点击插件管理 -&gt; 高级 -&gt; 上传插件(选择文件)弹出选择文件的对话框后，首先选择我们下载好的 LDAP 插件，然后点击上传，然后就会跳转到安装界面，我们勾选安装完成后重启Jenkins(空闲时)，等待一会Jenkins安装插件完成后就会重启输入用户名密码登录后，依次打开系统管理 -&gt; 全局安全配置，在安全域勾选 LDAP，点击Advanced Server Configuration,开始配置 LDAP 服务器的绑定信息点击Test LDAP settings，测试LDAP配置是否可用，如下图，输入一个LDAP服务器中存在的用户账号和密码，点击Test如果测试成功，会打印出类似如下的信息点击应用，然后点击保存。测试一下，用LDAP中的用户进行登录登陆成功，配置完成，到这里，Jenkins整合LDAP认证就完成了。整合 CAS 单点登录首先安装CAS插件，和上面安装LDAP插件步骤一样，安装完CAS打开系统管理 -&gt; 全局安全配置，在安全域勾选CAS (Central Authentication Service)，如图所示，配置好CAS的URL和CAS 协议然后点击应用-&gt;保存，注销，然后重新登录这时就可以跳转到CAS的登录界面了，输入用户名密码点击登录，就可以正常的登录进入Jenkins系统了。至此，Jenkins整合CAS完成。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://iamzhl.top/tags/Jenkins/"},{"name":"LDAP","slug":"LDAP","permalink":"https://iamzhl.top/tags/LDAP/"}]},{"title":"shadowsocks-libev","slug":"shadowsocks-libev","date":"2018-11-25T09:39:40.000Z","updated":"2019-03-11T16:21:49.905Z","comments":true,"path":"shadowsocks-libev.html","link":"","permalink":"https://iamzhl.top/shadowsocks-libev.html","excerpt":"","text":"环境准备国外服务器一台CentOS 操作系统安装12345678910111213141516171819202122232425262728293031# yum -y install pcre pcre-devel git wget gcc gcc-c++# cd ~ &amp;&amp; git clone https://github.com/shadowsocks/shadowsocks-libev.git# cd shadowsocks-libev &amp;&amp; git submodule update --init --recursive# yum install gettext gcc autoconf libtool automake make asciidoc xmlto c-ares-devel libev-devel# echo \"LIBSODIUM_VER=1.0.13\" &gt;&gt; /etc/profile# source /etc/profile# cd ~# wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz# tar zxvf LATEST.tar.gz# pushd libsodium-stable# ./configure --prefix=/usr &amp;&amp; make# make install# popd# ldconfig# echo \"export MBEDTLS_VER=2.6.0\" &gt;&gt; /etc/profile# source /etc/profile# cd ~ &amp;&amp; wget wget https://tls.mbed.org/download/mbedtls-2.14.0-apache.tgz# tar xvf mbedtls-2.14.0-apache.tgz# pushd mbedtls-2.14.0# make SHARED=1 CFLAGS=-fPIC# make DESTDIR=/usr install# popd# ldconfig# cd shadowsocks-libev &amp;&amp; ./autogen.sh &amp;&amp; ./configure &amp;&amp; make# make install# cd /usr/local &amp;&amp; wget https://nchc.dl.sourceforge.net/project/pcre/pcre/8.41/pcre-8.41.tar.gz# tar -zxvf pcre-8.41.tar.gz# cd pcre-8.41 &amp;&amp; ./configure &amp;&amp; make# make install# cd /usr/local &amp;&amp; mkdir ssr &amp;&amp; cd ssr# vi conf.conf12345678&#123; \"server\":\"your server ip\", \"server_port\":7788, \"local_port\":1080, \"password\":\"your password for ssr\", \"timeout\":60, \"method\":\"aes-256-cfb\"&#125;1# ss-server -c /usr/local/ssr/conf.conf //运行1# cd /usr/local/bin &amp;&amp; vi ssr //利用脚本后台运行12#!/bin/bashnohup ss-server -c /usr/local/ssr/conf.conf &gt; /dev/null 2&gt;&amp;1 &amp;123# chmod +x /usr/local/bin/ssr# ssr# ps ax | grep ssr","categories":[{"name":"study","slug":"study","permalink":"https://iamzhl.top/categories/study/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://iamzhl.top/tags/shadowsocks/"}]},{"title":"CentOS安装部署 openLDAP","slug":"CentOS-install-openLDAP","date":"2018-11-24T14:17:41.000Z","updated":"2019-03-11T16:21:49.884Z","comments":true,"path":"CentOS-install-openLDAP.html","link":"","permalink":"https://iamzhl.top/CentOS-install-openLDAP.html","excerpt":"","text":"简介OpenLDAP 是轻型目录访问协议Lightweight Directory Access Protocol - LDAP的自由和开源的实现，在其OpenLDAP许可证下发行，并已经被包含在众多流行的Linux发行版中。安装12# cd ~# yum -y install openldap-servers openldap-clients1234# cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG# chown ldap:ldap /var/lib/ldap/DB_CONFIG# systemctl start slapd# systemctl enable slapd配置1# slappasswd1# vi chrootpw.ldif12345# specify the password generated above for &quot;olcRootPW&quot; sectiondn: olcDatabase=&#123;0&#125;config,cn=configchangetype: modifyadd: olcRootPWolcRootPW: &#123;SSHA&#125;xxxxxxxxxxxxxxxxxxxxxxxx1# ldapadd -Y EXTERNAL -H ldapi:/// -f chrootpw.ldif导入基本模式123# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif # ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif # ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif在ldap的DB中设置域名1# slappasswd1# vi chdomain.ldif123456789101112131415161718192021222324252627282930# replace to your own domain name for &quot;dc=***,dc=***&quot; section# specify the password generated above for &quot;olcRootPW&quot; sectiondn: olcDatabase=&#123;1&#125;monitor,cn=configchangetype: modifyreplace: olcAccessolcAccess: &#123;0&#125;to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot; read by dn.base=&quot;cn=Manager,dc=iamzhl,dc=top&quot; read by * nonedn: olcDatabase=&#123;2&#125;hdb,cn=configchangetype: modifyreplace: olcSuffixolcSuffix: dc=iamzhl,dc=topdn: olcDatabase=&#123;2&#125;hdb,cn=configchangetype: modifyreplace: olcRootDNolcRootDN: cn=Manager,dc=iamzhl,dc=topdn: olcDatabase=&#123;2&#125;hdb,cn=configchangetype: modifyadd: olcRootPWolcRootPW: &#123;SSHA&#125;xxxxxxxxxxxxxxxxxxxxxxxxdn: olcDatabase=&#123;2&#125;hdb,cn=configchangetype: modifyadd: olcAccessolcAccess: &#123;0&#125;to attrs=userPassword,shadowLastChange by dn=&quot;cn=Manager,dc=iamzhl,dc=top&quot; write by anonymous auth by self write by * noneolcAccess: &#123;1&#125;to dn.base=&quot;&quot; by * readolcAccess: &#123;2&#125;to * by dn=&quot;cn=Manager,dc=iamzhl,dc=top&quot; write by * read1# ldapmodify -Y EXTERNAL -H ldapi:/// -f chdomain.ldif1# vi basedomain.ldif1234567891011121314151617181920# replace to your own domain name for &quot;dc=***,dc=***&quot; sectiondn: dc=iamzhl,dc=topobjectClass: topobjectClass: dcObjectobjectclass: organizationo: iamzhldc: iamzhldn: cn=Manager,dc=iamzhl,dc=topobjectClass: organizationalRolecn: Managerdescription: Directory Managerdn: ou=People,dc=iamzhl,dc=topobjectClass: organizationalUnitou: Peopledn: ou=Group,dc=iamzhl,dc=topobjectClass: organizationalUnitou: Group1# ldapadd -x -D cn=Manager,dc=iamzhl,dc=top -W -f basedomain.ldif添加一个用户12# slappasswd # vi ldapuser.ldif12345678910111213141516171819# create new# replace to your own domain name for &quot;dc=***,dc=***&quot; sectiondn: uid=cent,ou=People,dc=iamzhl,dc=topobjectClass: inetOrgPersonobjectClass: posixAccountobjectClass: shadowAccountcn: Centsn: LinuxuserPassword: &#123;SSHA&#125;xxxxxxxxxxxxxxxxxloginShell: /bin/bashuidNumber: 1000gidNumber: 1000homeDirectory: /home/centdn: cn=cent,ou=Group,dc=iamzhl,dc=topobjectClass: posixGroupcn: CentgidNumber: 1000memberUid: cent1# ldapadd -x -D cn=Manager,dc=iamzhl,dc=top -W -f ldapuser.ldif添加本机的用户和群组到ldap目录1# vi ldapuser.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# extract local users and groups who have 1000-9999 digit UID# replace \"SUFFIX=***\" to your own domain name# this is an example#!/bin/bashSUFFIX='dc=iamzhl,dc=top'LDIF='ldapuser.ldif'echo -n &gt; $LDIFGROUP_IDS=()grep \"x:[1-9][0-9][0-9][0-9]:\" /etc/passwd | (while read TARGET_USERdo USER_ID=\"$(echo \"$TARGET_USER\" | cut -d':' -f1)\" USER_NAME=\"$(echo \"$TARGET_USER\" | cut -d':' -f5 | cut -d' ' -f1,2)\" [ ! \"$USER_NAME\" ] &amp;&amp; USER_NAME=\"$USER_ID\" LDAP_SN=\"$(echo \"$USER_NAME\" | cut -d' ' -f2)\" [ ! \"$LDAP_SN\" ] &amp;&amp; LDAP_SN=\"$USER_NAME\" LASTCHANGE_FLAG=\"$(grep \"$&#123;USER_ID&#125;:\" /etc/shadow | cut -d':' -f3)\" [ ! \"$LASTCHANGE_FLAG\" ] &amp;&amp; LASTCHANGE_FLAG=\"0\" SHADOW_FLAG=\"$(grep \"$&#123;USER_ID&#125;:\" /etc/shadow | cut -d':' -f9)\" [ ! \"$SHADOW_FLAG\" ] &amp;&amp; SHADOW_FLAG=\"0\" GROUP_ID=\"$(echo \"$TARGET_USER\" | cut -d':' -f4)\" [ ! \"$(echo \"$&#123;GROUP_IDS[@]&#125;\" | grep \"$GROUP_ID\")\" ] &amp;&amp; GROUP_IDS=(\"$&#123;GROUP_IDS[@]&#125;\" \"$GROUP_ID\") echo \"dn: uid=$USER_ID,ou=People,$SUFFIX\" &gt;&gt; $LDIF echo \"objectClass: inetOrgPerson\" &gt;&gt; $LDIF echo \"objectClass: posixAccount\" &gt;&gt; $LDIF echo \"objectClass: shadowAccount\" &gt;&gt; $LDIF echo \"sn: $LDAP_SN\" &gt;&gt; $LDIF echo \"givenName: $(echo \"$USER_NAME\" | awk '&#123;print $1&#125;')\" &gt;&gt; $LDIF echo \"cn: $USER_NAME\" &gt;&gt; $LDIF echo \"displayName: $USER_NAME\" &gt;&gt; $LDIF echo \"uidNumber: $(echo \"$TARGET_USER\" | cut -d':' -f3)\" &gt;&gt; $LDIF echo \"gidNumber: $(echo \"$TARGET_USER\" | cut -d':' -f4)\" &gt;&gt; $LDIF echo \"userPassword: &#123;crypt&#125;$(grep \"$&#123;USER_ID&#125;:\" /etc/shadow | cut -d':' -f2)\" &gt;&gt; $LDIF echo \"gecos: $USER_NAME\" &gt;&gt; $LDIF echo \"loginShell: $(echo \"$TARGET_USER\" | cut -d':' -f7)\" &gt;&gt; $LDIF echo \"homeDirectory: $(echo \"$TARGET_USER\" | cut -d':' -f6)\" &gt;&gt; $LDIF echo \"shadowExpire: $(passwd -S \"$USER_ID\" | awk '&#123;print $7&#125;')\" &gt;&gt; $LDIF echo \"shadowFlag: $SHADOW_FLAG\" &gt;&gt; $LDIF echo \"shadowWarning: $(passwd -S \"$USER_ID\" | awk '&#123;print $6&#125;')\" &gt;&gt; $LDIF echo \"shadowMin: $(passwd -S \"$USER_ID\" | awk '&#123;print $4&#125;')\" &gt;&gt; $LDIF echo \"shadowMax: $(passwd -S \"$USER_ID\" | awk '&#123;print $5&#125;')\" &gt;&gt; $LDIF echo \"shadowLastChange: $LASTCHANGE_FLAG\" &gt;&gt; $LDIF echo &gt;&gt; $LDIFdonefor TARGET_GROUP_ID in \"$&#123;GROUP_IDS[@]&#125;\"do LDAP_CN=\"$(grep \":$&#123;TARGET_GROUP_ID&#125;:\" /etc/group | cut -d':' -f1)\" echo \"dn: cn=$LDAP_CN,ou=Group,$SUFFIX\" &gt;&gt; $LDIF echo \"objectClass: posixGroup\" &gt;&gt; $LDIF echo \"cn: $LDAP_CN\" &gt;&gt; $LDIF echo \"gidNumber: $TARGET_GROUP_ID\" &gt;&gt; $LDIF for MEMBER_UID in $(grep \":$&#123;TARGET_GROUP_ID&#125;:\" /etc/passwd | cut -d':' -f1,3) do UID_NUM=$(echo \"$MEMBER_UID\" | cut -d':' -f2) [ $UID_NUM -ge 1000 -a $UID_NUM -le 9999 ] &amp;&amp; echo \"memberUid: $(echo \"$MEMBER_UID\" | cut -d':' -f1)\" &gt;&gt; $LDIF done echo &gt;&gt; $LDIFdone)12# sh ldapuser.sh # ldapadd -x -D cn=Manager,dc=iamzhl,dc=top -W -f ldapuser.ldif利用Apache Directory Studio进行管理Apache Directory Studio 是一个 LDAP 的工具平台，用来连接到任何 LDAP 服务器并进行管理和开发工作。其可以实现以下功能：LDAP浏览器LDIF编辑器嵌入式 ApacheDSACI编辑器属性管理下面以新建连接和新增用户为例进行演示如图，点击 New Connection 新建一个 ldap 连接依次输入连接名、主机名以及端口号后点击Next再依次输入绑定的DN和密码后点击Finish新建一个 openLDAP 用户 test / 123456Credits本文多处参考centos7下ldap服务搭建，感谢wenwenxiong的分享。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"openLDAP","slug":"openLDAP","permalink":"https://iamzhl.top/tags/openLDAP/"}]},{"title":"CAS 5.3.4 安装部署","slug":"CAS-5-3-4-install-and-deploy","date":"2018-11-24T12:59:49.000Z","updated":"2019-03-11T16:21:49.883Z","comments":true,"path":"CAS-5-3-4-install-and-deploy.html","link":"","permalink":"https://iamzhl.top/CAS-5-3-4-install-and-deploy.html","excerpt":"","text":"简介CAS全称Central Authentication Service，中央认证服务，一种独立开放指令协议。CAS 是 Yale 大学发起的一个开源项目，旨在为 Web 应用系统提供一种可靠的单点登录方法，CAS 在 2004 年 12 月正式成为 JA-SIG 的一个项目，目前是一种企业级的单点登录解决方案。协议介绍关于 oauth2.0 的原理及介绍可以参考理解OAuth 2.0 - 阮一峰的网络日志，这里不做赘述。环境准备CAS是基于Spring写的，因此需要准备Java环境，官方提供了一种非常好用的编译方法，我们在使用时可以根据自己的需求来决定依赖的选择，本文主要以openLDAP和oauth为例。编译时需要maven环境。运行时需要 Tomcat 容器，因此需要提前准备好 Tomcat 环境。后续我们会整合 openLDAP 做统一用户管理，因此请先安装好 openLDAP。编译首先去项目地址下载编译模板1https://github.com/apereo/cas-overlay-template123# git clone https://github.com/apereo/cas-overlay-template# cd cas-overlay-template# vi pom.xml找到下面的部分123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-webapp$&#123;app.server&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- ...Additional dependencies may be placed here... --&gt; &lt;/dependencies&gt;将注释的部分替换为我们需要的模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-webapp$&#123;app.server&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;type&gt;war&lt;/type&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-oauth-webflow&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.driver.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jdbc-drivers&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-rest&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-ldap&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jpa-ticket-registry&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-jpa-service-registry&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-rest-services&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt; &lt;artifactId&gt;cas-server-support-json-service-registry&lt;/artifactId&gt; &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt; &lt;/dependency&gt; --&gt;&lt;/dependencies&gt;上面例子中我添加了openLDAP oauth2.0 mysql的依赖，具体请按照自己需求选择。编辑好pom文件后，执行下面的命令开始编译1# mvn clean package过程很长，需要联网。如上图所示，编译完成后，会在此目录下生成一个 target 目录，我们需要的 war 包就在里面。安装测试安装过程就比较简单了，将 war 包保存至 Tomcat 下 webapps 目录下，然后运行 Tomcat 即可。12# startup.sh# tail -f /usr/local/tomcat/logs/catalina.out运行完成后日志如上图所示，然后我们打开 http://localhost:8080/cas默认的用户名密码为 casuser / Mellon，输入用户名密码点击登录，登录成功后如图跳转至登录成功页面安装至此完成开启 oauth 2.0 授权application.properties 增加配置文件如下1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/application.properties12345678cas.authn.oauth.refreshToken.timeToKillInSeconds=2592000cas.authn.oauth.code.timeToKillInSeconds=30cas.authn.oauth.code.numberOfUses=1cas.authn.oauth.accessToken.releaseProtocolAttributes=truecas.authn.oauth.accessToken.timeToKillInSeconds=7200cas.authn.oauth.accessToken.maxTimeToLiveInSeconds=28800cas.authn.oauth.grants.resourceOwner.requireServiceHeader=truecas.authn.oauth.userProfileViewType=NESTED增加 OAUTH-1002.json service 注册文件1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/servies/OAUTH-1002.json12345678&#123; &quot;@class&quot; : &quot;org.apereo.cas.support.oauth.services.OAuthRegisteredService&quot;, &quot;clientId&quot;: &quot;20181124&quot;, &quot;clientSecret&quot;: &quot;123456&quot;, &quot;serviceId&quot; : &quot;^(https|http|imaps)://.*&quot;, &quot;name&quot; : &quot;OAuthService&quot;, &quot;id&quot; : 1002&#125;重启 Tomcat 测试1234567891011121314# shutdown.sh Using CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usrUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar# startup.sh Using CATALINA_BASE: /usr/local/tomcatUsing CATALINA_HOME: /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME: /usrUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jarTomcat started.#重启完成后，我们利用本博客作为目标访问网址进行测试，浏览器打开 http://localhost:8080/cas/oauth2.0/authorize?response_type=code&amp;client_id=20181124&amp;redirect_uri=https://blog.iamzhl.top发现跳转了一个示例网址这时我们需要设置一下两个变量1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/application.properties加入下面两行12cas.server.name=http://devops.iamzhl.top:8080/cascas.server.prefix=$&#123;cas.server.name&#125;请将 devops.iamzhl.top 改为你的 ip，然后重启 Tomcat 再次测试这次能正常跳转了，但是出现了未认证授权的服务，这是因为我们没有开启 http 协议支持，因此只要再让我们的 CAS Server 支持 http 认证就行了1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/application.properties添加下面两行12cas.tgc.secure=falsecas.serviceRegistry.initFromJson=true1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/services/HTTPSandIMAPS-10000001.json将&quot;serviceId&quot; : &quot;^(https|imaps)://.*&quot;,改为&quot;serviceId&quot; : &quot;^(https|http|imaps)://.*&quot;,，如图再次登录测试这次终于正常了，输入用户名密码点击登录，就会跳转到授权页面点击 Allow 即可成功授权跳转至本博客，我们会注意到 uri 会携带一个 code，这就是 CAS 目前在 oauth2.0 授权中最为完善的 code 授权模式了。至此， CAS 5.3 集成 oauth2.0 的授权已经搭建完毕整合 openLDAP1# vi /usr/local/tomcat/webapps/cas/WEB-INF/classes/application.properties注释掉默认的 cas.authn.accept.users 认证方式并添加与LDAP Server连接的配置(请根据自己的LDAP服务器信息进行修改)12345678910111213141516171819202122232425262728293031323334353637383940414243444546### CAS Authentication Credentials## cas.authn.accept.users=casuser::Melloncas.authn.ldap[0].principalAttributeList=sn,cn:commonName,givenName,eduPersonTargettedId:SOME_IDENTIFIERcas.authn.ldap[0].collectDnAttribute=falsecas.authn.ldap[0].principalDnAttributeName=principalLdapDncas.authn.ldap[0].allowMultiplePrincipalAttributeValues=truecas.authn.ldap[0].allowMissingPrincipalAttributeValue=truecas.authn.ldap[0].credentialCriteria=cas.authn.attributeRepository.ldap[0].attributes.uid=uidcas.authn.attributeRepository.ldap[0].attributes.displayName=displayNamecas.authn.attributeRepository.ldap[0].attributes.cn=commonNamecas.authn.attributeRepository.ldap[0].attributes.affiliation=groupMembershipcas.authn.ldap[0].ldapUrl=ldap://devops.iamzhl.top:389cas.authn.ldap[0].bindDn=cn=Manager,dc=iamzhl,dc=topcas.authn.ldap[0].bindCredential=passwdcas.authn.ldap[0].poolPassivator=BINDcas.authn.ldap[0].connectionStrategy=cas.authn.ldap[0].providerClass=org.ldaptive.provider.unboundid.UnboundIDProvidercas.authn.ldap[0].connectTimeout=5000cas.authn.ldap[0].trustCertificates=cas.authn.ldap[0].keystore=cas.authn.ldap[0].keystorePassword=cas.authn.ldap[0].keystoreType=PKCS12cas.authn.ldap[0].minPoolSize=3cas.authn.ldap[0].maxPoolSize=10cas.authn.ldap[0].validateOnCheckout=truecas.authn.ldap[0].validatePeriodically=truecas.authn.ldap[0].validatePeriod=500cas.authn.ldap[0].validateTimeout=5000cas.authn.ldap[0].failFast=truecas.authn.ldap[0].idleTime=500cas.authn.ldap[0].prunePeriod=24cas.authn.ldap[0].blockWaitTime=5000cas.authn.ldap[0].useSsl=falsecas.authn.ldap[0].useStartTls=falsecas.authn.ldap[0].responseTimeout=8000cas.authn.ldap[0].allowMultipleDns=falsecas.authn.ldap[0].name=cas.authn.ldap[0].type=AUTHENTICATEDcas.authn.ldap[0].searchFilter=uid=&#123;user&#125;#cas.authn.ldap[0].enhanceWithEntryResolver=truecas.authn.ldap[0].derefAliases=NEVERcas.authn.ldap[0].dnFormat=uid=%s,ou=People,dc=iamzhl,dc=topcas.authn.ldap[0].baseDn=ou=People,dc=iamzhl,dc=top重启 Tomcat 查看日志123# shutdown.sh# startup.sh# tail -f /usr/local/tomcat/logs/catalina.out新建一个 openLDAP 用户 test / 123456打开 CAS 网址测试 http://devops.iamzhl.top:8080/cas/login输入用户名密码登陆成功日志输出如下至此，CAS 5.3 整合 openLDAP 结束。自定义登出跳转界面某些时候，我们可能需要对登出进行定制，比如等出后跳转到等出界面，在CAS 5.3以后的版本中，直接修改前端的HTML页面无法完成登出的定制跳转，不过官方提供了更为方便的设置方法，我们可以通过修改配置文件application.properties来实现，在文件中添加以下内容12345cas.logout.followServiceRedirects=truecas.logout.redirectParameter=servicecas.logout.redirectUrl=https://default.cas.comcas.logout.confirmLogout=falsecas.logout.removeDescendantTickets=true请根据需要将其中的redirectUrl改为要定制的登出跳转链接自定义默认的登录跳转界面登出跳转可以定制，登录的也可以，有些时候，可能需要在直接访问的CAS的时候，登陆成功后直接跳转到指定的界面，比如直接访问http://devops.iamzhl.top:8080/cas，需要跳转到http://devops.iamzhl.top/index.html，那么就可以在application.properties中添加以下属性1cas.view.defaultRedirectUrl=http://devops.iamzhl.top/index.html自定义登录界面主题在cas/WEB-INF/classes/static/themes中新建一个文件夹以要设置的主题名命名，比如devops，在此目录下建立js、css以及images等静态资源文件夹，将定制的静态资源保存好，结构如下\u0011然后在application.properties添加以下属性1cas.theme.defaultThemeName=devops","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://iamzhl.top/tags/CAS/"}]},{"title":"CentOS 7 安装部署邮件服务器","slug":"Install-and-deploy-mail-server-on-CentOS-7","date":"2018-10-19T13:31:24.000Z","updated":"2019-03-11T16:21:49.893Z","comments":true,"path":"Install-and-deploy-mail-server-on-CentOS-7.html","link":"","permalink":"https://iamzhl.top/Install-and-deploy-mail-server-on-CentOS-7.html","excerpt":"","text":"本文环境CentOS 7.2 1511开始安装安装postfix1# yum -y install postfix如果机器已经安装了sendmail，需要将其卸载，下面两条命令均可12# yum -y remove sendmail# rpm -e sendmail修改MTA(默认邮件代理)1# alternatives --config mta检查是否配置成功1# alternatives --display mta这里我已经安装过postfix了安装dovecot1# yum -y install dovecot配置postfix1# vi /etc/postfix/main.cf修改以下参数123456789myhostname = mail.zhanghl.cn # 取消注释，设置hostnamemydomain = zhanghl.cn # 取消注释，设置域名myorigin = $mydomain # 取消注释inet_interfaces = all # 修改为allinet_protocols = ipv4 # 修改ipv4，如果支持ipv6，则可以为allmydestination = $myhostname, localhost.$mydomain, localhost, $mydomain # 修改在最后添加$mydomainmynetworks = 127.0.0.0/8, 10.0.0.0/24 # 取消注释，指定内网和本地的IP地址范围home_mailbox = Maildir/ # 取消注释，邮件保存目录smtpd_banner = $myhostname ESMTP $mail_name ($mail_version) # 取消注释，邮件服务器欢迎信息文件最后添加以下内容1234567891011# Setup max mail attachment to 10Mmessage_size_limit = 10485760# Setup max capacity of Inbox to 1Gmailbox_size_limit = 1073741824# SMTP Authenticationsmtpd_sasl_type = dovecotsmtpd_sasl_path = private/authsmtpd_sasl_auth_enable = yessmtpd_sasl_security_options = noanonymoussmtpd_sasl_local_domain = $myhostnamesmtpd_recipient_restrictions = permit_mynetworks,permit_auth_destination,permit_sasl_authenticated,reject启动并设置自启动12# systemctl start postfix //启动# systemctl enable postfix //自启动配置dovecot1# vim /etc/dovecot/dovecot.conf1listen = * //取消注释并修改1# vim /etc/dovecot/conf.d/10-auth.conf12disable_plaintext_auth = no //取消注释并修改auth_mechanisms = plain login //修改添加login1# vim /etc/dovecot/conf.d/10-mail.conf1mail_location = maildir:~/Maildir //修改设置邮件存储位置1# vim /etc/dovecot/conf.d/10-master.conf取消注释并添加user和group属性12345unix_listener /var/spool/postfix/private/auth &#123; mode = 0666 user = postfix group = postfix&#125;启动并设置自启动12# systemctl start dovecot //启动# systemctl enable dovecot //自启动域名解析添加一个子域名mail，A记录解析到服务器IP。再添加一个MX记录，主机记录为空，记录值为上面解析的二级域名mail.zhanghl.cn，优先级10。注意：解析生效可能需要一段时间。也可以修改/etc/hosts添加邮件服务器域名实现。1# vim /etc/hosts测试邮箱首先安装telnet，由于CentOS 7已经默认没有了xinetd和telnet，因此需要安装1# yum -y install xinetd telnet telnet-server设置xinetd启动并自启动12# systemctl start xinetd# systemctl enable xinetd利用telnet测试邮件服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105[zhanghl@centos-7 ~]$ telnet zhanghl.cn 25Trying 127.0.0.1...Connected to zhanghl.cn.Escape character is '^]'.220 mail.zhanghl.cn ESMTP Postfix (2.10.1)mail from:zhanghl250 2.1.0 Okrcpt to:root250 2.1.5 Okdata354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;Hello, i'm zhanghl!.250 2.0.0 Ok: queued as 731144191B7Fquit221 2.0.0 ByeConnection closed by foreign host.[zhanghl@centos-7 ~]$ telnet zhanghl.cn 110Trying 127.0.0.1...Connected to zhanghl.cn.Escape character is '^]'.+OK Dovecot ready.user zhanghl+OKpass 123456+OK Logged in.list+OK 1 messages:1 2381.retr 1+OK 2381 octetsReturn-Path: &lt;&gt;X-Original-To: zhanghl@zhanghl.cnDelivered-To: zhanghl@zhanghl.cnReceived: by mail.zhanghl.cn (Postfix) id 61E594191B92; Fri, 19 Oct 2018 22:44:27 +0800 (CST)Date: Fri, 19 Oct 2018 22:44:27 +0800 (CST)From: MAILER-DAEMON@zhanghl.cn (Mail Delivery System)Subject: Undelivered Mail Returned to SenderTo: zhanghl@zhanghl.cnAuto-Submitted: auto-repliedMIME-Version: 1.0Content-Type: multipart/report; report-type=delivery-status; boundary=\"731144191B7F.1539960267/mail.zhanghl.cn\"Message-Id: &lt;20181019144427.61E594191B92@mail.zhanghl.cn&gt;This is a MIME-encapsulated message.--731144191B7F.1539960267/mail.zhanghl.cnContent-Description: NotificationContent-Type: text/plain; charset=us-asciiThis is the mail system at host mail.zhanghl.cn.I'm sorry to have to inform you that your message could notbe delivered to one or more recipients. It's attached below.For further assistance, please send mail to postmaster.If you do so, please include this problem report. You candelete your own text from the attached returned message. The mail system&lt;root@zhanghl.cn&gt; (expanded from &lt;root&gt;): maildir delivery failed: create maildir file /root/Maildir/tmp/1539960267.P14995.centos-7.shared: Permission denied--731144191B7F.1539960267/mail.zhanghl.cnContent-Description: Delivery reportContent-Type: message/delivery-statusReporting-MTA: dns; mail.zhanghl.cnX-Postfix-Queue-ID: 731144191B7FX-Postfix-Sender: rfc822; zhanghl@zhanghl.cnArrival-Date: Fri, 19 Oct 2018 22:43:58 +0800 (CST)Final-Recipient: rfc822; root@zhanghl.cnOriginal-Recipient: rfc822;rootAction: failedStatus: 5.2.0Diagnostic-Code: X-Postfix; maildir delivery failed: create maildir file /root/Maildir/tmp/1539960267.P14995.centos-7.shared: Permission denied--731144191B7F.1539960267/mail.zhanghl.cnContent-Description: Undelivered MessageContent-Type: message/rfc822Return-Path: &lt;zhanghl@zhanghl.cn&gt;Received: from mail.zhanghl.cn (mail.zhanghl.cn [127.0.0.1]) by mail.zhanghl.cn (Postfix) with SMTP id 731144191B7F for &lt;root&gt;; Fri, 19 Oct 2018 22:43:58 +0800 (CST)Message-Id: &lt;20181019144410.731144191B7F@mail.zhanghl.cn&gt;Date: Fri, 19 Oct 2018 22:43:58 +0800 (CST)From: zhanghl@zhanghl.cnHello, i'm zhanghl!--731144191B7F.1539960267/mail.zhanghl.cn--.quit+OK Logging out.Connection closed by foreign host.[zhanghl@centos-7 ~]$使用邮箱一切都弄好以后，就可以使用Foxmail等第三方软件来收发邮件了。在这里需要说一下，系统用户就是邮件的用户，例如root，就是一个邮箱用户，邮箱是root@zhanghl.cn，密码就是root的密码，所以需要创建用户，只要使用useradd创建用户，再使用passwd设置密码。","categories":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/categories/运维/"},{"name":"Linux","slug":"运维/Linux","permalink":"https://iamzhl.top/categories/运维/Linux/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://iamzhl.top/tags/运维/"},{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/tags/Linux/"},{"name":"SMTP","slug":"SMTP","permalink":"https://iamzhl.top/tags/SMTP/"},{"name":"Mail Server","slug":"Mail-Server","permalink":"https://iamzhl.top/tags/Mail-Server/"}]},{"title":"TestLink安装部署","slug":"TestLink-install-and-deploy","date":"2018-08-26T11:51:29.000Z","updated":"2019-03-11T16:21:49.903Z","comments":true,"path":"TestLink-install-and-deploy.html","link":"","permalink":"https://iamzhl.top/TestLink-install-and-deploy.html","excerpt":"","text":"TestLink安装部署安装MySQLMySQL的Server在CentOS 7上从默认软件列表中被移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开，然后再安装：123# wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm# rpm -ivh mysql57-community-release-el7-9.noarch.rpm# yum -y install mysql mysql-server mysql-devel启动MySQL服务1# systemctl start mysqld获取安装MySQL时的初始密码并登录MySQL12# grep 'temporary password' /var/log/mysqld.log# mysql -u root -p登录成功后修改密码，首先修改安全策略为0，然后将密码长度限制修改为1，最后修改密码123mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;mysql&gt; set password for root@localhost=password(&apos;root&apos;);创建testlink用户并创建testlink要用的数据库并把testlink数据库的所有权限赋给testlink用户1234mysql&gt; CREATE USER &apos;testlink&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos;;mysql&gt; CREATE DATABASE testlink; mysql&gt; GRANT ALL ON testlink.* TO &apos;testlink&apos;@&apos;%&apos;; mysql&gt; flush privileges;设置MySQL启动与自启动12# systemctl enable mysqld //自启动# systemctl start mysqld //启动安装httpd安装1# yum -y install httpd启动自启动12# systemctl enable httpd //自启动# systemctl start httpd //启动安装PHP123# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# yum -y install `yum search php | grep php56w | grep -v \"===\" | grep -v mysqlnd | awk -F '.' '&#123;print $1&#125;'`测试一下PHP环境写一个phpinfo测试php环境是否正常1# vim /var/www/html/info.php123&lt;?php phpinfo();?&gt;浏览器打开http://IP:httpd端口/info.php如图，PHP环境安装完成。Note:PHP无法正确解析，网页显示源码的解决方法：1$ vi /etc/php.ini将short_open_tag = Off修改为short_open_tag = On，然后重启httpd服务即可安装TestLink下载1# wget https://jaist.dl.sourceforge.net/project/testlink/TestLink%201.9/TestLink%201.9.18/testlink-1.9.18.tar.gz解压重命名1234# tar zxvf testlink-1.9.18.tar.gz# mv testlink-1.9.18 testlink# mv testlink /var/www/html/# chown -R apache:apache /var/www/html/testlink修改配置文件12345# sed -i -e \"s/AllowOverride None/AllowOverride All/g\" /etc/httpd/conf/httpd.conf# sed -i -e \"s/DirectoryIndex index.html/DirectoryIndex index.html index.php index.shtm/g\" /etc/httpd/conf/httpd.conf# sed -i -e \"s/session.gc_maxlifetime = 1440/session.gc_maxlifetime = 2400/g\" /etc/php.ini# sed -i -e \"s/max_execution_time = 30/max_execution_time = 120/g\" /etc/php.ini# service httpd restart新建一些PHP环境要求必备的文件夹并赋予适当权限123456# mkdir -p /var/www/html/testlink/gui/templates_c# mkdir -p /var/testlink/logs/# mkdir -p /var/testlink/upload_area/# chmod 777 /var/www/html/testlink/gui/templates_c# chmod 777 /var/testlink/logs/# chmod 777 /var/testlink/upload_area/安装浏览器打开http://IP:port/testlink/install(将IP换成自己主机IP，端口号换为自己主机的Apache服务端口号)。如图，点击New installation开始安装选中同意协议，continue进入系统环境检测阶段，这一步需要根据错误提示进行配置，前面已经在安装php和testlink时解决了，所以现在已经没有错误了，图中橙色的提示可以忽略，点击continue如图，设定数据库管理员登录账户密码，自定义TestLink的数据库登录账户密码，其余均保持默认，点击Process TestLink Setup这里有一点提示，如上图中黑体所说 ，需要手动导入udf0结尾的sql文件，只需在mysql命令行中执行source /var/www/html/testlink/install/sql/mysql/testlink_create_udf0.sql即可，需要说明的是，需要手动修改其中的use字段，如下图，修改为mysql新建的testlink数据库名如果安装到最后出现了打印数据库调试信息，请检查php的mysql模块，命令是php -m | grep mysql，如下图则是正常的如果提示动态库无法加载之类的错误，只需重新安装php-mysql，然后重启php-fpm和httpd即可登录安装完成网址输入http://IP/testlink即可自动跳转到登录页面，默认用户admin/admin","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"运维","slug":"Linux/运维","permalink":"https://iamzhl.top/categories/Linux/运维/"}],"tags":[{"name":"TestLink","slug":"TestLink","permalink":"https://iamzhl.top/tags/TestLink/"}]},{"title":"CentOS 安装部署 Gerrit","slug":"Gerrit-install-and-deploy","date":"2018-08-22T03:36:45.000Z","updated":"2019-03-11T16:21:49.890Z","comments":true,"path":"Gerrit-install-and-deploy.html","link":"","permalink":"https://iamzhl.top/Gerrit-install-and-deploy.html","excerpt":"","text":"Gerrit 安装配置过程安装过程如下步骤一：创建专用账户和工作目录12# adduser gerrit // 创建专用账户# passwd gerrit //为专有账户设置密码步骤二：配置Java环境去官网下载JDK：http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html安装JDK将下载得到的jdk-8u161-linux-x64.rpm包保存到Linux主机1# rpm -ivh jdk-8u161-linux-x64.rpm设置环境变量，编辑~/.bashrc，1# vim ~/.bashrc在文件的末尾添加以下行1234export JAVA_HOME=/usr/java/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$CLASSPATH使环境配置生效1# source ~/.bashrc测试Java环境，在终端输入：java -version查看是否正常显示版本信息，若显示则安装成功步骤三：安装MySQLMySQL的Server在CentOS 7上从默认软件列表中被移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开，然后再安装：123# wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm# rpm -ivh mysql57-community-release-el7-9.noarch.rpm# yum -y install mysql mysql-server mysql-devel启动MySQL服务1# systemctl start mysqld获取安装MySQL时的初始密码并登录MySQL12# grep 'temporary password' /var/log/mysqld.log# mysql -u root -p登录成功后修改密码，首先修改安全策略为0，然后将密码长度限制修改为1，最后修改密码123mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;mysql&gt; set password for root@localhost=password(&apos;root&apos;);创建gerrit用户1mysql&gt; CREATE USER &apos;gerrit&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;创建gerrit要用的数据表1mysql&gt; CREATE DATABASE ReviewDB;把ReviewDB的所有权限赋给gerrit1mysql&gt; GRANT ALL ON ReviewDB.* TO &apos;gerrit&apos;@&apos;%&apos;;步骤四：安装Git1# yum -y install git步骤五：下载安装gerrit从官网下载gerrit，存放于/home/gerrit目录：1# wget https://gerrit-releases.storage.googleapis.com/gerrit-2.15.5.war安装gerrit：首先切换为gerrit用户，然后运行gerrit的war包123# su gerrit$ cd $ java -jar gerrit-2.15.war init -d review_site一路回车默认安装(其中的认证方式处改为HTTP)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798[root@centos-7 gerrit]# su gerrit[gerrit@centos-7 ~]$ ll总用量 83864-rwxr-xr-x. 1 root root 85872756 8月 21 12:49 gerrit-2.14.war[gerrit@centos-7 ~]$ java -jar gerrit-2.15.5.war init -d review_siteUsing secure store: com.google.gerrit.server.securestore.DefaultSecureStore[2018-08-21 12:51:37,463] [main] INFO com.google.gerrit.server.config.GerritServerConfigProvider : No /home/gerrit/review_site/etc/gerrit.config; assuming defaults*** Gerrit Code Review 2.15.5***Create '/home/gerrit/review_site' [Y/n]?*** Git Repositories***Location of Git repositories [git]:*** SQL Database***Database server type [h2]:*** Index***Type [LUCENE/?]:*** User Authentication***Authentication method [OPENID/?]: HTTPGet username from custom HTTP header [y/N]?SSO logout URL :Enable signed push support [y/N]?*** Review Labels***Install Verified label [y/N]?*** Email Delivery***SMTP server hostname [localhost]:SMTP server port [(default)]:SMTP encryption [NONE/?]:SMTP username :*** Container Process***Run as [gerrit]:Java runtime [/usr/java/jdk1.8.0_161/jre]:Copy gerrit-2.15.5.war to review_site/bin/gerrit.war [Y/n]?Copying gerrit-2.15.5.war to review_site/bin/gerrit.war*** SSH Daemon***Listen on address [*]:Listen on port [29418]:Generating SSH host key ... rsa... dsa... done*** HTTP Daemon***Behind reverse proxy [y/N]?Use SSL (https://) [y/N]?Listen on address [*]:Listen on port [8080]:Canonical URL [http://centos-7.shared:8080/]:*** Cache****** Plugins***Installing plugins.Install plugin commit-message-length-validator version v2.15.5 [y/N]?Install plugin download-commands version v2.15.5 [y/N]?Install plugin hooks version v2.15.5 [y/N]?Install plugin replication version v2.15.5 [y/N]?Install plugin reviewnotes version v2.15.5 [y/N]?Install plugin singleusergroup version v2.15.5 [y/N]?Initializing plugins.No plugins found with init steps.Initialized /home/gerrit/review_siteExecuting /home/gerrit/review_site/bin/gerrit.sh startStarting Gerrit Code Review: OKWaiting for server on centos-7.shared:8080 ... OKOpening http://centos-7.shared:8080/#/admin/projects/ ...FAILEDOpen Gerrit with a JavaScript capable browser: http://centos-7.shared:8080/#/admin/projects/[gerrit@centos-7 ~]$授权文件夹权限给gerrit用户：1# chown -R gerrit:gerrit review_site修改gerrit配置文件，说明如下1$ vim review_site/etc/gerrit.config12345678910111213141516171819[gerrit] basePath = git //指定被gerrit管理的所有git库存放位置，即review_site_project/git/ canonicalWebUrl = http://10.211.55.19:8081/project //指定web访问gerrit的网址//填自己的ip和端口号[database] type = mysql //指定gerrit所默认数据库类型，可以选用mysql，安装并创建gerrit账户 database = /home/gerrit/review_site/db/ReviewDB[auth] type = HTTP //指定浏览器登录gerrit时的认证方式[sendemail] smtpServer = localhost //局域网邮件服务器，可使用hMailSever搭建[container] user = gerrit //指定gerrit所在机器的用户身份与上文创建的用户对应一致,可以是root javaHome = /usr/java/jdk1.8.0_161/jre[sshd] listenAddress = *:29418 //指定sshd服务监听的端口号[httpd] listenUrl = http://*:8081/ //指定http代理地址[cache] directory = cache //缓存位置重启gerrit服务1$ review_site/bin/gerrit.sh restart设置gerrit服务开机启动1# ln -snf /home/gerrit/review_site/bin/gerrit.sh /etc/init.d/gerrit.sh步骤六：配置反向代理服务(nginx)说明： 局域网本地安装，设置本地repo库安装nginx反向代理服务器安装gcc-c++ pcre pcre-devel zlib zlib-devel openssl：1# yum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl安装启动nginx并设置自启动12345# rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm# yum update &amp;&amp; yum -y install nginx # systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.# systemctl start nginx配置nginx：1# vim /etc/nginx/conf.d/default.conf12345678910111213141516171819202122232425262728server &#123; listen 82; server_name localhost; auth_basic &quot;Welcome to Gerrit Code Review !&quot;; auth_basic_user_file /home/gerrit/review_site/etc/passwd; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; #root /usr/share/nginx/html; #index index.html index.htm index.php index.jsp; proxy_pass http://127.0.0.1:8081; #proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;启动nginx服务：1234# setenforce 0 //关闭selinux以避免造成权限问题# systemctl disable firewalld //禁用防火墙# systemctl stop firewalld //关闭防火墙# systemctl start nginx设置第一个gerrit用户的账号和密码要用到htpasswd命令需要首先安装有httpd123# yum -y install httpd$ touch ./review_site/etc/passwd$ htpasswd -b ./review_site/etc/passwd gerrit 123456步骤七：安装配置gitweb安装gitweb,最好在联网环境下安装，或者在离线环境下下载对应的依赖包1# yum -y install gitweb配置gitweb,与gerrit集成修改gitweb的配置文件（/etc/gitweb.conf），将配置项 “$projectroot”修改为gerrit的git仓库目录。修改/home/gerrit/review_site/etc/gerrit.config,添加：配置gerrit权限使用管理员账号登录gerrit,修改All-Projects的权限，为refs/*和refs/meta/config的Read配置项配置合适的权限。注意：如果你是在root用户下输入上面的命令 创建了password文件到/home/gerrit/review_site/etc目录中,你会发现在登录的时候永远登录不成功,永远会得到服务器500的错误页面。原因是password文件的权限问题。我们知道,/home/gerrit/是我们之前新建的gerrit用户的,那么这个文件夹的权限是700,也就是只允许gerrit用户访问,其他组的用户是访问不了的,虽然这个文件的权限拥有root用户的所有权限,但是因为它放在700权限的文件夹下面,所以同样其他用户是访问不到的。解决方法如下1# chown -R gerrit:gerrit /home/gerrit重启gerrit服务和Nginx服务重启gerrit和nginx服务12$ /home/gerrit/review_site/bin/gerrit.sh restart# systemctl restart nginx步骤八：测试访问http://localhost，用gerrit用户登录，登录界面如下","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"运维","slug":"Linux/运维","permalink":"https://iamzhl.top/categories/Linux/运维/"}],"tags":[{"name":"Gerrit","slug":"Gerrit","permalink":"https://iamzhl.top/tags/Gerrit/"},{"name":"代码审查","slug":"代码审查","permalink":"https://iamzhl.top/tags/代码审查/"}]},{"title":"Jenkins 配置部署","slug":"Jenkins-configure-and-deploy","date":"2018-08-22T03:36:45.000Z","updated":"2019-03-11T16:21:49.895Z","comments":true,"path":"Jenkins-configure-and-deploy.html","link":"","permalink":"https://iamzhl.top/Jenkins-configure-and-deploy.html","excerpt":"","text":"Jenkins 配置部署简介Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用；常用的版本管理系统有SVN、GIT，构建工具有Maven、Ant、Gradle。其具备以下特点：易于安装：不需要安装、不需要数据库，只需通过java -jar jenkins.war或部署到一个servlet容器中。易于配置：所有的配置都可能通过Jenkins提供的web界面完成，当然如果你喜欢，也可以通过手动修改xml文件进行配置。消息通知及测试报告：能够生成各类测试报告并通过消息通知机制（Email等）进行报告，包括单元测试、覆盖率测试、静态分析等。分布式构建：Jenkins支持多个Slave节点的动态挂载，完成分布式构建。资源动态调度：Jenkins的容器资源通过Kubernetes动态调度，动态扩容收缩。插件支持：Jenkins支持上千种插件，可以进行扩展，也可以根据需求近定制开发。安装部署以CentOS环境安装部署为例，详细介绍Jenkins安装部署整体过程和常用设置。准备工作环境准备如果使用Jenkins.war包的形式进行安装，需要提前准备以下环境。Java环境准备去官网下载JDK：http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html安装将下载得到的jdk-8u161-linux-x64.rpm包保存到Linux主机1# rpm -ivh jdk-8u161-linux-x64.rpm环境变量1# vim ~/.bashrc在文件的末尾添加以下行1234export JAVA_HOME=/usr/java/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$CLASSPATH使环境配置生效1# source ~/.bashrc测试Java环境1# java -version&emsp;&emsp;查看是否正常显示版本信息，若显示则安装成功Tomcat环境准备下载Tomcat地址: http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz1# wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz安装Tomcat12# tar zxvf apache-tomcat-8.5.32.tar.gz# mv apache-tomcat-8.5.32 /usr/local/配置Tomcat环境1# vim ~/.bashrc在文件的末尾添加以下行1234export CATALINA_BASE=/usr/local/apache-tomcat-8.5.32export TOMCAT_HOME=/usr/local/apache-tomcat-8.5.32export CATALINA_HOME=/usr/local/apache-tomcat-8.5.32export PATH=$PATH:$CATALINA_HOME/bin:$CATALINA_HOME/lib使环境配置生效1# source ~/.bashrc启动Tomcat服务1# startup.sh测试Tomcat打开浏览器，在地址栏中输入http://IP:8080回车，如果看到Tomcat自带的一个JSP页面，说明你的Tomcat已搭建成功安装部署下载war文件1# wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war安装Jenkins将下载后的war包放到/usr/local/apache-tomcat-8.5.32/webapps/目录下，启动tomcat即可， 或者用命令java -jar jenkins.war。测试打开浏览器输入http://IP:8080/jenkins回车即可看到jenkin初始配置界面，按照提示进行设置。常用设置邮件设置Jenkins-&gt;系统管理-&gt;系统设置，弹出如下图所示：SMTP服务器：为邮箱服务地址。QQ: smtp.qq.com163: smtp.163.com用户默认后缀：可以自动识别，只需填写用户即可。其他配置为Jenkins邮箱默认用户及采用的认证方式。Job设置在需要邮件通知的Job设置里面增加”构建后操作步骤” -&gt; 选择E-mail Notification。扩展插件设置但是如果你群发的收件人列表比较多，或者每次通知的人不一样，比如每次只想通知导致构建失败的那个人（即最后一次上传代码的人），那么简单的E-mail Notification就不能满足要求，需要使用Email extension plugin插件。SMTP server – 设置SMTP服务器地址Default user E-mail suffix – 设置用户默认邮件后缀Default Content Type – 默认内容类型(Plain Text HTML)Default Subject – 默认邮件主题Default Content – 默认邮件内容，可以设置模板Default Triggers – 触发器[ ] 全局配置根据实际情况勾选需要触发邮件通知的事件。点击上图右下角Default Trigger，弹出如下触发项： 项目配置进入到具体的项目配置界面点击”配置，在配置界面点击”增加构建后操作步骤”，选择”Editable Email Notification”。可以在“Advanced Settings”中针对该项目进行个性化的配置。可以针对该项目定义该项目通知的收件人列表、主题、内容、附件等。任务创建构建项目类型点击 Jenkins 首页”创建一个新任务”的链接，弹出如下图所示页面。Jenkins 提供了六种类型的任务。构建一个自由风格的软件项目这是Jenkins的主要功能。Jenkins 会结合任何 SCM 和任何构建系统来构建你的项目, 甚至可以构建软件以外的系统。Pipeline(流水线)Orchestrates long-running activities that can span multiple build slaves. Suitable for building pipelines (formerly known as workflows) and/or organizing complex activities that do not easily fit in free-style job type. – 很难用一两句话说清 Pipeline, 参考 , 后面另起一文来介绍。构建一个多配置项目适用于多配置项目,例如多环境测试、平台指定构建,等等。GitHub OrganizationScans a GitHub organization (or user account) for all repositories matching some defined markers. – 这个主要针对由 Github 托管的项目。Multibranch Pipeline(多分支流水线)Creates a set of Pipeline projects according to detected branches in one SCM repository. 根据一个SCM存储库中检测到的分支创建一组 Pipeline 项目。文件夹创建一个可以嵌套存储的容器。利用它可以进行分组。 视图仅仅是一个过滤器，而文件夹则是一个独立的命名空间， 因此你可以有多个相同名称的的内容，只要它们在不同的文件 夹里即可。这里选择第一个：构建一个自由风格的软件项目， 输入项目名称：python test project ，点击”确定”按钮。构建 Windows 测试任务假设，有一个 Python 编写的测试脚本 py_tests.py ，其绝对路径为/root/py_tests.py，内容如下：1print \"Hello world\"在Linux下怎么执行这个测试用例，打开终端123456[root@centos-7 ~]# cd[root@centos-7 ~]# ll py_tests.py-rw-r--r--. 1 root root 20 8月 16 16:07 py_tests.py[root@centos-7 ~]# python py_tests.pyHello world[root@centos-7 ~]#下面回到Jenkins的配置过程中添加项目的描述：Python 测试项目，打印Hello world。剩下的选项都不要管，拖到页面底部，构建 选项。选择执行shell选项，执行Linux shell命令。如上图，输入你在 Linux 终端下所输的命令python /root/py_tests.py。 点击保存。一个极简的，基于 Linux 系统的 Python 脚本测试持续集成项目就创建完成了。节点添加Jenkins有个很强大的功能：分布式构建(在Jenkins的配置中叫做节点)，分布式构建能够让同一套代码在不同的环境(如：Windows和Linux系统)中编译、测试等。而且Jenkins构建的代码和产物最后自动拷贝到主节点。注意：如果节点主机上不存在JDK，Jenkins会去自动下载。建议：所有Unix或者Windows机器的环境路径统一(如：JDK、Ant、Maven)，好处是便于管理、不容易出现奇葩问题。新建节点系统管理 → 管理节点 → 新建节点(左上角)，如下图所示：&emsp;&emsp;节点名称：建议使用字母、数字或字母和数字的组合。最好见名知意。不建议使用标点符号和中文(中文命名没有问题，但Job中无法引用)。配置节点Name(名称)：节点名称Description(描述)：节点描述，支持中文并发构建数：最大同时构建数量(根据机器的性能定，单颗四核cpu建议不要超过5) - 必须为数字远程工作目录：节点的根目录(注意：如果目录不存在，会自动创建目录。你必须对该目录有读写权限，不然会报错)标签：标记(又叫做标签)用来对多节点分组,标记之间用空格分隔.例如’refression java6’将会把一个节点标记上’regression’和’java6’.例来说,如果你有多个Linux系统的构建节点并且你的Job也需要在Linux系统上运行,那么你可以配置所有的Linux系统节点都标记为’windows’, 然后把Job也标记为’Linux’.这样的话你的Job就不会运行在除了Linux节点以外的其它节点之上了.Linux用法：尽可能的使用这个节点/只允许运行绑定到这台机器的Job(根据你的需求，二选一)启动方式：Linux节点：推荐 – Launch slave agents via SSH， 在Unix(包括Linux)机器上通过SSH通道连接节点 (适用于Unix和Linux)Host(主机)：节点主机的ip地址Credentials：凭据(如果为空或者不可选择，请在系统管理→Manage Credentials中配置。Manage Credentials的配置非常简单，这里就不在描述了。Manage Credentials配置完成后，需刷新节点配置页面才会显示。)节点连接以Launch slave agents via SSH为例，选择Manually trusted key Verification Strategy，然后点击最下面的保存。Jenkins -&gt; 系统管理 -&gt; 系统设置，设置SSH ServerName: 这个可以随意写Hostname: 远程主机的IP地址Username: 远程主机登录的用户名Remote Directory: 远程目录如图设置好信息后，点击下面的保存Jenkins -&gt; 系统管理 -&gt; 管理节点，点击刚刚配置好的节点，上线节点回到节点列表后发现节点就已经成功上线了角色权限由于jenkins默认的权限管理体系不支持用户组或角色的配置，因此需要安装第三发插件来支持角色的配置，本文将使用Role Strategy Plugin，介绍页面：https://wiki.jenkins-ci.org/display/JENKINS/Role+Strategy+Plugin。配置插件安装插件后，进入系统设置页面，配置如下：配置权限在系统管理页面点击Manage and Assign Roles进入角色管理页面进入之后管理角色（Manage Roles）选择该项可以创建全局角色、项目角色，并可以为角色分配权限。;如上图，分别创建了admin、anonymous两个全局角色，Online Program、test两个项目角色。&emsp;&emsp;项目角色与全局角色的区别就是，项目角色只能管理项目，没有管理jenkins的权限配置。&emsp;&emsp;添加项目角色时，需要指定匹配项目的模式，如上图中的Pattern，官方文档介绍该选项支持正则表达式，如”Roger-.”表示所有以Roger-开头的项目，(?i)roger-.*表示以roger-开头的项目并且不区分大小写，如以ABC开头的项目可以配置为”ABC|ABC.*”，也可以使用”abc|bcd|efg”直接匹配多个项目。创建用户在分配角色之前需要先创建用户。在系统管理页面，点击管理用户：&emsp;&emsp;点击新建使用者可以创建新用户，点击用户ID或名称都可以修改用户信息。&emsp;&emsp;选择Assign Roles可以为用户分配所属角色，可以分配全局角色和项目角色。&emsp;&emsp;如上图，将不同的用户分别分配给不同的角色，这样用户就可以具有角色所拥有的权限。运行与维护Jenkins升级说明：Jenkins迭代更新很频繁，一般1周更新一次，半年一个大版本。升级：下载新的war包，替换旧的war包，重启即可。下载地址为http://mirrors.jenkins-ci.org/。PS：升级前，请测试该版本和你本地数据的兼容性。如何测试：将JENKINS_HOME拷贝一份到新的机器，用新版的程序启动。测试对应的插件和配置。Jenkins迁移和备份首先找到JENKINS_HOME，一般在用户根目录下.jenkins目录，因为Jenkins的所有的数据都是以文件的形式存放在JENKINS_HOME目录中。所以不管是迁移还是备份，只需要操作JENKINS_HOME就行了。迁移：建议将JENKINS_HOME打包后再拷贝，Windows上可以用zip，rar等，Linux上有zip，tar等。然后将打包的文件解压到新的JENKINS_HOME目录就行了。备份：如果是临时备份，整个压缩文件就行了。恢复：恢复的时候需要先停止jenkins。移动，删除或修改jobs对于移动或删除jobs，只需要简单地移动或删除$JENKINS_HOME/jobs目录。对于修改jobs的名字，只需要简单地修改$JENKINS_HOME/jobs下对应job的文件夹的名字。对于不经常使用的job，只需要对$JENKINS_HOME/jobs下对应的jobs的目录zip或tar后存储到其他的地方。Jenkins 启动时的命令行参数--httpPort=$HTTP_PORT用来设置jenkins运行时的web端口。--httpsPort=$HTTP_PORT表示使用https协议。~~~~–httpListenAddress=$HTTP_HOST用来指定jenkins监听的ip范围，默认为所有的ip都可以访问此jenkins server。修改jenkins的timezone如果jenkins所在的server的timezone不同于用户的timezone，这时候需要修改jenkins的timezone，需要在jenkins启动的时候增加下列参数-Dorg.apache.commons.jelly.tags.fmt.timeZone=TZ。查看jenkins的系统信息以在jenkins的管理页面下的系统信息中，查看所有的jenkins的信息，例如jenkins的启动配置，所依赖的系统的环境变量，所安装的plugins。Jenkins中执行batch和PythonJenkins的job -&gt; build 支持Ant，maven，windows batch和Shell， 但是我们知道python，perl，ruby等脚本其实也是shell脚本，所以这里的Shell可以扩展为python，perl，ruby等。如图Jenkins 整合 LDAP 以及 CAS 单点登录参考另外一篇博客Jenkins 整合 LDAP 以及 CAS 单点登录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"运维","slug":"Linux/运维","permalink":"https://iamzhl.top/categories/Linux/运维/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://iamzhl.top/tags/Jenkins/"},{"name":"持续集成","slug":"持续集成","permalink":"https://iamzhl.top/tags/持续集成/"}]},{"title":"SonarQube安装部署","slug":"SonarQube-install-and-deploy","date":"2018-08-20T08:10:59.000Z","updated":"2019-03-11T16:21:49.901Z","comments":true,"path":"SonarQube-install-and-deploy.html","link":"","permalink":"https://iamzhl.top/SonarQube-install-and-deploy.html","excerpt":"","text":"SonarQube安装部署简介SonarQube是一个管理代码质量的开放平台，可以从七个维度检测代码质量：复杂度分布（complexity）：代码复杂度过高将难以理解、难以维护；重复代码（duplications）：程序中包含大量复制粘度的代码是质量低下的表现；单元测试（unit tests）：统计并展示单元测试覆盖率；编码规范（coding rules）：通过Findbugs、PMD、CheckStyle等规范代码编写；注释（commments）：少了可读性差，多了看起来费劲；潜在的Bug（potential bugs）：通过Findbugs、PMD、CheckStyle等检测潜在bug；结构与设计（architecture &amp; design）：依赖、耦合等。SonarQube 可以集成不同的测试工具（CppCheck、CheckStyle、Junit、CppUnit等），代码分析工具、持续集成工具（Jenkins）、IDE（VisualStudio）。Sonar通过对代码质量分析结果数据进行在加工处理，通过量化的方式来度量代码的质量变化，从而可以方便的对工程进行代码质量管理。支持语言：JAVA PHP C# C COBOL PL/SQL FLEX等20余种。组成SonarQube平台的组成：数据库：存放SonarQube的配置数据、代码质量的快照数据。Web服务：用于查看SonarQube的配置数据、代码质量的快照数据。分析器：对项目代码进行分析、生成质量结果数据并存入数据库中（分析器有多中，此处选择SonarQube Maven Plugin）。安装环境安装JDK去官网下载JDK：http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html安装JDK将下载得到的jdk-8u161-linux-x64.rpm包保存到Linux主机1# rpm -ivh jdk-8u161-linux-x64.rpm设置环境变量，编辑~/.bashrc，1# vim ~/.bashrc在文件的末尾添加以下行1export JAVA_HOME=/usr/java/jdk1.8.0_161 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$CLASSPATH使环境配置生效1# source ~/.bashrc测试Java环境，在终端输入：java -version查看是否正常显示版本信息，若显示则安装成功Note:如果已经预装了openjdk，请先卸载1# yum list installed | grep openjdk # 根据执行结果进行卸载安装MySQLMySQL的Server在CentOS 7上从默认软件列表中被移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开，然后再安装：123# wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm# rpm -ivh mysql57-community-release-el7-9.noarch.rpm# yum -y install mysql mysql-server mysql-devel启动MySQL服务1# systemctl start mysqld获取安装MySQL时的初始密码并登录MySQL12# grep 'temporary password' /var/log/mysqld.log# mysql -u root -p登录成功后修改密码，首先修改安全策略为0，然后将密码长度限制修改为1，最后修改密码123mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;mysql&gt; set password for root@localhost=password(&apos;root&apos;);设置sonar的用户名和数据库123# adduser sonar# passwd sonar # 修改sonar用户密码# su sonar # 切换为sonar用户安装1234mysql&gt; create user &apos;sonar&apos;@&apos;%&apos; identified by &apos;sonar&apos;;mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;mysql&gt; grant all privileges on sonar.* to &apos;sonar&apos;@&apos;%&apos;;mysql&gt; flush privileges;安装SonarQube12345$ wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.3.zip$ unzip sonarqube-7.3.zip //若提示unzip命令找不到，用yum -y install unzip安装即可$ mv sonarqube-7.3 sonarqube $ mv sonarqube /usr/local/# chown -R sonar:sonar /usr/local/sonarqube配置sonar1$ vim /usr/local/sonarqube/conf/sonar.properties如图设置以下选项启动sonar1$ /usr/local/sonarqube/bin/linux-x86-64/sonar.sh start成功启动后，访问本地 http://IP:9000，SonarQube 初始管理员账号为 admin，默认密码为 admin，登录后可修改密码。Note:如果遇到Sonar启动不起来，查看日志自动关闭的问题，可以采用以下方法解决1234# echo -e \"vm.max_map_count=262144\" &gt;&gt; /etc/sysctl.conf# sysctl -p# echo -e \"sonar hard nofile 65536\" &gt;&gt; /etc/security/limits.conf # echo -e \"sonar soft nofile 65536\" &gt;&gt; /etc/security/limits.conf然后注销sonar用户重新以sonar身份登录后再次启动:1$ /usr/local/sonarqube/bin/linux-x86-64/sonar.sh start插件安装：如果需要下载插件的话，各个版本不一样，如图所示，先点击Administration,再打开Marketplace就可以看到Plugins各种插件了。SonarQube 支持分析的语言有很多，像Java、Python、Php、C/C++、C#、HTML、JavaScript、PL/SQL、Objective C等20+语言，当我们需要支持分析什么语言时，只需要去插件中心安装对应语言的插件即可，非常方便，可扩展性强，根据自己的需要去选择插件。实验验证本次实验验证以Java工程为例安装配置sonar-scanner获取sonar-scanner12345# wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.2.0.1227-linux.zip# unzip sonar-scanner-cli-3.2.0.1227-linux.zip# mv sonar-scanner-3.2.0.1227-linux sonar-scanner# mv sonar-scanner /usr/local/# chown -R sonar:sonar sonar-scanner配置sonar-scanner环境变量1# vim ~/.bashrc使配置生效1# source ~/.bashrc检查环境配置是否成功1$ sonar-scanner -version配置sonar-scanner.properties文件1$ vim /usr/local/sonar-scanner/conf/sonar-scanner.properties验证过程添加Java Maven测试工程编写测试工程添加sonar-project.properties文件在工程根目录中添加sonar-project.properties文件，格式如下1234sonar.projectKey=com.geovis //项目的唯一标识sonar.projectName=helloworld //项目的名字sonar.projectVersion=1.0 //项目的版本sonar.sources=/root/helloworld/src //项目的源码目录，多目录以英文逗号分隔例如我的项目结构如下那么此项目配置文件应为代码质量检查设置完后，终端运行sonar-scanner命令，开始项目源代码的分析查看结果命令运行完成之后，访问http://localhost:9000，输入账号密码即可查看分析结果，如下图SonarQube 整合 LDAP 和 CAS 单点登录SonarQube整合LDAP和CAS单点登录的过程请参考我的另一篇博客SonarQube 整合 LDAP 和 CAS 单点登录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"运维","slug":"Linux/运维","permalink":"https://iamzhl.top/categories/Linux/运维/"}],"tags":[{"name":"SonarQube","slug":"SonarQube","permalink":"https://iamzhl.top/tags/SonarQube/"},{"name":"sonar-scanner","slug":"sonar-scanner","permalink":"https://iamzhl.top/tags/sonar-scanner/"}]},{"title":"MantisBT 安装部署过程","slug":"MantisBT-install-and-deploy","date":"2018-08-18T05:53:09.000Z","updated":"2019-03-11T16:21:49.896Z","comments":true,"path":"MantisBT-install-and-deploy.html","link":"","permalink":"https://iamzhl.top/MantisBT-install-and-deploy.html","excerpt":"","text":"MantisBT软件安装部署过程简介&#160;&#160;&#160;&#160;Mantis是一个基于PHP技术的轻量级的开源缺陷跟踪系统，以Web操作的形式提供项目管理及缺陷跟踪服务。在功能上、实用性上足以满足中小型项目的管理及跟踪。更重要的是其开源，不需要负担任何费用。部署环境Mantis安装部署环境如下：名称版本号描述Mantisbt2.16.0BugTracing 软件操作系统CentOS 7RedHat 社区发行版PHP7.2.8PHP 环境部署过程软件安装安装PHP1234# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# yum -y install libicu libicu-devel libicu-doc# yum -y install php70w php70w-gd php70w-xml php70w-mysql php70w-mbstring php70w-ldap php70w-xmlrpc php70w-odbc php70w-pear php70w-soap php70w-snmp安装PHPMailer1https://github.com/Synchro/PHPMailer/releases/tag/v5.2.13下载解压到/var/www/html/mantis/PHPMailer-5.2.13/安装apache mysql等必要软件MySQL的Server在CentOS 7上从默认软件列表中被移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开，然后再安装：123# wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm# rpm -ivh mysql57-community-release-el7-9.noarch.rpm# yum -y install mysql mysql-server mysql-devel启动MySQL服务1# systemctl start mysqld获取安装MySQL时的初始密码并登录MySQL12# grep 'temporary password' /var/log/mysqld.log# mysql -u root -p登录成功后修改密码，首先修改安全策略为0，然后将密码长度限制修改为1，最后修改密码123mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;mysql&gt; set password for root@localhost=password(&apos;root&apos;);安装apache httpd123# yum -y install httpd# systemctl enable httpd //自启动# systemctl start httpd //启动安装mantis下载12# cd /var/www/html# wget https://jaist.dl.sourceforge.net/project/mantisbt/mantis-stable/2.18.0/mantisbt-2.18.0.zip解压重命名123# tar zxvf mantisbt-2.16.0.tar.gz# mv mantisbt-2.16.0 mantis# mv mantis /var/www/html/修改用户组1# chown -R apache:apache /var/www/html/mantis创建数据库12345678910111213141516171819202122232425262728293031323334[root@centos-7 html]# mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 5.7.23 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; create database mantis;Query OK, 1 row affected (0.00 sec)mysql&gt; grant all privileges on mantis.* to root@localhost identified by '123456';ERROR 1819 (HY000): Your password does not satisfy the current policy requirementsmysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant all privileges on mantis.* to root@localhost identified by '123456';Query OK, 0 rows affected, 1 warning (0.01 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye[root@centos-7 html]#安装打开浏览器在地址栏输入 http://10.211.55.17:82/mantis – 格式为 http://IP:端口/mantis文件夹名称，这时就会自动跳转到php安装向导的页面:&#160;&#160;&#160;&#160;填好主机、密码等信息之后点击 Install/Upgrade Database 安装数据库。登录进入Mantis登录界面，输入用户密码：administrator/root ，登陆即可看到mantis主界面。邮件配置修改MantisBT/config/config_inc.php文件1234567891011$g_enable_email_notification = ON;$g_administrator_email = &apos;mailuser&apos;; # 邮箱地址$g_webmaster_email = &apos;mailuser&apos;; # 邮箱地址$g_from_email = &apos;mailuser&apos;; # 邮箱地址$g_from_name = &apos;Mantis Bug Tracker&apos;;$g_phpMailer_method = PHPMAILER_METHOD_SMTP;$g_smtp_host = &apos;smtp.163.com&apos;; # SMTP 服务器$g_smtp_username = &apos;mailuser&apos;; # 邮箱地址$g_smtp_password = &apos;mailpwd&apos;; # 邮箱密码$g_use_phpMailer = ON; $g_return_path_email = &apos;mailuser&apos;; # 邮箱地址中文配置修改/var/www/html/mantis/config_defaults_inc.php文件，在该文件中找到语言设置的地方，修改$g_default_language，将’english’改为’chinese_simplified’。懒得找的话直接复制下面的命令也可以。1# sed -i -e \"s/$g_default_language = 'auto'/$g_default_language = 'chinese_simplified'/g\" /var/www/html/mantis/config_defaults_inc.php问题解决问题描述：配置完成后，无法发送邮件。解决方法：邮箱配置问题，添加本地邮箱服务器，设置本地邮箱，对于本地测试邮箱，设置$g_smtp_host=本地IP地址。实例运行为了便于理解，先给出BUG跟踪流程图：Mantis使用流程图：新用户创建与登录目前本系统的访问地址为：http://IP:port/mantis/login_page.php，用户可以通过首页显示的&quot;注册一个新帐号&quot;进行新用户注册。然后点击邮箱内的激活邮件，进行用户名与密码的设置。也可以通过管理员创建新用户管理员可以对用户的角色、所属的项目以及一些其他的情况进行对应的配置。各种具体的配置以及各种角色用户的权限可参见管理员的管理视图。操作流程首先，说明一下系统中的角色和一般所对应的人员：观察者（复查员）、报告者（测试员）、升级者（审核员）、开发人员（开发员）、经理（项目经理）、管理员（系统管理员）。还要简单说明一下问题状态及相关含义（以上的两点只是中文理解和中文翻译的问题，可以在mantisbt-2.15.0/lang/strings_chinese_simplified.txt中修改）：新建：新提交的报告，默认状态为新建反馈：修正的问题经过测试后仍不完善认可：报告的问题确实存在已确认：通常为项目经理确认时使用已分配：分派给具体开发人员已解决：修改后的问题，可以进行测试已关闭：测试通过的问题，或者在报告周期内判定为无需修改的问题。下面介绍一下简单的操作流程，这里以管理员和报告者作为示例，这里为了方便示例，示例中管理员包含了其他角色属性。观察者、升级者以及经理可以根据具体情况进行添加。提交问题权限：全部角色必填信息：分类、摘要、描述、查看权限选填信息：出现频率、严重性、优先级、选择平台设置、重现步骤、辅助、标签、上传文件。问题单状态：新建审核问题权限：审核员、项目经理、（开发员）可进行操作：添加附件、添加注释问题单状态：新建 -&gt; 已审核（认可），审核员对问题进行审核，并确认此问题；新建 -&gt; 已关闭，审核员认为报告的问题不存在或无需修改。确认问题权限：项目经理问题单状态：认可 -&gt; 已确认，项目经理确认问题，确认后进入修改流程；认可 -&gt; 反馈，项目经理对问题存在异议，反馈给审核者。分派问题权限：项目经理、开发员问题单状态：已确认 -&gt; 已分派，项目经理分派问题给相应的开发人员；已分派 -&gt; 已分派，开发组长也可以给组员分派问题。修复问题权限：开发员问题单状态：已分派 -&gt; 已解决，分派给开发员的问题已修复及内部测试，可以提交业务测试时。测试问题权限：报告者问题单状态：已解决 -&gt; 已关闭，报告者对已解决的问题测试且测试通过；已解决 -&gt; 反馈，报告者对已解决的问题测试，而测试未通过，开发员可对反馈的问题继续修复，再进入后续环节。到此，整个流程结束。说明：整个流程中，问题处于不同的状态，标记的颜色不同。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"运维","slug":"Linux/运维","permalink":"https://iamzhl.top/categories/Linux/运维/"}],"tags":[{"name":"MantisBT","slug":"MantisBT","permalink":"https://iamzhl.top/tags/MantisBT/"},{"name":"Bug追踪","slug":"Bug追踪","permalink":"https://iamzhl.top/tags/Bug追踪/"}]},{"title":"awk to use","slug":"awk-to-use","date":"2018-08-05T10:01:00.000Z","updated":"2019-03-11T16:21:49.905Z","comments":true,"path":"awk-to-use.html","link":"","permalink":"https://iamzhl.top/awk-to-use.html","excerpt":"","text":"简介awk是Linux最常用的字符串处理工具awk 内置参数NR – 行号NF – 列总数FILENAME – 当前文件名实例打印/etc/passwd每行的行号，每行的字符总数以及第一行(即每行的用户名)print实现1$ awk -F ':' '&#123;print \"Line:\"NR,\"Col:\"NF,\"User:\"$1&#125;' /etc/passwdprintf实现1$ awk -F ':' '&#123;printf \"Line:%s,Col:%s,User:%s\\n\",NR,NF,$1&#125;' /etc/passwd打印/etc/passwd中UID(即第三列)大于100的行的行号，字符总数以及第一列(即每行的用户名)print实现1$ awk -F ':' '&#123;if ($3&gt;100) print \"Line:\"NR,\"Col:\"NF,\"User:\",$1&#125;' /etc/passwdprintf实现1$ awk -F ':' '&#123;if ($3&gt;100) printf(\"Line:%s,Col:%s,User:%s\\n\",NR,NF,$1)&#125;' /etc/passwd提取服务器日志fresh.log中ERROR行发生的时间fresh.log内容格式如下图利用sed和awk1$ sed '/ERROR/p' fresh.log | awk '&#123;print $1&#125;'只利用awk1$ awk '/ERROR/&#123;print $1&#125;' fresh.logSTART ENDawk提供了一个简单的方式在利用awk处理编程需求时的问题，例如制表时需在表前打印表头、表后打印表尾。举一个案例，制表显示/etc/passwd的行号、列号和用户名思路是首先在开头打印”Line Col User”，然后依次打印/etc/passwd每一行的行号、列号和用户名，最后另起一行打印--------并在中间加入awk操作的文件名以结束制表1$ awk -F ':' 'BEGIN&#123;print \"Line Col User\"&#125;&#123;print NR,NF,$1&#125;END&#123;print \"------\",FILENAME,\"------\"&#125;' /etc/passwd | grep -v \"#\"其中的grep -v &quot;#&quot;用以过滤掉/etc/passwd中开头的无用说明信息运行结果为截图方便这里只截了前面的一些行和最后的一些行","categories":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/categories/Linux/"},{"name":"学习","slug":"Linux/学习","permalink":"https://iamzhl.top/categories/Linux/学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://iamzhl.top/tags/Linux/"},{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/tags/学习/"}]},{"title":"quicksort","slug":"quicksort","date":"2018-07-20T04:53:01.000Z","updated":"2019-03-11T16:21:49.905Z","comments":true,"path":"quicksort.html","link":"","permalink":"https://iamzhl.top/quicksort.html","excerpt":"","text":"代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"stdio.h\"void quicksort(int a[], int left, int right) &#123; int i, j, t, temp; if(left &gt; right) return; temp = a[left]; i = left; j = right; while(i != j) &#123; while(a[j] &gt;= temp &amp;&amp; i &lt; j) j --; while(a[i] &lt;= temp &amp;&amp; i &lt; j) i ++; if(i &lt; j) &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; a[left] = a[i]; a[i] = temp; quicksort(a, left, i-1); quicksort(a, i+1, right);&#125; int main()&#123; int i, j, t; int n = 5; scanf(\"%d\", &amp;n); int a[n]; for(i = 1;i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); quicksort(a, 1, n); for(i=1; i &lt;= n; i++) printf(\"%d \", a[i]); putchar('\\n'); return 0; &#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"https://iamzhl.top/tags/快速排序/"}]},{"title":"High Sierra 和 Mojave 镜像大全","slug":"High-Sierra-and-Mojave-Images-update","date":"2018-07-15T07:58:04.000Z","updated":"2019-03-30T13:15:13.490Z","comments":true,"path":"High-Sierra-and-Mojave-Images-update.html","link":"","permalink":"https://iamzhl.top/High-Sierra-and-Mojave-Images-update.html","excerpt":"","text":"前言本人所有镜像均采用Applestore官方商店下载整包制作，适用于gpt分区表，加入了各个版本刚推送时的Clover源码最新引导，后续的测试版推送之后我会尽早做出供坛友使用，希望大家多多支持给楼主加个分，你们的支持就是我的动力楼主所做的镜像全部集成多驱动，多config，镜像所集成的这些东西只是方便大家用，坛友写入之后请适当删减使用，有能力的或者本身自己有一套适合自己的EFI的朋友请用自己的，望周知。PS: 镜像内驱动和config是为新手准备，老鸟勿喷镜像内有文件详细说明，新手请按说明自行配置引导。最近一次更新内容新款MacBook Pro上市之后，Apple推出特供版本以支持八代CPU，依然是10.13.6，此次版本号为17G2208，经测试，已原生支持八代机器此外,Clover也及时跟新了mbp15,1以及mbp15,2的SMBIOS，推荐大家使用，低压本用mbp15,2，其他mbp15,1，下面是SMBIOS，大家可以直接套用，记得修改BoardSerialNumber为自己之前正在用的。MacBook Pro 15,1123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;key&gt;SMBIOS&lt;/key&gt;&lt;dict&gt; &lt;key&gt;BiosReleaseDate&lt;/key&gt; &lt;string&gt;06/26/2018&lt;/string&gt; &lt;key&gt;BiosVendor&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;BiosVersion&lt;/key&gt; &lt;string&gt;MBP151.88Z.0178.B00.1806260902&lt;/string&gt; &lt;key&gt;Board-ID&lt;/key&gt; &lt;string&gt;Mac-937A206F2EE63C01&lt;/string&gt; &lt;key&gt;BoardManufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;BoardSerialNumber&lt;/key&gt; &lt;string&gt;C02418108QXF64WCB&lt;/string&gt; &lt;key&gt;BoardType&lt;/key&gt; &lt;integer&gt;11&lt;/integer&gt; &lt;key&gt;BoardVersion&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;ChassisAssetTag&lt;/key&gt; &lt;string&gt;MacBook-Aluminum&lt;/string&gt; &lt;key&gt;ChassisManufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;ChassisType&lt;/key&gt; &lt;string&gt;0x09&lt;/string&gt; &lt;key&gt;Family&lt;/key&gt; &lt;string&gt;MacBook Pro&lt;/string&gt; &lt;key&gt;FirmwareFeatures&lt;/key&gt; &lt;string&gt;0xFC0FE137&lt;/string&gt; &lt;key&gt;FirmwareFeaturesMask&lt;/key&gt; &lt;string&gt;0xFF1FFF3F&lt;/string&gt; &lt;key&gt;LocationInChassis&lt;/key&gt; &lt;string&gt;Part Component&lt;/string&gt; &lt;key&gt;Manufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;Mobile&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PlatformFeature&lt;/key&gt; &lt;string&gt;0x1A&lt;/string&gt; &lt;key&gt;ProductName&lt;/key&gt; &lt;string&gt;MacBookPro15,1&lt;/string&gt; &lt;key&gt;SerialNumber&lt;/key&gt; &lt;string&gt;C02X1HACKGYG&lt;/string&gt; &lt;key&gt;Version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt;&lt;/dict&gt;MacBook Pro 15,2123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;key&gt;SMBIOS&lt;/key&gt;&lt;dict&gt; &lt;key&gt;BiosReleaseDate&lt;/key&gt; &lt;string&gt;06/26/2018&lt;/string&gt; &lt;key&gt;BiosVendor&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;BiosVersion&lt;/key&gt; &lt;string&gt;MBP152.88Z.0178.B00.1806260902&lt;/string&gt; &lt;key&gt;Board-ID&lt;/key&gt; &lt;string&gt;Mac-827FB448E656EC26&lt;/string&gt; &lt;key&gt;BoardManufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;BoardSerialNumber&lt;/key&gt; &lt;string&gt;C02418108QXF64WCB&lt;/string&gt; &lt;key&gt;BoardType&lt;/key&gt; &lt;integer&gt;11&lt;/integer&gt; &lt;key&gt;BoardVersion&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;ChassisAssetTag&lt;/key&gt; &lt;string&gt;MacBook-Aluminum&lt;/string&gt; &lt;key&gt;ChassisManufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;ChassisType&lt;/key&gt; &lt;string&gt;0x09&lt;/string&gt; &lt;key&gt;Family&lt;/key&gt; &lt;string&gt;MacBook Pro&lt;/string&gt; &lt;key&gt;FirmwareFeatures&lt;/key&gt; &lt;string&gt;0xFC0FE137&lt;/string&gt; &lt;key&gt;FirmwareFeaturesMask&lt;/key&gt; &lt;string&gt;0xFF1FFF3F&lt;/string&gt; &lt;key&gt;LocationInChassis&lt;/key&gt; &lt;string&gt;Part Component&lt;/string&gt; &lt;key&gt;Manufacturer&lt;/key&gt; &lt;string&gt;Apple Inc.&lt;/string&gt; &lt;key&gt;Mobile&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PlatformFeature&lt;/key&gt; &lt;string&gt;0x1A&lt;/string&gt; &lt;key&gt;ProductName&lt;/key&gt; &lt;string&gt;MacBookPro15,2&lt;/string&gt; &lt;key&gt;SerialNumber&lt;/key&gt; &lt;string&gt;C02X1HACJHCD&lt;/string&gt; &lt;key&gt;Version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt;&lt;/dict&gt;镜像内容镜像地址每出一个版本都写一个帖子的话太麻烦，所以决定直接写一个镜像的集合贴，下面是各个版本的链接：1链接:https://pan.baidu.com/s/1ymm0dm2R3dlFGyCH88fbmA 密码:vvon镜像校验为防止下载文件损坏，请尽量进行MD5、SHA1、SHA256校验，校验文件以图片的形式存在于各个镜像文件夹内。镜像列表OS X EI CapitanOS X EI Capitan 10.11.6 15G31macOS SierramacOS Sierra 10.12.5 16F73macOS Sierra 10.12.6 16G29macOS High SierramacOS High Sierra DP1 17A264cmacOS High Sierra DP1 17A291mmacOS High Sierra DP1 17A306FmacOS High Sierra DP1 17A315imacOS High Sierra DP1 17A330hmacOS High Sierra DP1 17A344bmacOS High Sierra DP1 17A352amacOS High Sierra DP1 17A358amacOS High Sierra DP1 17A360amacOS High Sierra Golden Master 17A362amacOS High Sierra 10.13.0 17A365macOS High Sierra 10.13.0 17A405macOS High Sierra 10.13.1 17B48macOS High Sierra 10.13.2 17C88macOS High Sierra 10.13.2 17C88 光 - 暗影精灵 II 专用macOS High Sierra 10.13.3 17D47macOS High Sierra 10.13.4 17E199macOS High Sierra 10.13.5 17F77macOS High Sierra 10.13.6 17G65macOS High Sierra 10.13.6 17G2112macOS High Sierra 10.13.6 17G2208macOS MojavemacOS Mojave 10.14 DP1 18A293umacOS Mojave 10.14 DP2 18A324hmacOS Mojave 10.14 DP3 18A326hmacOS Mojave 10.14 DP4 18A336emacOS Mojave 10.14 DP5 18A347emacOS Mojave 10.14 DP6 18A353dmacOS Mojave 10.14 DP7 18A365amacOS Mojave 10.14 DP8 18A371amacOS Mojave 10.14 DP9 18A377amacOS Mojave 10.14 DP10 18A384amacOS Mojave 10.14 Golden Master 18A389macOS Mojave 10.14.0 18A389macOS Mojave 10.14.1 18B75macOS Mojave 10.14.1 18B2107macOS Mojave 10.14.1 18B3094macOS Mojave 10.14.2 18C54macOS Mojave 10.14.3 18D42macOS Mojave 10.14.4 18E226macOS Mojave 10.14.4 18E2034 (iMac 19 特供版)","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"原版镜像","slug":"原版镜像","permalink":"https://iamzhl.top/tags/原版镜像/"},{"name":"黑苹果镜像","slug":"黑苹果镜像","permalink":"https://iamzhl.top/tags/黑苹果镜像/"}]},{"title":"mac 上使用字符串处理神器 sed 的正确姿势","slug":"Command-sed-on-mac","date":"2018-07-07T14:04:34.000Z","updated":"2019-03-11T16:21:49.886Z","comments":true,"path":"Command-sed-on-mac.html","link":"","permalink":"https://iamzhl.top/Command-sed-on-mac.html","excerpt":"","text":"简介sed是shell中字符串处理的三大神器之一，利用sed进行字符串处理对从事Linux相关职业的人来说是必不可少的，但是在mac上的sed与Linux的sed是有一定区别的，为什么呢，因为mac实质上和Linux就是不一样的，尽管其中很多基本命令是通用的，例如ls、cd、pwd等。mac是unix内核，是基于FreeBSD的，而我们常用的Linux如Ubuntu、CentOS等是Linux内核。sed的不同非常大的一个坑就是sed命令的不统一，Linux的sed是基于GNU的sed，而FreeBSD中的sed则是基于XNU的，其用法有些不同，下面会做对比简要说明。拿最常用的追加行来说，我们假设一个场景，我需要对test.txt文件实时写入，在文件第二行添加1234，文件初始内容如下所示1234567$ cat test.txt333311123333test44445555在Linux下，我们只需要执行下面的命令即可实现追加1$ sed -i -e '1a\\1234' test.txt但是在mac下这条命令会报错如下1sed: 1: &quot;1a\\1234&quot;: extra characters after \\ at the end of a command这是因为xnu的sed命令用法不同于gnu，具体可以通过下面的命令查看sed命令手册1$ man sed那么我想用我习惯的Linux的GNU-sed怎么解决呢，我们可以安装gnu-sed来代替系统内的sed，具体方法如下首先我们需要Homebrew包管理器1$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"然后，通过brew来安装gnu-sed1$ brew install gnu-sed默认brew会将gnu-sed安装到/usr/local/Cellar/目录下，这时我们就可以利用gsed来执行了1$ gsed -i -e '1a\\1234' test.txt如果提示命令找不到的话，只需要将下面的路径添加到PATH环境变量就可以了1/usr/local/Cellar/gnu-sed/4.5/bin/或者将/usr/local/Cellar/gnu-sed/4.5/bin/gsed添加别名都可以。网上也有人用下面的命令安装1$ brew install gnu-sed --with-default-names貌似这种方式直接替代了系统内的sed，我个人不是很推荐这种方式，不是说不好，而是当我们的机器不只是一个人用，是做服务器用的，或者有一些我们正在用的脚本里面有xnu的sed调用，那么这种方式就会造成一些问题，所以我个人认为安装了gnu-sed后，利用别名、环境变量、配置文件等方式调用是更好的一种方法，当然，这个根据个人需求决定就好了。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"sed","slug":"sed","permalink":"https://iamzhl.top/tags/sed/"},{"name":"gnu-sed","slug":"gnu-sed","permalink":"https://iamzhl.top/tags/gnu-sed/"},{"name":"xnu-sed","slug":"xnu-sed","permalink":"https://iamzhl.top/tags/xnu-sed/"}]},{"title":"iTerm2 + ohmyzsh + powerlevel9k + tmux 打造专属个性化终端","slug":"Custom-terminal-on-your-mac","date":"2018-06-26T03:04:23.000Z","updated":"2019-03-11T16:21:49.888Z","comments":true,"path":"Custom-terminal-on-your-mac.html","link":"","permalink":"https://iamzhl.top/Custom-terminal-on-your-mac.html","excerpt":"","text":"先来张图镇楼首先搭建好安装homebrew环境在mac上拥有一个好的包管理器是非常重要的，Debian家族有apt，mac有homebrew，非常好用。1$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"安装oh-my-zshoh-my-zsh是一款非常好用且美观的shell工具，其命令的补全等都是其他如bash、csh等所无法比拟的安装方式两种通过curl1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"通过wget1$ sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"安装完成后设定zsh为默认shell1$ chsh -s /bin/zsh设定oh-my-zsh的主题oh-my-zsh支持非常多的主题，这里我将我个人比较喜欢的主题powerlevel9k作为实例1$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k然后修改zsh的配置文件1$ vim ~/.zshrc将ZSH_THEME设定为powerlevel9k，如图然后保存退出，使配置文件重新生效1$ source ~/.zshrc安装iTerm2iTerm2是一款替代系统内置终端的工具，其功能更强大，可定义扩展性也更强1$ brew cask install iterm2安装archey小工具archey是一个命令行美化工具，其可以在运行终端程序时为用户显示打印出一个七彩的苹果logo这个工具的原作者是obihann，我将其按照自己的习惯进行了一些修改，并做了汉化，朋友们可以自行选择原作者的安装方式1brew install archey我个人修改的和汉化的可以通过我GitHub仓库中Pages页面的README说明文档进行安装，按照要求安装并配置完成后，退出终端再重新打开就可以发现终端可以自动打印图中的七彩苹果了。https://athlonreg.github.io/archey-osx/安装tmux小工具Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。1$ brew install tmux安装完成后输入命令tmux即可打开软件，界面十分简单，类似一个下方带有状态栏的终端控制台安装完成后，我们将其再美化一下1234$ cd ; rm -rf .tmux$ git clone https://github.com/gpakosz/.tmux.git$ ln -s .tmux/.tmux.conf$ cp .tmux/.tmux.conf.local .美化结束到这里，相信你应该和我开头的截图有一样的效果了，如果没有的话，可以在本文后面评论，我会尽快回复。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"iTerm2","slug":"iTerm2","permalink":"https://iamzhl.top/tags/iTerm2/"},{"name":"tmux","slug":"tmux","permalink":"https://iamzhl.top/tags/tmux/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://iamzhl.top/tags/oh-my-zsh/"},{"name":"终端美化","slug":"终端美化","permalink":"https://iamzhl.top/tags/终端美化/"},{"name":"archey","slug":"archey","permalink":"https://iamzhl.top/tags/archey/"}]},{"title":"集成 CLOVER 引导的黑苹果原版镜像制作教程","slug":"Make-a-boot-img-of-OS-X-with-Clover","date":"2018-06-14T02:27:33.000Z","updated":"2019-03-11T16:21:49.896Z","comments":true,"path":"Make-a-boot-img-of-OS-X-with-Clover.html","link":"","permalink":"https://iamzhl.top/Make-a-boot-img-of-OS-X-with-Clover.html","excerpt":"","text":"准备工作macOS环境(虚拟机实机均可)Clover的pkg安装包(可以去我Github找，保证源码最新，传送门)app格式的原版镜像(可以去App Store下载)制作过程新建空白镜像打开终端，状态栏新建一个空白磁盘，名字任意，不要有中文，大小我们这里设置为6.8G，格式为HFS，即mac os扩展日志式，不要太小，也不建议太大，将其保存至桌面。示例中我做的是10.14的镜像，名字用macOS Mojave 10.14 beta 1 with Clover 4539 18A293u，当然这个看自己心情。然后你就发现桌面会多出一个dmg文件和挂载后的一个磁盘。至此空白镜像新建完成利用命令写入app镜像到空白镜像打开终端，输入命令来将镜像写进刚才我们新建的那个空盘，命令的大体格式如下：1$ sudo createinstallmedia制作工具 --volume 空盘 –applicationpath app镜像 --nointeraction从macOS Mojave开始，--applicationpath参数被抛弃，因此，10.14以后的写入命令为下面的1$ sudo createinstallmedia制作工具 --volume 空盘 --nointeraction由于命令较长，在此稍作说明，方便朋友们理解，以支持更为广泛的命令为例，首先输入sudo后边跟一个空格，然后找到app镜像，右键显示包内容，依次进入/Contents/Resources,找到一个名为createinstallmedia的文件，将其拖到终端，然后空格输入--volume再空格，然后将磁盘工具新建的那个空白镜像自动挂载后的空磁盘拖进来，空格输入--applicationpath，再空格将整个app镜像拖进来，空格输入--nointeraction,最后空格回车输入密码再回车，静静等待写入完成即可。这时你会发现桌面的那个空磁盘现在已经有内容了，而且也有了自己的图标到这里镜像已经写入完成集成四叶草引导写入完成之后，如果你不打算集成四叶草，请略过这一步看下一步。找到准备好的pkg格式的CLOVER安装包，双击打开按继续再次按继续选择更改安装位置，选择做好的安装盘，然后选择继续选择自定，弹出下面的对话框按照下面勾选的方式进行择选选项，然后选择安装，输入密码安装完成后选择关闭这时我们会发现桌面多出了一个EFI磁盘，这就是我们安装CLOVER后自动挂载的引导盘为了让我们的镜像更加干净，打开桌面上挂载的镜像磁盘，删除里面的EFI-Backups至此集成CLOVER完成定制四叶草引导上面我们已经集成好了CLOVER引导，但是现在集成的CLOVER是杂乱的没有意义的，我们需要进行定制，这里我可以将我本机正在用的CLOVER引导定制进去，以达到我使最终镜像成为我本机专用的写入U盘后直接引导可以完美的镜像打开桌面的自动挂载的EFI磁盘，依次打开EFI -&gt; CLOVER将我自己的引导的必要文件导入进去，有ACPI、kexts、config.plist，然后将一些没用的文件删除以精简我们的镜像，例如drivers64、OEM、kexts下除Other之外的其他文件夹和themes下的除去我们需要的主题之外的其他文件，经过以上所述的处理之后，我的CLOVER定制完成，如下至此CLOVER定制完成推出镜像盘CLOVER定制完成我们需要将镜像磁盘推出以压缩镜像。右键桌面的那两个挂载后的磁盘，选择推出至此推出镜像盘完成转换压缩镜像到了最后一步，这时我们的镜像其实已经做完了，只是它个头很大，我们需要将其压缩一下，让它和应用商店下载的app格式的镜像大小相近。打开磁盘工具，状态栏依次选择映像-&gt; 转换弹出的对话框选择我们桌面的那个大镜像，点击选取然后弹出存储选项的对话框这里存储为后面的名字和刚开始起的名字一致好了，位置选择文稿，这个看自己心情吧。然后点击转换然后静静等待，直到完成。转换完成后，点击完成退出磁盘工具，文稿中会出现一个和你当初下载的app原版镜像大小差不多的dmg文件，这就是我们最后需要的原版镜像了。将此镜像拿到windows电脑上，用Transmac写进U盘，由于我做的是集成我自己引导专用的CLOBER，所以重启就可以愉快的黑苹果咯。视频链接为了方便大家理解，我将过程做了一个视频，大家可以简单看看1链接:https://pan.baidu.com/s/1g0J8zxqut4S2JYxtJV8IXw 密码:vcjo关于打赏码字不易，你们的支持是我分享和创作的动力，欢迎打赏。","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"原版镜像","slug":"原版镜像","permalink":"https://iamzhl.top/tags/原版镜像/"},{"name":"黑苹果镜像","slug":"黑苹果镜像","permalink":"https://iamzhl.top/tags/黑苹果镜像/"},{"name":"dmg","slug":"dmg","permalink":"https://iamzhl.top/tags/dmg/"}]},{"title":"使用Hibernate反向工程自动产生实体类和映射文件","slug":"Use-Hibernate-reverse-engineering-to generate-entity-classes-and-mapping-files-automatically","date":"2018-05-31T13:07:42.000Z","updated":"2019-03-11T16:21:49.904Z","comments":true,"path":"Use-Hibernate-reverse-engineering-to generate-entity-classes-and-mapping-files-automatically.html","link":"","permalink":"https://iamzhl.top/Use-Hibernate-reverse-engineering-to generate-entity-classes-and-mapping-files-automatically.html","excerpt":"","text":"使用Hibernate反向工程自动产生实体类和映射文件一、首先建立一个项目工程二、建立数据库表 – 以student表为例三、在项目中配置好数据库并建立一个model包四、生成数据库映射五、配置数据源、数据表，生成注解，加入session工厂等六、弹出确认导入数据库的窗口点击Yes七、这时带有注解的Student类和配置好映射的hibernate.cfg.xml就成功生成了","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://iamzhl.top/tags/GitHub/"},{"name":"团队开发","slug":"团队开发","permalink":"https://iamzhl.top/tags/团队开发/"},{"name":"分支管理","slug":"分支管理","permalink":"https://iamzhl.top/tags/分支管理/"}]},{"title":"黑苹果声卡 cx20751/2 驱动方法","slug":"Drive-CX20751-2-audio-on-hackintosh","date":"2018-05-02T15:10:57.000Z","updated":"2019-03-11T16:21:49.889Z","comments":true,"path":"Drive-CX20751-2-audio-on-hackintosh.html","link":"","permalink":"https://iamzhl.top/Drive-CX20751-2-audio-on-hackintosh.html","excerpt":"","text":"准备工作首先从linux提取codec，然后整理codec提取节点数据，参考我的另一篇帖子http://blog.athlonreg.top/Driver-audio-for-hackintosh.html对比节点数据这里拿我的CX20751为例，codec整理的数据如下看其中的Line in节点，即Mic at Ext，我的是0x19，那么我的AppleALC就需要注入Layout-ID为28，如果你的CX20751/2提取的数据中此节点是0x18，就需要注入Layout-ID为3。注入Layout-IDDSDT方式挂载你的ESP分区，打开DSDT，打上声卡Layout-ID注入补丁如图，3和12都可以，我拿12为例，点击此补丁，将如下图中的12改为28，然后点击Apply。如果你的需要注入3，只需直接打上那个为3的补丁即可Hotpatch方式将图中三个SSDT放入/EFI/CLOVER/ACPI/patched，三个文件分别做以下修改，我的是28改为0x1C，如果你的是3，则改为0x03。然后在config.plist中勾选以下选项config方式同样勾选以下选项然后注入ID，此处根据前面的Layout-ID决定注入3还是28放驱动将AppleALC、Lilu、CodecCommander三个驱动放到/EFI/CLOVER/kexts/Otherhttps://github.com/vit9696/AppleALC/releaseshttps://github.com/vit9696/Lilu/releaseshttps://bitbucket.org/RehabMan/os-x-eapd-codec-commander/downloads/注意三个驱动都用Release里面的放SSDT打开终端执行1$ git clone https://github.com/RehabMan/OS-X-Clover-Laptop-Config利用MaciASL打开SSDT-CX20752.dsl，将其另存为SSDT-CX20752.aml。保存至/EFI/CLOVER/ACPI/patched,如果你正在使用SortedOrder，则将其加入进去。然后保存全部工作重启。声卡输入修复若遇到声卡内建输入或耳机线路输入无电平的情况，请继续以下步骤。下载ALCPlugFix for AppleALC.ziphttps://github.com/athlonreg/ASUS-F455LD-i5-4210u打开终端执行1$ git clone https://github.com/athlonreg/ASUS-F455LD-i5-4210u下载完成后，如果你的Layout-ID是3，则将其中的ALCPlugFix-LayoutID=3.zip解压至桌面，若为28则将其中的ALCPlugFix-LayoutID=28.zip解压至桌面，执行123$ cd ~/Desktop/ALCPlugFix/alc_fix $ chmod +x install.sh $ ./install.sh然后根据提示输入密码回车。最后保存重启即可。","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"cx20751","slug":"cx20751","permalink":"https://iamzhl.top/tags/cx20751/"},{"name":"cx20752","slug":"cx20752","permalink":"https://iamzhl.top/tags/cx20752/"},{"name":"ALCPlugFix","slug":"ALCPlugFix","permalink":"https://iamzhl.top/tags/ALCPlugFix/"}]},{"title":"利用 GitHub 进行团队多分支开发","slug":"Use-GitHub-for-team-development","date":"2018-04-21T14:07:42.000Z","updated":"2019-03-11T16:21:49.904Z","comments":true,"path":"Use-GitHub-for-team-development.html","link":"","permalink":"https://iamzhl.top/Use-GitHub-for-team-development.html","excerpt":"","text":"创建项目本文以GitHub项目为例:1https://github.com/athlonreg/Common-patches-for-hackintosh.git然后在本地克隆项目代码：1$ git clone https://github.com/athlonreg/Common-patches-for-hackintosh.git查看项目分支情况可以使用命令12$ git branch * master可以看到当前项目坐在的分支是master（*号后边为当前所在分支名）。而且项目目前也只有一个分支，就是master。团队开发但是我们在实际项目开发中，通常都是以团队开发为主，所以为了维护线上主干代码的稳定，我们也都会采取创建分支 -&gt; 开发 -&gt; 测试 -&gt; 合并 -&gt; 上线的形式进行实际操作的。接下来描述一下简单的团队开发Git项目。本地分支工程师A需要对原来的代码做改动，这时他需要创建一个开发分支，假设名字为dev1234$ git branch dev$ git branch dev* master这个时候我们看到本地工作区已经有两个分支：master和dev。但当前工作区还是在master上（注意*号位置），需要手动切换到dev上。只需使用git checkout命令12345$ git checkout devSwitched to branch &apos;dev&apos;$ git branch* dev master当然有人希望创建分支后直接切换到新的分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos;这样就将当前工作区切换到新的分支中，我们可以发现此时的dev分支中的内容是master的复制。远程分支现在的dev分支只是存在于A的本地环境，当工程师B打算协同A进行相同业务的开发时，他也需要拿到dev分支的代码，那该怎么获取呢？此时需要A将本地分支推送到远程分支，以供给其他工程师共同开发。使用git branch -a能够查询当前所有分支，包括本地分支和远程分支（下边remotes/origin开头）1234$ git branch -a* dev master remotes/origin/master发现并没有远程分支里并没有新建的dev，这时需要执行git push origin dev命令，将本地dev分支推送到GitHub服务器，生成远程分支。1234$ git push origin devTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/athlonreg/Common-patches-for-hackintosh * [new branch] dev -&gt; dev这时再用git branch -a查看分支。12345$ git branch -a* dev master remotes/origin/dev remotes/origin/master可以看到多了一个名为remotes/origin/dev的分支，即为创建的远程分支。好了，现在B和其他任何工程师都可以通过拉取远程分支获取A创建的dev分支代码。B先做一次分支查询1234$ git branch -a* master remotes/origin/dev remotes/origin/master发现存在remotes/origin/dev远程分支。此时只需执行git fetch origin dev:dev将远程分支代码拉取到本地.。12345678$ git fetch origin dev:devFrom https://github.com/athlonreg/Common-patches-for-hackintosh * [new branch] dev -&gt; dev$ git branch -a dev* master remotes/origin/dev remotes/origin/master再通过查询可以看到本地多了一个dev本地分支。git fetch origin dev:dev这个命令的意思是将远程dev分支代码拉取到本地dev分支中。这是一个快捷的方式，如果B本地没有dev分支，该命令会创建一个名为dev的分支，如果B本地有自己的分支，如B_dev，则可以执行git fetch origin dev:B_dev或者先切到B_dev分支内，执行git fetch origin dev即可。多人开发此时A和B就可以切到本地dev分支进行开发了。假如B的开发修复了某个BUG，需要提交推送申请123$ git add .$ git commit -m &quot;Some fix&quot;$ git push origin dev在B将分支推送到她的远程仓库（不是别人维护的正式仓库，是他fork的仓库）后，去GitHub网页端点击Pull requests提交合并申请。弹出表单并要求他设置源分支、目标仓库和目标分支，默认设置B的仓库为源仓库。A需要合并他的代码，所以他设置他的分支为源分支，目标仓库为A的共有正式仓库，目标分枝为主干分支dev，还需要输入标题和提交的修改描述。提交申请后，A就会通过邮件或者订阅收到通知。A在网页端点击Pull requests后Merge requests即可合并提交。这时如果A想再次进行开发，就必须要将远程dev分支fetch到本地，如下:开发过程中每个工程师在推送代码之前要先执行拉取操作，因为远程仓库有更新的话，不先拉取（pull/fetch）是无法推送（push）的，尽量少使用git pull进行拉取，而是先用git fetch拉取再进行git merge。1234567$ git fetch origin dev From https://github.com/athlonreg/Common-patches-for-hackintosh * branch dev -&gt; FETCH_HEADUpdating 23b74f3..ea1c09fFast-forward config_patches.plist | 178 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 178 insertions(+)当然git pull也可以1234567$ git pull origin devFrom https://github.com/athlonreg/Common-patches-for-hackintosh * branch dev -&gt; FETCH_HEADUpdating 23b74f3..ea1c09fFast-forward config_patches.plist | 178 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 178 insertions(+)在每个开发阶段都及时地提交代码（git commit）并推送（git push）至远程仓库，可以使用git status检查工作区是否还有未处理的代码和文件。在提交代码的时候写好优秀的注释。1$ git add .1$ git commit -m &quot;Some fix (credit by A)&quot;1$ git push origin dev在项目代码将要合并到主干master的时候，要由一名工程师做最后的合并处理，如创建分支的A。由于在合并代码时极易产生冲突，所以一定要先与主干代码版本做对比（git diff），合并时可以使用git merge，当然如果dev可以废除的话，也可以使用git rebase做最后的合并。12345678910111213$ git checkout master Switched to branch &apos;master&apos;$ git merge dev Updating 23b74f3..ea1c09fFast-forward config_patches.plist | 178 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 178 insertions(+) $ git push origin master Total 0 (delta 0), reused 0 (delta 0)To https://github.com/athlonreg/Common-patches-for-hackintosh 23b74f3..ea1c09f master -&gt; master最后在分支代码合并到主干或者代码上线后，dev分支完成了自己的任务，可以删除本地分支和远程分支。删除本地分支：123456$ git branch -d devDeleted branch dev (was 1fe1352).$ git branch -a* master remotes/origin/dev remotes/origin/master删除远程分支：123456$ git push origin --delete devTo https://github.com/athlonreg/Common-patches-for-hackintosh - [deleted] dev$ git branch -a* master remotes/origin/master解决冲突在代码的合并阶段（git pull或者git merge命令），通常会产生代码冲突。如果是其他工程师造成的冲突，需要转给相关工程师处理，也造成大量的沟通成本。为了减少冲突，建议每个工程师各自单独负责模块，业务互相不冲突。在解决冲突时，需要使用git log和git diff来检查历史版本的修改信息1$ git log README.mdgit log可以列出该文件的历史提交版本，能看到提交的版本号和提交的注释信息。然后使用git diff来对比该文件两个版本的不同。1$ git diff需要回退到某一版本，可以使用git reset命令1$ git reset --hard 265886db0d6868cc669e0ef253e6e9ac1e39319c如果文件尚未提交，也可以用git checkout filename恢复到提交前。12345$ git statusOn branch devnothing to commit, working tree clean$ git checkout README.md开发规范12$ git config --global user.name &quot;用户名&quot;。 $ git config --global user.email &quot;电子邮件&quot; 。团队开发禁止在主干直接修改代码，一定要开分支，而且是远程分支进行开发。创建分支可以打标签，git tag。拉取代码时最好先git fetch再git merge而不是直接git pull。提交代码和推送代码以及代码上线之前，一定要先和原来版本对比git diff。提交代码加注释git commit -m &#39;B developed&#39;。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://iamzhl.top/tags/GitHub/"},{"name":"团队开发","slug":"团队开发","permalink":"https://iamzhl.top/tags/团队开发/"},{"name":"分支管理","slug":"分支管理","permalink":"https://iamzhl.top/tags/分支管理/"}]},{"title":"AppleALC 目前支持的 Codec","slug":"Supported-codecs-by-AppleALC","date":"2018-04-18T12:41:37.000Z","updated":"2019-03-11T16:21:49.902Z","comments":true,"path":"Supported-codecs-by-AppleALC.html","link":"","permalink":"https://iamzhl.top/Supported-codecs-by-AppleALC.html","excerpt":"","text":"Currently supported codecsVendorCodecRevisionsMinKernelMaxKernelCreativeCA01320x100918 layout 0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 1213 (10.9)—CirrusLogicCS42100x100101 layout 1313 (10.9)—CirrusLogicCS42130x100100 layout 2813 (10.9)—RealtekALC221layout 1112 (10.8)—RealtekALC225/ALC3253layout 28, 30, 3313 (10.9)—RealtekALC230layout 13, 2013 (10.9)—RealtekALC233layout 3, 13, 27, 32, 3313 (10.9)—RealtekALC235layout 3, 11, 2813 (10.9)—RealtekALC2360x100001, 0x100002 layout 3, 11, 13, 1513 (10.9)—RealtekALC3236layout 4, 5, 28, 2913 (10.9)—RealtekALC255layout 3, 13, 17, 18, 27, 28, 9913 (10.9)—RealtekALC256 (3246)layout 11, 13, 5613 (10.9)—RealtekALC257layout 1113 (10.9)—RealtekALC260layout 11, 1213 (10.9)—RealtekALC2620x100202 layout 11, 12, 13, 2813 (10.9)—RealtekALC268layout 313 (10.9)—RealtekALC2690x100004, 0x100100, 0x100202, 0x100203 layout 1-11, 13-16, 18-20, 27-30, 32, 33, 35, 40, 45, 58, 66, 76, 93, 99, 12712 (10.8)—RealtekALC2700x100100, layout 3, 4, 27, 2813 (10.9)—RealtekALC271xlayout 9, 3112 (10.8)—RealtekALC2720x100001, layout 3, 1113 (10.9)—RealtekALC2750x100005, 0x100008, layout 3, 13, 2813 (10.9)—RealtekALC280layout 3, 4, 11, 13, 1513 (10.9)—RealtekALC2820x100003, layout 3, 4, 13, 27, 28, 29, 76, 86, 12712 (10.8)—RealtekALC283layout 1, 3, 11, 6613 (10.9)—RealtekALC284layout 313 (10.9)—RealtekALC285layout 1113 (10.9)—RealtekALC2860x100002, 0x100003 layout 313 (10.9)—RealtekALC288layout 3, 1313 (10.9)—RealtekALC290layout 3, 2813 (10.9)—RealtekALC3241layout 413 (10.9)—RealtekALC292layout 12, 18, 2813 (10.9)—RealtekALC293layout 28, 2913 (10.9)—RealtekALC294layout 11, 12, 1313 (10.9)—RealtekALC295layout 1, 3, 13, 14, 15, 2813 (10.9)—RealtekALC2980x100101, 0x100103 layout 3, 11, 13, 28, 29, 30, 47, 66, 72, 9913 (10.9)—RealtekALC6620x100101, 0x100300 layout 5, 7, 11, 12, 1313 (10.9)—RealtekALC6630x100001, 0x100002, layout 3, 4, 28, 9913 (10.9)—RealtekALC665layout 12, 1313 (10.9)—RealtekALC6680x100003, layout 3, 20, 27, 28, 2913 (10.9)—RealtekALC6700x100002, layout 1213 (10.9)—RealtekALC671layout 1213 (10.9)—RealtekALC8820x100101, layout 5, 713 (10.9)—RealtekALC8830x100002, layout 713 (10.9)—RealtekALC8850x100101, 0x100103 layout 1, 1213 (10.9)—RealtekALC8870x100202, 0x100302, layout 1, 2, 3, 5, 7, 11, 13, 17, 18, 33, 50, 9913 (10.9)—RealtekALC888/ALC12000x100101, 0x100001, 0x100202, 0x100302 layout 1, 2, 3, (4 for laptop), 5, 7, 11, 27, 28, 2913 (10.9)—RealtekALC8890x100004, layout 1, 11, 1213 (10.9)—RealtekALC891/ALC8670x100002, layout 11, 1313 (10.9)—RealtekALC8920x100302, layout 1, 2, 3, (4 for laptop), 5, 7, 12, 28, 31, 92, 98, 9913 (10.9)—RealtekALC898/ALC8990x100003, layout 1, 2, 3, 5, 7, 11, 13, 28, 65, 98, 99, 10113 (10.9)—RealtekALC11500x100001, layout 1, 2, 3, 5, 7, 1112 (10.8)—RealtekALC12200x100003, layout 1, 2, 5, 7, 11, 1315 (10.11)—RealtekALCS1220Alayout 1, 2, 5, 715 (10.11)—AnalogDevicesAD19840x100400, layout 1113 (10.9)—AnalogDevicesAD1984A0x100400, layout 11, 1313 (10.9)—AnalogDevicesAD1988Blayout 5, 7, 1213 (10.9)—AnalogDevicesAD2000Blayout 5, 713 (10.9)—ConexantCX8050layout 316 (10.12)—ConexantCX8200layout 316 (10.12)—ConexantCX205610x100000, layout 1113 (10.9)—ConexantCX20583layout 313 (10.9)—ConexantCX20585layout 3, 1313 (10.9)—ConexantCX20588layout 313 (10.9)—ConexantCX205900x100000, 0x100002, 0x100003, layout 3, 12, 2813 (10.9)—ConexantCX20641layout 11, 1313 (10.9)—ConexantCX20642layout 11, 1313 (10.9)—ConexantCX20722layout 316 (10.12)—ConexantCX20724layout 3, 1313 (10.9)—ConexantCX20751/20752layout 3, 2813 (10.9)—ConexantCX20753/4layout 316 (10.12)—ConexantCX20755layout 313 (10.9)—ConexantCX20756layout 3, 1313 (10.9)—ConexantCX20757layout 313 (10.9)—IDTIDT92HD66C3/65layout 313 (10.9)—IDTIDT92HD71B7Xlayout 313 (10.9)—IDTIDT92HD73C1X5layout 1913 (10.9)—IDTIDT92HD75B2X5layout 313 (10.9)—IDTIDT92HD75B3X5layout 3, 1113 (10.9)—IDTIDT92HD99BXXlayout 313 (10.9)—IDTIDT92HD87B1layout 313 (10.9)—IDTIDT92HD81B1C5layout 3, 1113 (10.9)—IDTIDT92HD81B1X5layout 3, 11, 12, 20, 21, 2813 (10.9)—IDTIDT92HD87B1/3layout 12, 1313 (10.9)—IDTIDT92HD87B2/4layout 1213 (10.9)—IDTIDT92HD90BXXlayout 3, 1213 (10.9)—IDTIDT92HD91BXX0x100102, 0x100303 layout 3, 12, 13, 33, 8413 (10.9)—IDTIDT92HD93BXX0x100203, layout 1213 (10.9)—IDTIDT92HD95layout 1213 (10.9)—VIAVT18020x100000, layout 3, 3313 (10.9)—VIAVT2020/20210x100100, layout 5, 7, 913 (10.9)—IntelHD460013 (10.9)—AMDRadeon 290/290X15 (10.11)—NvidiaGK20817 (10.13.4)—NvidiaGM20017 (10.13.4)—NvidiaGM20417 (10.13.4)—NvidiaGM20617 (10.13.4)—NvidiaGP10217 (10.13.4)—NvidiaGP10417 (10.13.4)—NvidiaGP10617 (10.13.4)—NvidiaGP10717 (10.13.4)—NvidiaGP10817 (10.13.4)—Creditshttps://github.com/vit9696/AppleALC/wiki/Supported-codecs","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"AppleALC","slug":"AppleALC","permalink":"https://iamzhl.top/tags/AppleALC/"},{"name":"codec","slug":"codec","permalink":"https://iamzhl.top/tags/codec/"}]},{"title":"struts2 中 s:iterator 标签的使用详解","slug":"Intro-about-iterator-in-struts2","date":"2018-04-11T02:12:17.000Z","updated":"2019-03-11T16:21:49.895Z","comments":true,"path":"Intro-about-iterator-in-struts2.html","link":"","permalink":"https://iamzhl.top/Intro-about-iterator-in-struts2.html","excerpt":"","text":"简单的Demos:iterator 标签有三个属性：value: 被迭代的集合id: 指定集合中元素的idstatus: 迭代元素的索引jsp页面定义元素写法 数组或list123&lt;s:iterator value=\"&#123;'1','2','3','4','5'&#125;\" &gt; &lt;s:property value='number'/&gt;A&lt;/s:iterator&gt;打印结果为: 1A2A3A4A5A索引的用法如果指定了status，每次的迭代数据都有IteratorStatus的实例，它有以下几个方法int getCount() – 返回当前迭代了几个元素int getIndex() – 返回当前元素索引boolean isEven() – 当前的索引是否偶数boolean isFirst() – 当前是否第一个元素boolean isLast() – 当前是否最后一个元素boolean isOdd() – 当前元素索引是否奇数123456&lt;s:iterator value=\"&#123;'a','b','c'&#125;\" status='st'&gt; &lt;s:if test=\"#st.Even\"&gt; 现在的索引是奇数为:&lt;s:property value='#st.index'/&gt; &lt;/s:if&gt; 当前元素值：&lt;s:property value='char'/&gt;&lt;/s:iterator&gt;遍历mapvalue可以直接定义为:1value=\"#&#123;\"1\":\"a\",\"2\":\"b\"&#125;\"每个元素以逗号隔开，元素之间的key和value冒号隔开。value也可以是数据栈里面的java.util.Map对象遍历写法如下：1234&lt;s:iterator value=\"map\" status=\"st\"&gt; key : &lt;s:property value='key'/&gt; value:&lt;s:property vlaue='value'/&gt;&lt;/s:iterator&gt;当然key和value都可以是java的 Object。遍历数据栈 – 简单的List类1234567891011List&lt;Attr&gt; class Attr&#123; String attrName; String getAttrName() &#123; return \"123\"; &#125;&#125;&lt;s:iterator value=\"label\" &gt; &lt;s:property value=\"#id.attrName\" /&gt;&lt;/s:iterator&gt;当然value还可以写成value=&quot;%{label}&quot;，label可以用.操作label的属性List，可以写成value=&quot;%{label.list}&quot;，相当于: getLabel().getList()；遍历 2 个list12List&lt;AttrName&gt; attrN &#123;color,size,style&#125;List&lt;AttrValue&gt; attrV &#123;red,20,gay&#125;这 2 个list的元素是一一对应的，一个attrN对应一个attrV12345678910111213&lt;s:iterator value=\"%&#123;attrN&#125;\" status=\"status\"&gt; index is : &lt;s:property value='status.index'/&gt; attrName is : &lt;s:property value='id'/&gt; or &lt;s:property value='%&#123;id&#125;'/&gt; attrName is : &lt;s:property value='%&#123;attrV[#status.index]&#125;'/&gt;&lt;/s:iterator&gt;&lt;s:bean&gt; &lt;s:param value=\"5\" /&gt; &lt;s:param value=\"10\" /&gt; &lt;s:iterator&gt; counter:&lt;s:property/&gt; &lt;/s:iterator&gt;&lt;/s:bean&gt;这个标签主要的的作用就是迭代出集合。value属性表示需要跌代显示出来的值。status属性，又来保存迭代时的一些状态值。注：如果需要引用valueStack中的值，需要使用这样的形式。1&lt;s:iterator value=\"#userList\" /&gt; //userList在action部分被保存在Request中，所以使用#加属性名来引用值。如果集合的值是通过action的方法，假设我们的action中有一个getListMenu方法，返回一个List集合。我们可以使用如下的形式来引用这个集合，并用s:iterator来输出。1&lt;s:iterator value=\"listMenu\" /&gt;iterator的value使用定义好的方式，如：1&lt;s:iterator value=\"&#123;1,2,3,4&#125;\" /&gt; //这样跌代输出的值就是1.2.3.4这四个值。iterator中输出具体值如果，在上面我们的list中的对象，有两个属性，都是String类型，一个是name，一个是url。我们可以这样来引用。1&lt;s:property value=\"name\" /&gt; //这样我们将可以输出迭代对象的name属性值。如果我们希望使用&lt;s:url /&gt;来将跳转过后的url进行处理，该如何来做？12&lt;s:url value=\"%&#123;url&#125;\"/&gt; //%&#123;&#125;ognl的表达式，这样的值能够将url的值进行&lt;s:url/&gt;的处理实际上就是转为绝对路径。这样，我们就可以对付一些因跳转换产生的路径问题。原因：因为&lt;s:iteratotr /&gt;以后，当前的对象应该就在ValueStack顶部了，这样当然的url实际上就是对象的url属性了。使用ognl输出对应的值1&lt;s:textfield value=\"%&#123;#request.loginNames&#125;\"/&gt;使用此表达式，会生成一个文本框，并且，如果request.attribute中有loginNames属性，将会做为些文本框的默认值。如果只使用#request.loginNames在struts2的标签内部，是不会显示任何值的，注意外面加上的%{}符号，才会被正常的使用。如果希望如EL语言一样直接输出文件，如在一个&lt;a&gt;&lt;/a&gt;之间的innerHTML文本为#request.loginNames的值，我们只要使用：&lt;s:property value=&quot;#request.loginNames&quot; /&gt;便可以正常使用！注：${}是EL语言的%{}这样的形式是ognl表达式语言的，在struts2的标签内部，使用%{}这样的形式，在标签外部可以使用${} EL语言的方式。如果在struts2的标签内部使用${}这样的方式，会出现以下的错误提示：1According to TLD or attribute directive in tag file, attribute value does not accept any expressions2.很多时候，我们使用struts2的一些标签，属性是需要接受集合的，如果集合是保存在request,session，或者是值栈(非根对象的栈顶)，可以使用#变量名的方式，如果获取的值是在Action中通过特定的方法来获取，就需要使用如value=&quot;userList&quot;这样的方式，只是去掉了前面的#。struts2中的OGNL用法User对象属性获取如User中有username和password字段获取username属性1&lt;s:property value=\"user.username\" /&gt;获取password属性1&lt;s:property value=\"user.password\" /&gt;若User中又包含定义了address对象，address对象中包含有addr属性，则可以这样访问获取addr属性:1&lt;s:property value=\"user.address.addr\" /&gt;若User中还包含一个get()的普通方法，可以这样调用1&lt;s:property value=\"user.get()\" /&gt;以上是调用值栈中对象的普通方法，user为值栈中的对象调用action中的静态方法get()，普通方法不能直接调用1&lt;s:property value=\"@com.netshuai.action.ManagerAction@get()\" /&gt;以上为调用非值栈中的静态方法调用JDK中类的静态方法1&lt;s:property value=\"@java.lang.Math@floor(32.56)\" /&gt;上例也可写成1&lt;s:property value=\"@@floor(32.56)\" /&gt;省略前面的类则默认使用java.lang.Math类，其他类不可省略调用普通类中的静态属性1&lt;s:property value=\"@com.netshuai.model.Address@city\" /&gt;address中的city静态属性要用public声明调用普通类的构造方法，如构造方法为1234public User(String username)&#123; this.username=username;&#125;调用方法为1&lt;s:property value=\"new com.netshuai.model.User('hello').username\" /&gt;则返回username值为hello获取List1&lt;s:property value=\"list\" /&gt;获取List中的某一个元素1&lt;s:property value=\"list[0]\" /&gt;获取List的大小1&lt;s:property value=\"list.size\" /&gt;获取Set1&lt;s:property value=\"set\" /&gt;无法获取Set中的某一个元素，因为Set没有顺序获取Map1&lt;s:property value=\"map\" /&gt;获取Map中所有key的值1&lt;s:property value=\"map.keys\" /&gt;获取Map中所有value的值1&lt;s:property value=\"map.values\" /&gt;获取Map中的某一个元素1&lt;s:property value=\"map['k1']\" /&gt;获取List所有对象1&lt;s:property value=\"listObject\" /&gt;需要重写toString()方法才能正常显示对象的值利用投影获取List中所有对象的username属性1&lt;s:property value=\"listObject.&#123;username&#125;\" /&gt;利用投影获取List中第一个对象的username属性1&lt;s:property value=\"listObject.&#123;username&#125;[0]\" /&gt;利用选择获取List中年龄大于 30 的对象1&lt;s:property value=\"listObject.&#123;?#this.age&gt;30&#125;\" /&gt;利用选择获取List中年龄大于 30 的对象的username1&lt;s:property value=\"listObject.&#123;?#this.age&gt;30&#125;.&#123;username&#125;\" /&gt;利用选择获取List中年龄大于 30 的第一个对象的username1&lt;s:property value=\"listObject.&#123;?#this.age&gt;30&#125;.&#123;username&#125;[0]\" /&gt;或1&lt;s:property value=\"listObject.&#123;^#this.age&gt;30&#125;.&#123;username&#125;\" /&gt;利用选择获取List中年龄大于 30 的最后一个对象的username1&lt;s:property value=\"listObject.&#123;$#this.age&gt;30&#125;.&#123;username&#125;\" /&gt;获取parameters中的属性1&lt;s:property value=\"#parameters.name\" /&gt;获取request中的属性1&lt;s:property value=\"#request.name\" /&gt;获取session中的属性1&lt;s:property value=\"#session.name\" /&gt;获取application中的属性1&lt;s:property value=\"#application.name\" /&gt;按顺序遍历上面四个对象，然后返回首先找到的值1&lt;s:property value=\"#attr.name\" /&gt;%{}可以取出存在值堆栈中的Action对象，直接调用它的方法，如%{getText(&#39;key&#39;)}可以取出国际化信息${}可以用在国际化资源文件中和struts2配置文件中使用top获取值栈中第二个对象1&lt;s:property value=\"[1].top.user\"/&gt;使用top获取值栈中第二个对象的属性1&lt;s:property value=\"[1].user\"/&gt;调用值栈中action的静态方法(vs也可写做vs1)1get()&lt;s:property value=\"@vs@get()\"/&gt;调用值栈中第二个action的静态方法1get()&lt;s:property value=\"@vs2@get()\"/&gt;将一个对象放入值栈1ActionContext.getContext().getValueStack().push(user);转载自http://tomfish88.iteye.com/blog/1489506","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"https://iamzhl.top/tags/struts2/"},{"name":"iterator","slug":"iterator","permalink":"https://iamzhl.top/tags/iterator/"},{"name":"框架","slug":"框架","permalink":"https://iamzhl.top/tags/框架/"}]},{"title":"OSI 七层模型详解","slug":"OSI-Model","date":"2018-04-09T08:36:53.000Z","updated":"2019-03-11T16:21:49.897Z","comments":true,"path":"OSI-Model.html","link":"","permalink":"https://iamzhl.top/OSI-Model.html","excerpt":"","text":"定义OSI（Open System Interconnection）参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。模型图各层描述物理层设备之间的比特流传输、物理接口、电气特性等物理层并不是物理媒体本身，它只是开放系统中利用物理媒体实现物理连接的功能描述和执行连接的规程。物理层提供用于建立、保持和断开物理连接的机械的、电气的、功能的和过程的条件。简而言之，物理层提供有关同步和全双工比特流在物理媒体上的传输手段，其典型的协议有RS 232C、RS 449/422/423、V.24和X.21、X.21bis等。物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接、传送数据和终止物理连接。所谓激活，就是不管有多少物理媒体参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。传输数据。物理层要形成适合数据传输需要的实体，为数据传送服务。一是要保证数据能在其上正确通过，二是要提供足够的带宽(带宽是指每秒钟内能通过的比特(Bit)数)，以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。完成物理层的一些管理工作。数据链路层封装数据帧数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输介质及其连接。介质是长期的，连接是有生存期的。在连接生存期内，收发两端可以进行不等的一次或多次数据通信。每次通信都要经过建立通信联络和拆除通信联络两个过程。这种建立起来的数据收发关系就叫做数据链路。而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错，为了弥补物理层上的不足，为上层提供无差错的数据传输，就要能对数据进行检错和纠错。数据链路的建立，拆除，对数据的检错，纠错是数据链路层的基本任务。链路层是为网络层提供数据传送服务的，这种服务要依靠本层具备的功能来实现。链路层应具备如下功能：链路连接的建立、拆除和分离；帧定界和帧同步。链路层的数据传输单元是帧，协议不同，帧的长短和界面也有差别，但无论如何必须对帧进行定界；顺序控制，指对帧的收发顺序的控制；差错检测和恢复。还有链路标识，流量控制等等。差错检测多用方阵码校验和循环码校验来检测信道上数据的误码，而帧丢失等用序号检测。各种错误的恢复则常靠反馈重发技术来完成。独立的链路产品中最常见的当属网卡，网桥也是链路产品。数据链路层将本质上不可靠的传输媒体变成可靠的传输通路提供给网络层。在IEEE802.3情况下，数据链路层分成了两个子层，一个是逻辑链路控制，另一个是媒体访问控制.OSI其中：AUI——连接单元接口PMA——物理媒体连接MAU——媒体连接单元PLS——物理信令MDI——媒体相关接口网络层封装数据报文网络层的产生也是网络发展的结果。在联机系统和线路交换的环境中，网络层的功能没有太大意义。当数据终端增多时。它们之间有中继设备相连，此时会出现一台终端要求不只是与惟一的一台而是能和多台终端通信的情况，这就产生了把任意两台数据终端设备的数据链接起来的问题，也就是路由或者叫寻径。另外，当一条物理信道建立之后，被一对用户使用，往往有许多空闲时间被浪费掉。人们自然会希望让多对用户共用一条链路，为解决这一问题就出现了逻辑信道技术和虚拟电路技术。中继控制层，其主要功能是利用数据链路层所保证的邻接节点间的无差错数据传输功能，通过路由选择和中继功能，实现两个端系统之间的数据传输。为此，网络层还具有多路复用功能，采用统计时分复用原理，将一条数据链路复用为多条逻辑信道，从而实现一个数据终端设备利用一条物理电路同时和多个远程数据通信设备的通信。网络层规定了网路连接的建立和拆除规程以及数据传送规程等。路由选择和中继；激活，终止网络连接；在一条数据链路上复用多条网络连接，多采取分时复用技术；检测与恢复；排序，流量控制；服务选择；网络管理。传输层确定传输协议、确定数据传输的接口主要功能是端开放系统之间数据的收妥确认。同时，还用于弥补各种通信网路的质量差异，对经过下三层之后仍然存在的传输差错进行恢复，进一步提高可靠性。另外，还通过复用、分段和组合、连接和分离、分流和合流等技术措施，提高吞吐量和服务质量。传输层是两台计算机经过网络进行数据通信时，第一个端到端的层次，具有缓冲作用。当网络层服务质量不能满足要求时，它将服务加以提高，以满足高层的要求；当网络层服务质量较好时，它只用很少的工作。传输层还可进行复用，即在一个网络连接上创建多个逻辑连接。传输层也称为运输层。传输层只存在于端开放系统中，是介于低3层通信子网系统和高3层之间的一层，但是很重要的一层。因为它是源端到目的端对数据传送进行控制从低到高的最后一层。有一个既存事实，即世界上各种通信子网在性能上存在着很大差异。例如电话交换网，分组交换网，公用数据交换网，局域网等通信子网都可互连，但它们提供的吞吐量，传输速率，数据延迟通信费用各不相同。对于会话层来说，却要求有一性能恒定的界面。传输层就承担了这一功能。它采用分流/合流，复用/介复用技术来调节上述通信子网的差异，使会话层感受不到。此外传输层还要具备差错恢复，流量控制等功能，以此对会话层屏蔽通信子网在这些方面的细节与差异。传输层面对的数据对象已不是网络地址和主机地址，而是会话层的界面端口。上述功能的最终目的是为会话提供可靠的，无误的数据传输。传输层的服务一般要经历传输连接建立、数据传送、传输连接释放3个阶段才算完成一个完整的服务过程。而在数据传送阶段又分为一般数据传送和加速数据传送两种。会话层对应用会话的管理、同步按照在应用进程之间约定的原则，按照正确的顺序收、发数据，进行各种形态的对话。会话层规定了会话服务用户间会话连接的建立和拆除规程以及数据传送规程。会话层提供的服务是应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。会话层，表示层，应用层构成开放系统的高3层，面向应用进程提供分布处理、对话管理、信息表示、检查和恢复与语义上下文有关的传送差错等。为给两个对等会话服务用户建立一个会话连接，应该做如下几项工作：将会话地址映射为运输地址；数据传输阶段；连接释放。表示层数据的表现形式、特殊数据的加密、压缩（解释传输的数据）把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。表示层的作用之一是为异种机通信提供一种公共语言，以便能进行互操作。这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。例如，IBM主机使用EBCDIC编码，而大部分PC机使用的是ASCII码。在这种情况下，便需要表示层来完成这种转换。通过前面的介绍，我们可以看出，会话层以下5层完成了端到端的数据传送，并且是可靠的、无差错的传送。但是数据传送只是手段而不是目的，最终是要实现对数据的使用。由于各种系统对数据的定义并不完全相同，最易明白的例子是键盘——其上的某些键的含义在许多系统中都有差异。这自然给利用其它系统的数据造成了障碍。表示层和应用层就担负了消除这种障碍的任务。应用层提供用户接口实现应用进程（如用户程序、终端操作员等）之间的信息交换。同时，还具有一系列业务处理所需要的服务功能。应用层一般包括公共应用服务要素（CASE）和特定应用服务要素（SASE）。其中CASE提供应用进程中最基本的服务，向应用进程提供信息传送所必需的、但又独立于应用进程通信的能力。SASE实质上是各种应用进程在应用层中的映射，每一个SASE都针对某一类具体应用，例如文件传送、访问和管理（FTAM）、虚拟终端（VT）、消息处理系统（MHS）、电子数据互换（EDI）和目录查询等。应用层向应用程序提供服务，这些服务按其向应用程序提供的特性分成组，并称为服务元素。有些可为多种应用程序共同使用，有些则为较少的一类应用程序使用。应用层是开放系统的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。OSI七层模型 相关协议 缩写应用层HTTP 超文本传输协议FTP 文件传输协议SMTP 简单邮件传输协议TELNETTCP/IP 终端仿真协议POP3 邮局协议第三版Finger 用户信息协议NNTP 网络新闻传输协议IMAP4 因特网信息访问协议第四版LPR UNIX 远程打印协议Rwho UNIX 远程 Who协议Rexec UNIX 远程执行协议Login UNIX 远程登陆协议RSH UNIX 远程Shell协议NTF HP 网络文件传输协议RDA HP 远程数据库访问协议VT 虚拟终端仿真协议RFA HP 远程文件访问协议RPC Remote Process Comm.S-HTTP 安全超文本传输协议GDP 网关发现协议X-WindowCMOT 基于TCP/IP的CMIP协议SOCKS 安全套接字协议FANP 流属性通知协议SLP 服务定位协议MSN 微软网络服务Radius 远程用户拨号认证服务协议DNS 域名系统NFS 网络文件系统协议NIS SUN 网络信息系统协议R-STAT SUN 远程状态协议NSM SUN 网络状态监测协议PMAP SUN 端口映射协议MountLPR UNIX远程打印协议常用UDP协议的应用层服务BOOTP 引导协议DHCP 动态主机配套协议NTP 网络时间协议TFTP 简单文件传输协议SNMP 简单网络管理协议表示层DECnet NSPLPP 轻量级表示协议NBSSN NetBIOS 会话服务协议XDP 外部数据表示协议IPX会话层SSL 安全套接字层协议TLS 传输层安全协议DAP 目录访问协议LDAP 轻量级目录访问协议RPC 远程过程调用协议VINES NETRPCVFRPNeTBIOSIPX传输层XOT 基于tcp之上的X协议Van Jacobson 压缩TCP协议ISO-DE ISO 开发环境——–&gt;NetBISOTALI 传输适配层接口协议DSI、NetBIOS、IP NeTBIOS、ISO-TP SSP、SMB、MSRPCUDP 用户数据报协议RUDP 可靠的用户数据报协议Mobile IP 移动IP协议网络层IP/IPv6 互联网协议/互联网协议第六版ICMPv6 互联网控制信息协议第六版ICMP 互联网控制信息协议IGMP 互联网组管理协议SLIP 串行线路IP协议安全协议AH 认证头协议ESP 安装封装有效载荷协议路由协议EGP 外部网关协议OSPF 开放最短路径优先协议IGRP 内部网关路由协议NHRP 下一跳解析协议IE-IRGP 增强内部网关路由选择协议RIPng for IPv6 IPv6路由信息协议GGP 网关到网关协议VRRP 虚拟路由器冗余协议PGM 实际通用组播协议RSVP 资源预留协议PIM-DM 密集模式独立组播协议DVMRP 距离矢量组播路由协议RIP2 路由信息协议第二版PIM-SM 稀疏模式独立组播协议MOSPF 组播开放最短路径优先协议数据链路层MPLS 多协议标签交换协议XTP 压缩传输协议DCAP 数据转换客户访问协议SLE 串行连接封装协议IPinIP IP套IP封装协议隧道协议PPTP 点对点隧道协议L2F 第二层转发协议L2TP 第二层隧道协议ATMP 接入隧道管理协议Cisco 协议CDP 思科发现协议CGMP 思科组管理协议地址解析协议ARP 地址解析协议RAR 逆向地址解析协议物理层IEEE 802.2Ethernet v.2Internetwork","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"OSI","slug":"OSI","permalink":"https://iamzhl.top/tags/OSI/"},{"name":"七层模型","slug":"七层模型","permalink":"https://iamzhl.top/tags/七层模型/"}]},{"title":"黑苹果常见补丁","slug":"Common-patches-on-Hackintosh","date":"2018-04-09T02:08:56.000Z","updated":"2019-03-11T16:21:49.887Z","comments":true,"path":"Common-patches-on-Hackintosh.html","link":"","permalink":"https://iamzhl.top/Common-patches-on-Hackintosh.html","excerpt":"","text":"先说说怎样强制加载某个驱动如下，KextToPatch并列ForceKextsToLoad，设置kext路径12345&lt;key&gt;ForceKextsToLoad&lt;/key&gt;&lt;array&gt; &lt;string&gt;\\System\\Library\\Extensions\\AppleHDA.kext&lt;/string&gt; &lt;string&gt;\\Extra\\Extensions&lt;/string&gt;&lt;/array&gt;笔记本显存修改至2048MBHD4200_4400_4600 Mobile：1234Name： AppleIntelFramebufferAzulFind： 01030303 00000002 00003001 00006000 00000060Replace： 01030303 00000002 00003001 00009000 00000080Comment: 1536MB -&gt; 2048MB for HD4200_4400_4600 MobileHD620 Mobile：1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00002002 00000000 00000060Replace： 01030303 00002002 00000000 00000080 Comment: 1536MB -&gt; 2048MB for HD620 MobileHD630 Mobile：1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00006002 00005001 00000060Replace： 01030303 00006002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD630 MobileHD520_530_540 Mobile：1234Name： AppleIntelSKLGraphicsFramebufferFind： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD520_530_540 MobileHD5500 Mobile：1234Name： AppleIntelBDWGraphicsFramebuffer Find: 01030303 00002002 00005001 00000060Replace: 01030303 00002002 00005001 00000080Comment: 1536MB -&gt; 2048MB for HD5500 Mobile开启Trim1234Name: com.apple.iokit.IOAHCIBlockStorageFind: 00415050 4C452053 534400Replcae: 00000000 00000000 000000Comment: Enable TRIM for SSD花屏补丁12345Name: com.apple.iokit.IOGraphicsFamilyFind: 4188C4EB 11Replcae: 4188C4EB 31Comment: Boot graphics glitch, 10.10.2/10.10.3MatchOS: 10.10.2,10.10.312345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 17Replcae: 010000EB 17Comment: Boot graphics glitch, 10.10.x/10.11.x (credit lisai9093, cecekpawon)MatchOS: 10.10.x,10.11.x12345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 25Replcae: 010000EB 25Comment: Boot graphics glitch, 10.12.dp1 (credit denskop)MatchOS: 10.12.x12345Name: com.apple.iokit.IOGraphicsFamilyFind: 01000075 22Replcae: 010000EB 22Comment: Boot graphics glitch, 10.13 beta (based on denskop patch)MatchOS: 10.13.xDVMT补丁Broadwell12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 39CF763CReplcae: 39CFEB3CComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.10.x (based on Austere.J patch)MatchOS: 10.10.x12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4139C476 3EReplcae: 4139C4EB 3EComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.11.beta (based on Austere.J patch)MatchOS: 10.11.x12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 8945C839 C7764FReplcae: 8945C839 C7EB4FComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.12.0 (based on Austere.J patch)MatchOS: 10.12.x12345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4C895DB8 7644Replcae: 4C895DB8 EB44Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.112345Name: com.apple.driver.AppleIntelBDWGraphicsFramebufferFind: 4C8945C0 7644Replcae: 4C8945C0 EB44Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit RehabMan)MatchOS: 10.13.2,10.13.3Skylake12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4139C476 2AReplcae: 4139C4EB 2AComment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.11.4 (based on Austere.J patch)MatchOS: 10.11.x12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 8945C839 C67651Replcae: 8945C839 C6EB51Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.12.0 (based on Austere.J patch)MatchOS: 10.12.x12345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4C8955B8 7640Replcae: 4C8955B8 EB40Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.112345Name: com.apple.driver.AppleIntelSKLGraphicsFramebufferFind: 4C895DB8 7640Replcae: 4C895DB8 EB40Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit PMHeart, , shdkpr2008)MatchOS: 10.13.2,10.13.3Kabylake12345Name: com.apple.driver.AppleIntelKBLGraphicsFramebufferFind: 4C895DC0 7646Replcae: 4C895DC0 EB46Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.0/1 (credit PMHeart)MatchOS: 10.13.0,10.13.112345Name: com.apple.driver.AppleIntelKBLGraphicsFramebufferFind: 4C896DB8 7646Replcae: 4C896DB8 EB46Comment: Disable minStolenSize less or equal fStolenMemorySize assertion, 10.13.2/3 (credit RehabMan)MatchOS: 10.13.2,10.13.3硬盘橙色1234Name: AppleAHCIPortFind: 45787465 726E616CReplcae: 496E7465 726E616CComment: Define external drivers as internal to fix yellow drive icons让没有ECC内存的机器利用MacPro4,1或者 MacPro5,1机型启动1234Name: AppleTyMCEDriverFind: 720A004D 61635072 6F342C31 004D6163 50726F35 2C310058Replcae: 720A0000 00000000 00000000 00000000 00000000 00000058Comment: Allow booting with a MacPro4,1 or MacPro5,1 SMBIOS definition without ECC memory万能声卡将Headphones显示替代为Telephones1234Name: VoodooHDAFind: 48656164 70686F6E 657300Replcae: 54656C65 70686F6E 657300Comment: For VoodooHDA replacing the string Headphones with Telephones","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"patch","slug":"patch","permalink":"https://iamzhl.top/tags/patch/"},{"name":"Hackintosh","slug":"Hackintosh","permalink":"https://iamzhl.top/tags/Hackintosh/"},{"name":"补丁","slug":"补丁","permalink":"https://iamzhl.top/tags/补丁/"}]},{"title":"macOS 下一些常用命令","slug":"Common-command-in-macOS","date":"2018-03-30T12:32:47.000Z","updated":"2019-03-11T16:21:49.886Z","comments":true,"path":"Common-command-in-macOS.html","link":"","permalink":"https://iamzhl.top/Common-command-in-macOS.html","excerpt":"","text":"Trim开启1$ sudo trimforce enable关闭1$ sudo trimforce disable查看启用的ig-platform-id1$ ioreg -l | grep -y platform-id笔记本开启插电源出提示音:开启:1$ defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app &amp;关闭:1$ defaults write com.apple.PowerChime ChimeOnAllHardware -bool false; killall PowerChime去掉apfs.efi最新版本的日志调试显示123$ cd ~/Desktop &amp; cp /usr/standalone/i386/apfs.efi .$ perl -i -pe &apos;s|\\x00\\x74\\x07\\xb8\\xff\\xff|\\x00\\x90\\x90\\xb8\\xff\\xff|sg&apos; ./apfs.efi提取显示器EDID及设备ID厂商IDEDID1$ ioreg -lw0 | grep -i &quot;IODisplayEDID&quot; | sed -e &apos;s/.*&lt;//&apos; -e &apos;s/&gt;//&apos;PID1$ ioreg -l | grep &quot;DisplayProductID&quot;VID1$ ioreg -l | grep &quot;DisplayVendorID&quot;为macOS Sierra以上的OS X开启任何来源1$ sudo spctl --master-disable查看加载的非官方内核扩展 – kext1$ kextstat | grep -v &quot;com.apple&quot; | grep -v Energy查看显示器硬件信息EDID1$ ioreg -l | grep &quot;IODisplayEDID&quot;ProductID1$ ioreg -l | grep &quot;DisplayProductID&quot;VendorID1$ ioreg -l | grep &quot;DisplayVendorID&quot;设置系统语言1$ languagesetup磁盘工具123$ diskutil $ fdisk $ dfkext工具1234$ kextstat $ kextfind$ kextlibs$ kextcache系统设置工具1# systemsetup系统控制工具12$ sysctl $ sysadminctl系统状态查看工具12345$ systemstats $ system_profiler$ ioreg$ iostat$ bdmesgnvram工具1$ nvrampkg工具1$ pkgutilclover生成工具1$ clover-genconfig查看启动参数1$ sysctl -n kern.bootargs查看CPU内核数1$ sysctl -n hw.physicalcpu查看CPU线程数1$ sysctl -n hw.logicalcpu查看机型SMBIOS1$ sysctl -n machdep.cpu.brand_string查看网络是否连通1$ ping -c 2 www.baidu.com &amp;&gt;/dev/null&amp;&amp; echo &quot;Internet: Connected&quot; || echo &quot;Internet: Disconnected&quot;查看当前登录用户1$ who查看DNS1$ cat /etc/resolv.conf | sed -n &apos;16p&apos; | awk &apos;&#123;print $2&#125;&apos;查看IP12$ osascript -e &quot;IPv4 address of (system info)&quot; //内网$ dig +short myip.opendns.com @resolver1.opendns.com //公网查看运行时间1$ uptime | sed &apos;s/.*up \\([^,]*\\), .*/\\1/&apos;查看电量剩余1$ ioreg -c AppleSmartBattery -r | awk &apos;$1~/Capacity/&#123;c[$1]=$3&#125; END&#123;OFMT=&quot;%.2f%&quot;; max=c[&quot;\\&quot;MaxCapacity\\&quot;&quot;]; if (max&gt;0) &#123; print 100*c[&quot;\\&quot;CurrentCapacity\\&quot;&quot;]/max;&#125; &#125;&apos;查看电池充电状态1$ pmset -g batt | sed -n &apos;2p&apos; | awk &apos;&#123;print $4&#125;&apos; | sed &apos;s/;//g&apos;查看系统版本1$ sw_vers -productVersion查看系统版本号1$ sw_vers -buildVersion查看内存容量1$ echo $(($(sysctl -n hw.memsize) / 1024 / 1024))查看操作系统型号1$ sysctl -n hw.model查看当前系统短版本名称1$ xxd -ps /Applications/Utilities/System\\ Information.app/Contents/MacOS/System\\ Information|tr -d &apos;\\n&apos;|perl -nle &quot;print $&amp; if m&#123;00$(sw_vers -productVersion|awk -F &apos;.&apos; &apos;&#123;printf $1&quot;.&quot;$2&#125;&apos;|xxd -ps)00\\K.*?00&#125;&quot;|xxd -r -p待续…","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"command","slug":"command","permalink":"https://iamzhl.top/tags/command/"},{"name":"macOS","slug":"macOS","permalink":"https://iamzhl.top/tags/macOS/"}]},{"title":"简单修改 FB 实现显存增加至 2048MB 修复某些花屏","slug":"How-to-patch-Framebuffer-change-VRAM-from-1536MB-to-2048MB","date":"2018-03-29T09:22:57.000Z","updated":"2019-03-11T16:21:49.892Z","comments":true,"path":"How-to-patch-Framebuffer-change-VRAM-from-1536MB-to-2048MB.html","link":"","permalink":"https://iamzhl.top/How-to-patch-Framebuffer-change-VRAM-from-1536MB-to-2048MB.html","excerpt":"","text":"前言：本来不打算发这个帖子的，因为好多人觉得没有什么用，但前几天帮论坛好友阿林解决他hd4600花屏问题时，发现这个方法还是有一定作用的。之前在10.12区有坛友的4600部分区域出现花屏的情况，最后通过修改注入的ig来解决的，大家都知道，4200 4400 4600都是靠FakeID为0x04128086和ig为0x0a260006然后配合FakePCIID和FakePCIID_HD_Graphics两个kext来驱动的，大家也知道，一部分4600也可以用0x04160000而不需要FakeID注入来驱动（相应的不少4400也可以用0x0a160000而不需要FakeID来驱动），两种方法都可以驱动核显，但区别还是有的，最容易发现的就是显存了，第一种方法驱动后都是1536m，第二种则是1024m。而前面提到的4600部分区域花屏的案例则是用第二种方式来解决的，后来经过测试，发现通过对framebuffer进行patch以达到2048m的显存也可以解决这个问题，于是这个方法就被我记在心里了。后来在帮阿林解决了他的花屏问题后，决定还是把相关方法写出来，虽然没什么技术含量，但也能为景友提供一个思路。废话就说到这，下面说方法:开工查看FB以及ig首先，确定你当前加载的Framebuffer，终端执行以下命令1$ kextstat | grep -y AppleIntel如图，看输出结果中带Framebuffer的就是我们需要的（haswell之前的是带FB的），图中我的就是AppleIntelFramebufferAzul然后执行以下命令查看当前使用的ig1$ ioreg -l | grep ig-platform-id如图我的就是0x0a260006,有朋友不清楚，不是0600260a吗，下次一定要知道，这种id将每两位一组分组，然后从后往前排序，最后由于是十六进制，我们在最前面加上0x来表示，就得出了0x0a260006，这就是我们的id，当然了，后面步骤中用到的还是0600260a。下载并安装hexfiend我直接放链接了链接:https://pan.baidu.com/s/1EhkVv2eaUE1u_Gmp87arJw 密码:lm1o在FB中查找ig进行处理然后，在/System/Library/Extensions下找到和第一步找出的Frambuffer同名kext，以我的为例，就是AppleIntelFramebufferAzul.kext,右键显示包内容，在/Contents/MacOS下将kext的同名文件拷贝到桌面，以我的为例就是AppleIntelFramebufferAzul。右键此文件打开方式选我们刚才安装的hexfiend，快捷键command + F调出搜索框，输入刚才在第一步找到的ig，回车搜索，找到后面紧跟01030303的那一串字符，如图从搜索的ig后面第一串开始，到00000060结束，将这些字符串拷贝到一个文本文档，并八个数字一组，整理好，然后再复制一行，将第二行最后的60改为80，如图第一串就是我们要做的patch的Find，第二串是Replace，而Name则是第一步中的Framebuffer名字，我这里就是AppleIntelFramebufferAzul，Comment就无所谓了，我写成Change VRAM from 1536MB to 2048MB for HD4400，这时我们的补丁就做好了。最后将patch打到config.plist然后保存重启，就会发现关于本机的显存从原来的1536MB变成了2048MB如果没效果，可以尝试重建缓存。帖子的最后，我将之前做的几个patch贴出来，大家可以尝试使用HD4200_4400_4600 Mobile1234Name： AppleIntelFramebufferAzulFind： 01030303 00000002 00003001 00006000 00000060Replace： 01030303 00000002 00003001 00009000 00000080Comment： 1536MB -&gt; 2048MB for HD4200_4400_4600 MobileHD620 Mobile：1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00002002 00000000 00000060Replace： 01030303 00002002 00000000 00000080 Comment： 1536MB -&gt; 2048MB for HD620 MobileHD630 Mobile：1234Name： AppleIntelKBLGraphicsFramebufferFind： 01030303 00006002 00005001 00000060Replace： 01030303 00006002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD630 MobileHD520_530_540 Mobile：1234Name： AppleIntelSKLGraphicsFramebufferFind： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD520_530_540 MobileHD5500 Mobile：1234Name： AppleIntelBDWGraphicsFramebuffer find： 01030303 00002002 00005001 00000060Replace： 01030303 00002002 00005001 00000080Comment： 1536MB -&gt; 2048MB for HD5500 Mobile","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"显存","slug":"显存","permalink":"https://iamzhl.top/tags/显存/"},{"name":"FB","slug":"FB","permalink":"https://iamzhl.top/tags/FB/"},{"name":"花屏","slug":"花屏","permalink":"https://iamzhl.top/tags/花屏/"},{"name":"Framebuffer","slug":"Framebuffer","permalink":"https://iamzhl.top/tags/Framebuffer/"}]},{"title":"macOS 修改帐户名、主机名和计算机名","slug":"How-to-change-your-username-on-your-mac","date":"2018-03-15T09:19:00.000Z","updated":"2019-03-11T16:21:49.891Z","comments":true,"path":"How-to-change-your-username-on-your-mac.html","link":"","permalink":"https://iamzhl.top/How-to-change-your-username-on-your-mac.html","excerpt":"","text":"帐户信息修改1System Preferences &gt; Users &amp; Groups &gt; 右单击当前用户 &gt; Advanced Options注意：用了一段时间的电脑不建议修改，可能会导致很多软件要重新安装。主机名修改1$ sudo scutil --set HostName MacBookPro计算机名修改1$ sudo scutil --set ComputerName MacBookPro","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"账户名","slug":"账户名","permalink":"https://iamzhl.top/tags/账户名/"},{"name":"主机名","slug":"主机名","permalink":"https://iamzhl.top/tags/主机名/"},{"name":"计算机名","slug":"计算机名","permalink":"https://iamzhl.top/tags/计算机名/"},{"name":"mac","slug":"mac","permalink":"https://iamzhl.top/tags/mac/"}]},{"title":"0-1背包问题","slug":"0-1-backpack","date":"2018-01-17T08:51:25.000Z","updated":"2019-03-11T16:21:49.881Z","comments":true,"path":"0-1-backpack.html","link":"","permalink":"https://iamzhl.top/0-1-backpack.html","excerpt":"","text":"递归123456789101112131415161718192021222324252627282930313233//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int f(int i,int j)&#123; int m1,m2; if(i==n-1)&#123; if(j&gt;=weight[i]) return value[i]; return 0; &#125; if(j&lt;weight[i]) return f(i+1,j); m1=f(i+1,j); m2=f(i+1,j-weight[i])+value[i]; return m1&gt;m2?m1:m2;&#125;int main(int argc, const char * argv[]) &#123; printf(&quot;%d\\n&quot;,f(0,c)); return 0;&#125;运行结果动态规划1234567891011121314151617181920212223242526272829303132333435//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int main(int argc, const char * argv[]) &#123; int s[n][c+1]; int i,j; for(j=0;j&lt;=c;j++)&#123; if(j&gt;weight[n-1]) s[n-1][j]=value[n-1]; else s[n-1][j]=0; &#125; for(i=n-2;i&gt;=0;i--)&#123; for(j=0;j&lt;=c;j++)&#123; if(j&lt;weight[i]) s[i][j]=s[i+1][j]; else s[i][j]=s[i+1][j]&gt;(s[i+1][j-weight[i]]+value[i])?s[i+1][j]:(s[i+1][j-weight[i]]+value[i]); &#125; &#125; printf(&quot;%d\\n&quot;,s[0][c]); return 0;&#125;运行结果回溯12345678910111213141516171819202122232425262728293031323334353637//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int weight[n]=&#123;2,2,6,5,4&#125;, value[n]=&#123;6,3,5,4,6&#125;;int maxvalue, tempvalue, tempweight;void traceback(int t)&#123; if(t==n)&#123; if(tempvalue&gt;maxvalue) maxvalue=tempvalue; return; &#125; if(tempweight+weight[t]&lt;=c)&#123; tempweight+=weight[t]; tempvalue+=value[t]; traceback(t+1); tempweight-=weight[t]; tempvalue-=value[t]; &#125; traceback(t+1);&#125;int main(int argc, const char * argv[]) &#123; traceback(0); printf(&quot;%d\\n&quot;,maxvalue); return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"https://iamzhl.top/tags/0-1背包问题/"},{"name":"algorithm","slug":"algorithm","permalink":"https://iamzhl.top/tags/algorithm/"},{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"}]},{"title":"数组部分逆置问题","slug":"Reverse-part-of-array","date":"2018-01-17T08:23:37.000Z","updated":"2019-03-11T16:21:49.900Z","comments":true,"path":"Reverse-part-of-array.html","link":"","permalink":"https://iamzhl.top/Reverse-part-of-array.html","excerpt":"","text":"代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// main.c// reverse-part-of-array//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define n 8int a[n]=&#123;1,4,2,6,8,5,7,3&#125;;void print()&#123; for(int i=0;i&lt;n;i++)&#123; printf(\"%3d\", a[i]); &#125; putchar('\\n');&#125;void swap(int *a, int *b)&#123; int temp=*a; *a=*b; *b=temp;&#125;void swapposition(int a[], int low, int high, int k)&#123; int i, j; for(i=low,j=k-1;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]); for(i=k,j=high;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]); for(i=low,j=high;i&lt;j;i++,j--) swap(&amp;a[i], &amp;a[j]);&#125;int main(int argc, const char * argv[]) &#123; int k; print(); scanf(\"%d\", &amp;k); swapposition(a, 0, n-1, k); print(); return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://iamzhl.top/tags/algorithm/"},{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"逆置","slug":"逆置","permalink":"https://iamzhl.top/tags/逆置/"}]},{"title":"n 皇后问题","slug":"n-queen","date":"2018-01-17T08:04:05.000Z","updated":"2019-03-11T16:21:49.905Z","comments":true,"path":"n-queen.html","link":"","permalink":"https://iamzhl.top/n-queen.html","excerpt":"","text":"代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define n 8int a[n];int count=0;int judge(int t)&#123; if(t==n) return 0; for(int i=0;i&lt;t;i++)&#123; for(int j=i+1;j&lt;=t;j++)&#123; if(a[i]==a[j]) return 0; if(abs(i-j)==abs(a[i]-a[j])) return 0; &#125; &#125; return 1;&#125;void traceback(int t)&#123; int i; if(t==n)&#123; count++; for(i=0;i&lt;n;i++) printf(\"%3d\", a[i]); printf(\"\\n\"); &#125; for(i=0;i&lt;n;i++)&#123; a[t]=i; if(judge(t)) traceback(t+1); &#125;&#125;int main(int argc, const char * argv[]) &#123; traceback(0); printf(\"%d\\n\", count); return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://iamzhl.top/tags/algorithm/"},{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"n皇后问题","slug":"n皇后问题","permalink":"https://iamzhl.top/tags/n皇后问题/"}]},{"title":"矩阵连乘问题","slug":"RecurMatrix","date":"2018-01-17T07:54:02.000Z","updated":"2019-03-11T16:21:49.900Z","comments":true,"path":"RecurMatrix.html","link":"","permalink":"https://iamzhl.top/RecurMatrix.html","excerpt":"","text":"代码12345678910111213141516171819202122232425262728293031323334353637383940414243//// main.c// RecurMatrix//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include &lt;stdio.h&gt;#define n 6int a[n+1]=&#123;30,35,15,5,10,20,25&#125;;int b[n+1][n+1];int RecurMatrix(int i, int j)&#123; if(i==j) return 0; int minvalue=RecurMatrix(i, i)+RecurMatrix(i+1, j)+a[i-1]*a[i]*a[j]; b[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int tempvalue=RecurMatrix(i, k)+RecurMatrix(k+1, j)+a[i-1]*a[k]*a[j]; if(tempvalue&lt;minvalue)&#123; minvalue=tempvalue; b[i][j]=k; &#125; &#125; return minvalue;&#125;void traceback(int i, int j)&#123; if(i==j) return; traceback(i, b[i][j]); traceback(b[i][j]+1, j); printf(\"A[%d-%d]*A[%d-%d]\\n\", i, b[i][j], b[i][j]+1, j);&#125;int main(int argc, const char * argv[]) &#123; printf(\"%d\\n\", RecurMatrix(1, n)); traceback(1, n); return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://iamzhl.top/tags/algorithm/"},{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"矩阵连乘问题","slug":"矩阵连乘问题","permalink":"https://iamzhl.top/tags/矩阵连乘问题/"}]},{"title":"二分查找","slug":"BinarySearch","date":"2018-01-17T07:29:36.000Z","updated":"2019-03-11T16:21:49.882Z","comments":true,"path":"BinarySearch.html","link":"","permalink":"https://iamzhl.top/BinarySearch.html","excerpt":"","text":"代码1234567891011121314151617181920212223242526272829303132//// main.c// algorithm//// Created by athlonreg on 17/01/2018.// Copyright © 2018 athlonreg. All rights reserved.//#include &lt;stdio.h&gt;#define n 5int arr[n]=&#123;1,2,3,4,5&#125;;int BinarySearch(int a[], int low, int high, int k)&#123; while(low&lt;high)&#123; int mid=(low+high)/2; if(a[mid]==k) return mid; else if(a[mid]&gt;k) return BinarySearch(a, low, mid-1, k); else return BinarySearch(a, mid+1, high, k); &#125; return -1;&#125;int main(int argc, const char * argv[]) &#123; int x=4; printf(\"%d\\n\", BinarySearch(arr, 0, n-1, x)); return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://iamzhl.top/tags/algorithm/"},{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"二分查找","slug":"二分查找","permalink":"https://iamzhl.top/tags/二分查找/"}]},{"title":"macOS 安装和配置 MySQL","slug":"Install-and-config-mysql-on-mac","date":"2017-12-20T09:01:00.000Z","updated":"2019-03-11T16:21:49.893Z","comments":true,"path":"Install-and-config-mysql-on-mac.html","link":"","permalink":"https://iamzhl.top/Install-and-config-mysql-on-mac.html","excerpt":"","text":"准备安装HomeBrew1$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"等待安装完成即可安装安装MySQL1$ brew install mysql等待安装完成，如下图检查安装是否正常1$ mysql --version如果出现版本号，则正常，如下图若提示command not found，则依次执行下面两条命令12$ cd /usr/local/bin/$ sudo ln -fs /usr/local/mysql/bin/mysql mysql配置配置root账号的密码，默认无密码开启安全模式启动mysql1$ sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables修改密码首先登录mysql1$ mysql -u root配置root账号的密码命令中的****为要修改的密码1UPDATE mysql.user SET authentication_string=PASSWORD(&apos;****&apos;) WHERE User=&apos;root&apos;;刷新权限1FLUSH PRIVILEGES;退出mysql1\\q验证密码1$ mysql -u root -p会提示输入密码，输入刚才设定的密码后如果能够进入mysql则说明配置成功。终端开启和关闭mysql服务12$ sudo /usr/local/mysql/support-files/mysql.server start$ sudo /usr/local/mysql/support-files/mysql.server stop","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://iamzhl.top/tags/Mac/"},{"name":"MySQL","slug":"MySQL","permalink":"https://iamzhl.top/tags/MySQL/"}]},{"title":"Clover ACPI hotpatch","slug":"Clover-ACPI-hotpatch","date":"2017-12-17T07:30:15.000Z","updated":"2019-03-11T16:21:49.885Z","comments":true,"path":"Clover-ACPI-hotpatch.html","link":"","permalink":"https://iamzhl.top/Clover-ACPI-hotpatch.html","excerpt":"","text":"Preface–序言This blog is created by me to introduce how to using Clover to hotpatch ACPI，and provide an Chinese version。我写这篇博客是为了介绍如何使用Clover对ACPI使用hotpatch，并翻译原贴提供中文参考帖。Brief description for hotpatch–hotpatch概要In RehabMan’s GitHub homepage, a repository named OS-X-Clover-Laptop-Config Contains some Clover config.plist for common Intel graphics and hotpatch for common configurations.More information in here.RehabMan的GitHub有一个仓库–OS-X-Clover-Laptop-Config,里面包含了一些适用于常见的英特尔核芯显卡的config.plist,还有hotpatch。点击这里了解更多。There are some handy SSDTs for use with Clover ACPI hotpatch (in conjunction with hotpatch/config.plist) If you understand ACPI, you may find the SSDTs and hotpatch/config.plist quite useful.这儿有许多针对使用Clover ACPI hotpatch(连同使用hotpatch/config.plist)的SSDT。如果你理解了ACPI，你会发现这些SSDT和hotpatch/config.plist相当重要。Read here for the hotpatch guide: https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/这里是hotpatch的‘入门引导贴。https://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/A brief description of each hotpatch SSDT is provided below–下面是每一个 hotpatch SSDT 的概要SSDT-Config.dsl: This file provides configuration data for other SSDTs. Read the comments within the file for more information.SSDT-Config.dsl:这个文件为其他SSDT提供参数。请阅读文件中的注释以获得更多信息。SSDT-Debug.dsl: This SSDT is for use with ACPIDebug.kext. Instead of patching your DSDT to add the RMDT device, you can use this SSDT and refer to the methods with External. See ACPIDebug.kext documentation for more information regarding the RMDT methods.这个SSDT和ACPIDebug.kext一起使用。不需要对你的DSDT打补丁增加RMDT设备，你可以使用这个SSDT通过External导入这个方法。关于RMDT方法，要了解更多请参阅ACPIDebug.kext文档。SSDT-XOSI.dsl: This SSDT provides the XOSI method, which is a replacement for the system provided _OSI object when the _OSI-&gt;XOSI patch is being used. This is actually one of the examples in the Clover ACPI hotpatch guide, linked above.这个SSDT提供了XOSI方法，当打了_OSI-&gt;XOSI补丁时，XOSI方法会替换系统提供的_OSI对象。实际上，这就是Clover ACPI hotpatch入门参考帖的一个例子，链接在下面。SSDT-IGPU.dsl This SSDT injects Intel GPU properties depending on the configuration data in SSDT-Config and the device-id that is discovered to be present on the system. It assumes the IGPU is named IGPU (typical is GFX0, requring GFX0-&gt;IGPU rename). Configured with RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml.这个SSDT根据SSDT-config的配置数据和系统中发现的设备id注入了Intel GPU–核芯显卡属性。它假定IGPU被命名成IGPU(通常是GFX0，需要重命名GFX0-&gt;IGPU)。通过RMCF.TYPE, RMCF.HIGH, RMCF.IGPI, and SSDT-SkylakeSpoof.aml来配置。SSDT-SkylakeSpoof.aml: This SSDT is an optional SSDT that can be paired with SSDT-IGPU.dsl. When present, SSDT-IGPU uses the data within as an override for various KabyLake graphics devices which spoofs those devices as Skylake. Prior to 10.12.6, Skylake spoofing is the only option for KabyLake graphics. And even with 10.12.6 (or later, including 10.13.x), it still may be useful to spoof KabyLake graphics as Skyake. Keep in mind complete Skylake spoofing requires FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext.这个SSDT是一个可选的SSDT,它可以配合SSDT-IGPU.dsl使用。SSDT-IGPU使用这些数据对KabyLake图形设备的数据进行覆盖重写，把KabyLake仿冒成Skylake。10.12.6之前,KabyLake只有仿冒成’SkyLake’驱动核显，即使在10.12.6之后(或者更新的版本，包括10.13.x)，将KabyLake仿冒成’SkyLake’仍然是很有用的，需要注意的是完整的仿冒需要FakePCIID.kext + FakePCIID_Intel_HD_Graphics.kext。SSDT-IMEI.dsl: This SSDT injects fake device-id as required for IMEI when using mixed HD3000/7-series or HD4000/6-series. Be sure to read the comments within carefully, as customization is required if your system already has an IMEI identity in ACPI.当使用混合的hd3000/7系或hd4000/6系时，该SSDT为IMEI注入了仿冒的设备id。一定要仔细阅读注释，因为如果您的系统已经在ACPI中有了IMEI标识，那么就需要进行定制。SSDT-PNLF.dsl: This SSDT injects a PNLF device that works with IntelBacklight.kext or AppleBacklight.kext. Configured with RMCF.BKLT, RMCF.LMAX, RMCF.FBTP. See guide for more information: https://www.tonymacx86.com/threads/guide-laptop-backlight-control-using-applebacklightinjector-kext.218222/这个SSDT注入了一个PNLF设备，它可以与IntelBacklight.kext 或者AppleBacklight.kext一起工作。通过RMCF.BKLT ,RMCF.LMAX RMCF.FBTP。更多信息参见指南:SSDT-LPC.dsl:This SSDT injects properties to force AppleLPC to load for various unsupported LPC device-ids. It assumes the LPC device is named LPCB.这个SSDT:注入属性以强制AppleLPC加载各种不支持的LPC设备id。需要LPC设备被命名为LPCB。SSDT-SATA.dsl: This SSDT injects properties (fake device-id, compatible) to enable the SATA controller with certain unsupported SATA controllers. It assumes the SATA device is named SATA (typical is SAT0, thus requiring SAT0-&gt;SATA rename).这个SSDT注入了一些属性(仿冒的设备id，兼容的)，以使某些不受支持的SATA控制器启用SATA控制器。它假设SATA设备被命名为SATA(常见的是SAT0，因此需要SAT0-SATA重命名)。SSDT-Disable_DGPU.dsl: This SSDT provides an _INI method that will call _OFF for a couple of common paths for a discrete GPU in a switched/dual GPU scenario. This SSDT can work to disable the Nvidia or AMD graphics device, if the path matches (or is modified to math) and your _OFF method code path has no EC related code. Refer to the hotpatch guide for a complete example.这个SSDT提供了一个INI方法，它将在可切换的/双GPU中为独立显卡提供一些通用的路径来调用_OFF。如果路径匹配(或被自定义来匹配)而且你的_OFF方法代码路径则没有与EC相关的代码，那么这个SSDT可以禁用Nvidia或AMD图形设备。有关一个完整的示例，请参阅热补丁指南。SSDT-SMBUS.dsl:This SSDT injects the missing DVL0 device. Mostly used with Sandy Bridge and Ivy Bridge systems.这个SSDT注入了丢失的DVL0设备。主要用于Sandy Bridge和Ivy Bridge平台。SSDT-GPRW.dsl and SSDT-UPRW.dsl: These SSDTs is used in conjuction with the GPRW-&gt;XPRW or UPRW-&gt;XPRW patch. Used together this SSDT can fix “instant-wake” by disabling “wake on USB”. It overrides the _PRW package return for GPE indexes 0x0d or 0x6d. Potential companion patches are provided in hotpatch/config.plist这些SSDT与GPRW-XPRW或UPRW-XPRW补丁一起使用。通过使用这些SSDT，可以通过禁用wake on USB来修复instant wake。它重写了GPE的索引0x0d或0x6d的PRW包返回值。在hotpatch/config.plist中提供了潜在的伙伴补丁。SSDT-LANC_PRW.dsl: Also part of fixing “instant wake”, but this is for _PRW on the Ethernet device. Potential companion patches are provided in hotpatch/config.plist.这也是修复instant wake的一部分，但这是在以太网设备上进行修复的。在hotpatch/config.plist中提供了潜在的伙伴补丁。SSDT-PTSWAK.dsl: This SSDT provides overrides for both _PTS and _WAK. When combined with the appropriate companion patches from hotpatch/config.plist, these methods can provide various fixes. The actions are controlled by RMCF.DPTS, RMCF.SHUT, RMCF.XPEE, RMCF.SSTF. Refer to SSDT-Config.dsl for more information on those options.这个SSDT提供了对_PTS和_WAK的重写。当与来自hotpatch/config.plist的适当的补丁相结合使用时，这些方法可以提供一系列的修复。这些行为是由RMCF.DPTS, RMCF.SHUT,RMCF.XPEE,RMCF.XPEE ,RMCF.SSTF.更多关于这些选项的信息参阅SSDT-Config。SSDT-Disable_EHCI.dsl: This SSDT can disable both EHCI controllers. It is assumed both have been renamed to EH01/EH02 (typically original names are EHC1/EHC2).这个SSDT可以禁用EHCI控制器。要求这两种情况都被重新命名为EH01/EH02(通常原来的名字是EHC1/EHC2).SSDT-Disable_EH01.dsl, SSDT-Disable_EH02.dsl: Each of these SSDTs is just SSDT-Disable_EHCI.dsl broken down to only disable EH01 or only EH02. Use as appropriate depending on which EHCI controllers are active/present in your ACPI set.这些SSDT每一个都是SSDT-Disable_EHCI.dsl分解的，仅仅用以禁用EH01或EH02。取决于在你的ACPI集合中使用哪个EHCI控制器是合适的。SSDT-XWAK.dsl, SSDT-XSEL.dsl, SSDT-ESEL.dsl: Each of these SSDTs provides an empty XWAK, XSEL, and ESEL methods (respectively). Use with the appropriate companion patch from hotpatch/config.plist. Typically, these methods are disabled (by having no code in them) to disable certain actions native ACPI may be doing on wake from sleep or during startup that cause problems with the xHCI/EHCI configuration.这些SSDT分别提供了一个空的XWAK、XSEL和ESEL方法(独立地)。配合hotpatch/config.plist中适当的补丁一起使用。通常情况下，这些方法被禁用(因为在它们中没有代码)，以禁用本地ACPI可能在唤醒睡眠或在启动时导致xHCI/EHCIi配置问题的某些动作。SSDT-PluginType1.dsl: This SSDT injects “plugin-type”=1 on CPU0. It assumes ACPI Processor objects are in Scope(_PR). It can be used to enable native CPU power management on Haswell and later CPUs. See guide for more information: https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/.这个SSDT在CPU0注入“plugin-type”=1。它要求ACPI处理器对象在Scope(_PR)范围内。它可以用于在Haswell和更新的CPU启用原生电源管理。更多信息见指南：https://www.tonymacx86.com/threads/guide-native-power-management-for-laptops.175801/.SSDT-HDEF.dsl and SSDT-HDAU.dsl: Injects layout-id, hda-gfx, and PinConfiguration properties on HDEF and HDAU in order to implement audio with patched AppleHDA.kext Configured with: RMCF.AUDL.在HDEF和HDAU上注入layout-id、hda-gfx和PinConfiguration属性，以通过对AppleHDA的patch实现音频。通过RMCF.AUDL配置.SSDT-EH01.dsl,SSDT-EH02.dsl, and SSDT-XHC.dsl:These SSDTs inject USB power properties and control over FakePCIID_XHCIMux (dending on SSDT-Disable_EH*.dsl).这些SSDT注入USB电源属性并通过FakePCIID_XHCIMux控制(取决于SSDT-Disable_EH*.dsl)。SSDT-ALS0.dsl: Injects a fake ALS device (ambient light sensor). This SSDT is used to fix problems with restoring brightness upon reboot.注入仿冒ALS设备(环境光传感器)。这个SSDT用于修复重新启动时还原亮度的问题。Introduction-说明文档Patching ACPI is always necessary to enable (near) full functionality when installing OS X on non-Apple hardware.在非苹果硬件上安装OS X时，修补ACPI以启用(接近)完整的功能总是必要的。There is a complete guide here: http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/这里有一个完整的指南: http://www.tonymacx86.com/threads/guide-patching-laptop-dsdt-ssdts.152573/That guide uses what is known as “static patching”. In order to inject patched ACPI files, we extract native ACPI, disassemble them, make changes, then recompile and place the files in ACPI/patched, so that Clover injects the patched ACPI instead of native ACPI. With the techniques detailed in this guide, the changes can be made directly to the ACPI binaries provided by BIOS, skipping the extract, disassembly, and recompilation steps.该指南使用了所谓的“静态补丁”。为了注入打了补丁的ACPI文件，我们提取本地的ACPI，将它们反编译，进行修改，然后重新编译，并将文件放在ACPI/patched中，这样Clover就注入了打过补丁的ACPI，而不是原生的ACPI。通过本指南中详细介绍的技术，可以直接对BIOS提供的ACPI二进制文件进行更改，跳过提取、分解和重新编译步骤。You should have a solid understanding of static ACPI patching before attempting to hotpatch. You should also have an understanding of the ACPI spec, binary patching, programming, and ACPI concepts. Don’t expect step-by-step and spoon feeding in this thread.在尝试hotpatch之前，你应该对静态的ACPI补丁有一定的了解。你还应该了解ACPI规范、二进制补丁、语法和ACPI概念。不要指望在这个过程中循序渐进地学习。Clover mechanisms-Clover机制Clover provides a few methods for accomplishing ACPI hotpatch:Clover提供了一些新的方法来实现ACPI hotpatch.config.plist/ACPI/DSDT/Fixesconfig.plist/ACPI/DSDT/Patchesability to inject additional SSDTsDSDT/Fixes provide fixed function ACPI patching. Each “Fix” can do a particular kind of patching that can be used instead of typical patching you might do with MaciASL and static patching. For example, “IRQ Fix” can be accomplished with “FixHPET_0010” “FixIPIC_0040” “FIX_RTC_20000” and “FIX_TMR_40000”. As an other example, “Fix _WAK Arg0 v2” can be accomplished with “FIX_WAK_200000”. You can read the Clover wiki for more information on each patch. Most of the time, there are not many DSDT “Fixes” needed for basic functionality. DSDT “Fixes” are useful for implementing patches that are difficult or impossible to implement with ACPI/DSDT/Patches or additional SSDTs.DSDT/Fixes提供了具有修复功能的ACPI补丁。每一个Fix都可以使用一种特殊的补丁，从而不需要你使用MaciASL和静态补丁。例如，IRQ Fix可以用FixHPET_0010、FixIPIC_0040、FIX_RTC_20000和FIX_TMR_40000来完成。再举一个例子，Fix _WAK Arg0 v2可以用FIX_WAK_200000来完成。对于每个补丁阅读Clover wiki以获得更多信息。大多数情况下，基本功能所需的DSDTFix并不多。对于用ACPI/DSDT/Patches或附加的SSDT很难实现甚至不可能实现的补丁,利用DSDTFixes实现非常有用。DSDT/Patches allows for binary search and replace by Clover. Clover loads the native ACPI files, applies the patches specified in ACPI/Patches using binary search/replace, then injects the patched ACPI. You need to have an understanding of the binary AML format. It is fully documented in the ACPI spec.DSDT/Patches允许通过Clover对二进制进行查找并替换。Clover加载本地的ACPI文件，在ACPI/Patches中使用二进制查找替换以应用指定的补丁，然后注入打过补丁的ACPI。您需要了解二进制AML格式。它在ACPI规范中有完整的文档记录。ACPI namespace is built by merging the DSDT and SSDTs at load time. By placing additional SSDTs into ACPI/patched, we can essentially add code to this ACPI set. Since many OS X patches involve adding properties to ioreg with a _DSM method, it is often adequate to simply add an SSDT which contains the additional _DSM method instead of patching the native ACPI files. A perfect example you’re already familiar with is the SSDT.aml that is generated by Pike’s ssdtPRgen.sh.ACPI命名空间在加载时通过合并DSDT和SSDT构建。通过将额外的SSDT放到ACPI/patched,我们可以添加代码到ACPI集。因为许多OS X补丁涉及_DSM方法添加属性到ioreg ,通常是适当的SSDT包含额外的一个_DSM方法而不是对本地ACPI文件打补丁。你已经熟悉的一个很好的例子是Pike的ssdtprgensh.sh脚本生成的SSDT.aml。In some cases, more than one mechanism must be used to accomplish a single goal. For example, you might use binary patching to disable or rename components in the native ACPI set, and then replace it with additional SSDTs.在某些情况下，必须使用不止一个机制来完成某一个目标。例如，你可能使用二进制补丁来禁用或重命名本地ACPI集合中的组件，然后用额外的SSDT替换它。Renaming ACPI objects-重命名ACPI对象Since OS X can depend on specific ACPI object names used by Macs, a common patch is to rename an object in the native ACPI set. For example, most PC laptops use GFX0 for the integrated Intel GPU object (Intel HD Graphics). In OS X, power management for Intel graphics is not enabled unless this device is named IGPU. Using static patching, we apply “Rename IGPU to GFX0” in order to rename this object. The patch must be applied to the DSDT and all SSDTs that reference it.由于OS X可以依赖于Mac所使用的特定的ACPI对象名称，一个常见的补丁是在本地的ACPI集合中重命名一个对象，例如，大多数PC笔记本使用GFX0作为集成的Intel GPU对象(Intel HD显卡)。在OS X中，除非这个设备被命名为IGPU，否则英特尔图形的电源管理是不能启用的。使用静态补丁，我们应用Rename IGPU to GFX0来重命名这个对象。这个补丁必须应用到DSDT和所有有引用GFX0的SSDT上。With hotpatch, we can rename GFX0 to IGPU using a simple Clover patch in ACPI/DSDT/Patches. Such patches apply to DSDT and all native SSDTs (DSDT/Patches do not apply to SSDTs that are added via ACPI/patched). The patch for the rename would be:使用hotpatch，我们可以在ACPI/DSDT/Patches使用一个简单的四叶草补丁将GFX0重命名为IGPU。这些补丁适用于DSDT和所有本地的SSDTs((DSDT/Patches不能被应用到通过ACPI/patched添加的SSDT)。重命名的补丁是:123Comment: Rename GFX0 to IGPUFind: &lt;4746 5830&gt;Replace: &lt;4947 5055&gt;The hex values in Find and Replaces are the ASCII codes for GFX0 and IGPU, respectively.查找和替换的十六进制值分别是GFX0和IGPU的ASCII码,分别是：1234$ echo -n GFX0|xxd0000000: 4746 5830 GFX0$ echo -n IGPU|xxd0000000: 4947 5055 IGPUThere are number of common renames, and most are in the config.plist that are part of my Clover/hoptpatch project:https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatch有许多通用的重命名，而且很多都在config.plist里，这个config.plist是我的Clover/hotpatch项目的一部分:https://github.com/RehabMan/OS-X-Clover-Laptop-Config/tree/master/hotpatchIn fact, the hotpatch SSDTs that are part of the same project depend on the renames being implemented.事实上，这些hotpach的SSDT也是上面那个项目的一部分，并且它们要求这些重命名必须被实现。Common renames:通用的重命名：12345678910GFX0 -&gt; IGPUSAT0 -&gt; SATAEHC1 -&gt; EH01EHC2 -&gt; EH02XHCI -&gt; XHCHECI -&gt; IMEIMEI -&gt; IMEILPC -&gt; LPCBHDAS -&gt; HDEFAZAL -&gt; HDEFNote: All ACPI identifiers are 4 characters. Shorter names are padded with underscore. So, for example, XHC is represented in the AML binary as XHC_, EC would be EC__, EC0 would be EC_, MEI would be MEI_, etc.注意：所有的ACPI标识符都是4个字符。较短的名字用下划线填充。例如，XHC在AML二进制文件中被表示为XHC_，EC是EC__，EC0是EC0_，MEI是MEI_，等等。Removing methods-移除方法It is very difficult to remove ACPI objects, (methods, names, devices, etc) using Clover binary patches. Commonly, we must add _DSM methods to inject properties that describe various hardware properties. But added _DSM methods can conflict with existing _DSM methods that may already be in the native ACPI files. With static patching, “Remove _DSM methods” would be used.使用Clover二进制补丁来移除ACPI对象(方法、名称、设备等等)是非常困难的。通常，我们必须添加_DSM方法来注入各种描述硬件属性的属性。但是，添加_DSM方法可能与本地ACPI文件现有的_DSM方法冲突。这时，就会用到静态补丁Remove _DSM methods。Since it is difficult to remove the methods, but we don’t want the native methods to conflict with new _DSM methods that are added, the fix is to rename the native methods to something else.由于很难删除这些方法，但是我们又不希望本地方法与添加的新_DSM方法相冲突，所以就将本地方法重命名为其他名字来修复这个问题。So… again, we use a simple rename patch:那么…同样地，我们使用一个简单的重命名补丁:123Comment: Rename _DSM to XDSMFind: &lt;5f44534d&gt;Replace: &lt;5844534d&gt;Sometimes, you might rename an object to effectively disable it so it does not cause problems. For example, my Intel DH67GD DSDT defines an APSS object. If this object is left in the DSDT it interferes with power management (causes panic). I use a rename from APSS -&gt; APXX. Because AppleIntelCPUPowerManagement is looking for APSS, it does not cause a problem once renamed to APXX.有时，你可能会重命名一个对象，以便有效地禁用它，这样它就不会造成问题。例如，我的Intel DH67GD的 DSDT定义了APSS对象。如果这个对象留在DSDT中，它会干扰电源管理(引起KP)。我使用APSS-&gt;APXX的重命名。因为AppleIntelCPUPowerManagement会查找APSS,只要改名为APXX就不会引起问题。Redirect and Replace-重定向和替换In some cases, we would like to replace code to change the behavior. For this, we can rename the object and provide an alternate implementation in an SSDT.在某些情况下，我们希望替换代码来改变某些动作。为此，我们可以重命名这个对象，并在SSDT中提供一个用来替代的对象以达到目的。A common fix is spoofing the ACPI code in DSDT and SSDTs such that it behaves as if a certain version of Windows is the ACPI host. When static patching, we might use “OS Check Fix (Windows 8)”. When applied, it changes code from:一个常见的修复是在DSDT和SSDT中仿冒ACPI代码，使其表现得就像是ACPI主机的某个版本的Windows一样。当利用静态补丁时，我们可能会使用OS Check Fix (Windows 8)。当应用这个补丁时，它会将代码从:1If (_OSI(&quot;Windows 2012&quot;))To:改为：1If (LOr(_OSI(&quot;Darwin&quot;),_OSI(&quot;Windows 2012&quot;))Since the _OSI implementation in OS X only responds to “Darwin” the code is changed so that this specific _OSI check also accomodates “Darwin”.由于OS X中_OSI方法的实现只对被修改了代码的Darwin作出响应，所以这个特定的_OSI check补丁也能响应Darwin。With hotpatching, the opposite approach is taken. Instead of changing the code using _OSI, we change the code so it calls a different method that emulates the _OSI implementation that would be in the Windows ACPI host.而热补丁则采用相反的方法，我们不使用_OSI修改代码，而是改变代码让它调用一种不同的方法来模拟在Windows ACPI主机上的_OSI实现。This technique relies on two of the techniques… a patch to change all calls from _OSI to XOSI… and an implementation of XOSI that emulates what Windows would do for a certain Windows version.这项技术依赖于两种技术，一个补丁来改变从_OSI到XOSI的所有调用。另一个是XOSI的实现，即模拟Windows对某个Windows版本的操作。First, changing the code to call XOSI instead of _OSI:首先，改变代码来调用XOSI而不是_OSI:123Comment: Change _OSI to XOSIFind: &lt;5f4f 5349&gt;Replace: &lt;584f 5349&gt;The hex codes above should be no mystery (they are ASCII for _OSI and XOSI, respectively).上面的十六进制代码没有什么神秘的(它们分别是_OSI和XOSI的ASCII码)。Now the code mentioned above, after patching by Clover, will read:现在，上面提到的代码，在通过Clover打了补丁之后，将会读到:1If (XOSI(&quot;Windows 2012&quot;))Now we need an SSDT that implements XOSI. You will find such an implementation in the repository (SSDT-XOSI.dsl).现在我们需要一个实现XOSI的SSDT。你可以我的GitHub仓库中找到这样的实现(SSDT-XOSI.dsl).Note that without the SSDT that implements the XOSI method, the (patched) calls to XOSI would cause an ACPI abort (ACPI abort causes execution of the ACPI method to be terminated immediately with an error). Don’t use the _OSI-&gt;XOSI patch without the XOSI method.注意，如果没有实现XOSI方法的SSDT，这个补丁对XOSI的调用将导致ACPI的加载被终止(ACPI中止导致ACPI方法的执行被错误立即终止)。如果没有XOSI方法不要使用_OSI-&gt;XOSI补丁。Rename and Replace-重命名和替换A second pattern, similar to “Redirect and Replace” is “Rename and Replace”. In this case, instead of changing all the call sites, we change the method definition such that the method is named something different than it was originally, but leave the original method name at the call sites. This allows the method that is the target of the calls to be replaced.For example, it is very common for USB devices to cause “instant wake”. As a work around, wake on USB can be disabled. Most laptops don’t have a BIOS option for it, so instead the _PRW methods that control this feature are patched.For example, the native _SB.PCI0.EHC1._PRW method might read:1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0x03))&#125;In order to patch it so USB devices on EHCI#1 cannot cause wake, it would be changed:1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0))&#125;Usually, there are several such call sites to GPRW that need to be changed (also, keep in mind not all ACPI sets use the specific name GPRW). Instead of trying to patch all the call sites as above, we can instead patch the method definition of GPRW instead:With the original code:1234Method (GPRW, 2, NotSerialized)&#123; ...&#125;If we change it to:1234Method (XPRW, 2, NotSerialized)&#123; ...&#125;Since you don’t want to change any call sites, the patch must be constructed such that it affects only the method itself and not the call sites. According to ACPI spec, a method definition starts with bytecode 14, is followed by the method size, the method name, argument count/flags. You can use the “-l” option in iasl to generate a mixed listing of your ACPI file. For example, the Lenovo u430 GPRW method mixed listing:1234564323: Method (GPRW, 2, NotSerialized)00003F95: 14 45 08 47 50 52 57 02 &quot;.E.GPRW.&quot;4324: &#123;4325: Store (Arg0, Index (PRWP, Zero))00003F9D: 70 68 .................. &quot;ph&quot;00003F9F: 88 50 52 57 50 00 00 ... &quot;.PRWP..&quot;We could do a find replace using the method header bytes:12Find: &lt;14 45 08 47 50 52 57 02&gt;Replace: &lt;14 45 08 58 50 52 57 02&gt;But what happens if the method differs slightly between different versions of BIOS or models that are similar, but not exactly the same? In that case, the byte following the 14 will change due to the change in the method length.My thought is that the beginning of the method body is less likely to be different than the total length of the method, so it helps to add a few extra bytes from the body of the method to the find/replace specification:12Find: &lt;47 50 52 57 02 70 68&gt;Replace: &lt;58 50 52 57 02 70 68&gt;The number of follow-on bytes that you use depends on how many you need to make the find/replace affect only the method definition. You can verify by looking at the native AML binary in a hex editor such as Hex Fiend (it is a nice hex editor and is also open source).Note: Although you could search just for the method name + arg count/flags, it is possible that the same pattern will find a call site to the method which you don’t want to change. In the case of the u430 that wasn’t the case, so I was able to find/replace with just the method name+flags.12Find: &lt;47505257 02&gt;Replace: &lt;58505257 02&gt;In the case of the ProBook UPRW, it was necessary to use the follow-on bytes that are part of the method body:12Find: &lt;55505257 0a7012&gt;Replace: &lt;58505257 0a7012&gt;Now any code that calls GPRW (or UPRW in the ProBook example) will not call the implementation in XPRW because the name doesn’t match. The original XPRW is now unreachable code. Which means the GPRW implementation can be changed for our purpose:123456Method(GPRW, 2)&#123; If (0x6d == Arg0) &#123; Return(Package() &#123; 0x6d, 0, &#125;) &#125; External(\\XPRW, MethodObj) Return(XPRW(Arg0, Arg1))&#125;Explaining the code: For any call to GPRW with the first argument set to 0x6d (the GPE we are trying to disable for wake), instead of returning what the original GPRW would, we return a package with 0x6d and 0 (which disables wake). And for other GPE values, the code simply calls the original GPRW method now named XPRW.Another simple case is patching EC query methods to fix the brightness keys. A simple rename of the _Qxx methods involved to XQxx, and a new definition of the method with the original name is all that is needed.For example, in the HP Envy Haswell repo:123456789101112131415161718192021// _Q13 called on brightness/mirror display keyMethod (_Q13, 0, Serialized) // _Qxx: EC Query&#123; External(\\HKNO, FieldUnitObj) Store(HKNO, Local0) If (LEqual(Local0,7)) &#123; // Brightness Down Notify(\\_SB.PCI0.LPCB.PS2K, 0x0405) &#125; If (LEqual(Local0,8)) &#123; // Brightness Up Notify(\\_SB.PCI0.LPCB.PS2K, 0x0406) &#125; If (LEqual(Local0,4)) &#123; // Mirror toggle Notify(\\_SB.PCI0.LPCB.PS2K, 0x046e) &#125;&#125;And the associated patch:123Comment: change Method(_Q13,0,S) to XQ13Find: &lt;5f513133 08&gt;Replace: &lt;58513133 08&gt;This same “Rename and Replace” mechanism can be used in cases that are much more complex than this. For example, it is typically used to patch battery methods, which need to be patched to avoid access to multibyte EC fields.Tips for complex Rename and ReplaceAs you probably already know, patching for battery status (multibyte EC fields) can be very complex and can involve a lot of code changes to many methods.This section will detail some of the techniques and procedures used for battery patching.It is advisable to patch for battery without using hotpatch first. After you get it working, then attempt hotpatch. Also, the difference between the code not patched for battery and the code patched for battery is very helpful. You can use a tool like ‘diffmerge’ to compare each. This is especially true if there is already a static battery patch for your laptop in my laptop repository.General procedure:start with native ACPIpatch for battery status using static patching (verify it works)use diffmerge to compare the unpatched code with patched codefor each method that is different, implement the “Rename and Replace” patternfor the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patchto create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fieldsuse External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT)let the compiler point out where you need to use Externalwatch out for symbols with duplicate names in different scopesAn example is provided in post #2 of this thread.Code value patchingConsider the case of “Fix Mutex with non-zero SyncLevel”. This patch finds all Mutex objects and replaces the SyncLevel with 0. We use this patch since OS X does not support Mutex debugging correctly and aborts on any Acquire with a Mutex that has a non-zero SyncLevel.As an example, the u430 has Mutexes delcared as such:Mutex (MSMI, 0x07) To make it compatible with OS X it must be changed:Mutex (MSMI, 0) The ACPI spec defines how a Mutex object is encoded in the AML, but it can be helpful to look at a mixed disassembly of a small ACPI file:1234DefinitionBlock (&quot;&quot;, &quot;DSDT&quot;, 2, &quot;test&quot;, &quot;test&quot;, 0)&#123; Mutex(ABCD, 7)&#125;The iasl compiler can create a mixed listing file with the “-l” option.If we compile the above file with: iasl -l test.dsl, test.lst contains: 1: DefinitionBlock (&quot;&quot;, &quot;DSDT&quot;, 2, &quot;test&quot;, &quot;test&quot;, 0) 00000000: 44 53 44 54 2B 00 00 00 &quot;DSDT+...&quot; 00000008: 02 36 74 65 73 74 00 00 &quot;.6test..&quot; 00000010: 74 65 73 74 00 00 00 00 &quot;test....&quot; 00000018: 00 00 00 00 49 4E 54 4C &quot;....INTL&quot; 00000020: 10 04 16 20 ............ &quot;... &quot; 2: { 3: Mutex(ABCD, 7) 00000024: 5B 01 41 42 43 44 07 ... &quot;[.ABCD.&quot; 4: } As you can see, the Mutex(ABCD, 7), is encoded as &lt;5B 01 41 42 43 44 07&gt;It is now very easy to construct a patch for it:123Comment: Change Mutex(ABCD,7) to Mutex(ABCD,0)Find: &lt;5B 01 41 42 43 44 07&gt;Replace: &lt;5B 01 41 42 43 44 00&gt;Clover ACPI configurationWith static patching, DropOem=true is used and patched DSDT and SSDTs are added to ACPI/patched. With hotpatch, instead use DropOem=false, and only add-on SSDTs are placed in ACPI/patched.It is important to note that config.plist/ACPI/patches are applied only to native SSDTs, and not the SSDTs in ACPI/patched. This means that if you are renaming objects using config.plist, the add-on SSDTs must refer to the new names, not the old names. Unlike SSDTs in ACPI/patched, binary patches in ACPI/Patches do apply to DSDT.aml that might be in ACPI/patched. Keep this in mind if you’re using a combination of static and hotpatching.Also, with static patching, SortedOrder is used to specify the order of SSDTs in ACPI/patched. With hotpatch it is not strictly necessary as it is possible to construct the code in each SSDT such that the code is not order dependent. Especially if you place all add-on code in a single SSDT such as many of my laptop repo examples. Unless your add-on SSDTs are order dependent, you do not have to name each one in SortedOrder.It is also not necessary to choose “numbered names” for each SSDT. Instead you can use meaningful names, such as “SSDT-USB.aml”, SSDT-XOSI.aml”, etc. Using numbers instead of meaningul names will just confuse you. Don’t do it.TroubleshootingYou can use patchmatic to look at your complete ACPI set as injected by Clover after patching. By runnning ‘patchmatic -extract’, patchmatic will write all injected DSDT.aml and SSDT.aml in the order they were injected by Clover. You can disassemble them with ‘iasl -da -dl .aml’. If iasl shows errors with the disassembly (for example duplicate symbols), it is likley OS X is also rejecting the conflicting SSDTs.If you’re a novice with this technique, it is a good idea to implement one patch at a time, and slowly build it up to a full set of working patches + SSDTs. Trying to do all at once can make it difficult to locate your mistake.Battery Status HotpatchThis second post is dedicated to patching battery status with Clover hotpatch. To demonstrate the process, we will work through an example DSDT. The example files used are from the guide for disabling discrete graphics, an “Asus UX303LN”.https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/You should download the ACPI/origin files that are attached to that guide, so you can follow along.As mentioned in post #1, the general procedures are as follows:start with native ACPIpatch for battery status using static patching (verify it works)use diffmerge to compare the unpatched code with patched codefor each method that is different, implement the “Rename and Replace” patternfor the EC fields, create another EC OperationRegion (use a name that is different from the original) and Field definition as a sort of “overlay” which contains only the EC fields you need to patchto create the EC overlay, you can use the patched Field/OperationRegion in the patched DSDT, then eliminate unpatched fieldsuse External to allow the replacement methods in the SSDT to access the fields defined elsewhere in the ACPI set (usually DSDT)let the compiler point out where you need to use Externalwatch out for symbols with duplicate names in different scopesUsing diffmerge to find patched vs. native differencesStart by disassembling the origin files: iasl -da -dl *.aml(you should be familiar with this part as it is part of normal ACPI patching)Next apply the battery patch only using MaciASL to DSDT.dsl. In this case, we apply the “ASUS N55SL/VivoBook”. There is no need to fix any errors, as we are interested only in the differences created by applying the battery patch. Save the patched file as DSDT_patched.dsl.Now you can run diffmerge to see the differences between DSDT.dsl and DSDT_patched.dsl. I usually just do this from Terminal:$ diffmerge DSDT.dsl DSDT_patched.dslThe initial diffmerge window will look something like this:From there, we can examine the parts that have changes by clicking on the markers in the left column.In the examples, the groups of changes you find:group 1: is the changes to the EC fields (multibyte to single byte)group 2: addition of RDBA, WRBA, RDBB, WRBB methodsgroup 3: patched FBST, _BIX, B1FA methodsgroup 4: patched SMBR, SMBW, ECSB methodsgroup 5: patched TACH methodfinal group: addition of B1B2 methodConstructing the initial SSDTStart with an empty SSDT in MaciASL:123DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123;&#125;Next, add all methods that were added by the patch. In the example, this includes RDBA, WRBA, RDBB, WRBB and B1B2 methods. You can copy them directly from the DSDT_patched.dsl.You want to be certain each method is placed in the same scope. For example, here is the “group 2” methods added:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } And with B1B2 added:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } // added methods (group 2) Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } Don’t worry that the code does not compile at the moment. It is not expected at this point, due to the EC fields (and other identifiers) that are not defined in this file. They will need to be definined or referenced via External (eventually).Now let’s add the patched methods. Just like the methods that were added methods, the patched methods are just copied from the DSDT_patched.dsl:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { // patched methods Scope (_SB.PCI0) { Scope (BAT0) { Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) { Store (One, Local0) } If (Local0) { If (CHGS (Zero)) { Store (0x02, Local0) } Else { Store (Zero, Local0) } } Else { Store (One, Local0) } If (BLLO) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (And (^^LPCB.EC0.EB0S, 0x08)) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (LGreaterEqual (Local1, 0x8000)) { Subtract (0xFFFF, Local1, Local1) } Store (Arg2, Local2) If (LEqual (PUNT, Zero)) { Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) } And (Local0, 0x02, Local3) If (LNot (Local3)) { Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) { Store (LFCC, Local2) } } Else { Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) { Store (Local4, Local2) } } If (LNot (^^LPCB.EC0.ACAP ())) { Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) { Store (Local4, Local1) } } Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) } Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended { If (LNot (^^LPCB.EC0.BATP (Zero))) { Return (NBIX) } If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) { Return (NBIX) } _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) { Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) } Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) } } } Scope (_SB.PCI0.LPCB.EC0) { Method (BIFA, 0, NotSerialized) { If (ECAV ()) { If (BSLF) { Store (B1B2(B1S0,B1S1), Local0) } Else { Store (B1B2(B0S0,B0S1), Local0) } } Else { Store (Ones, Local0) } Return (Local0) } } Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } // added methods (group 2) Scope (_SB.PCI0.LPCB.EC0) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } Notice how FBST and _BIX were added to scope _SB.PCI0.BAT0, but BIFA was added to _SB.PCI0.LPCB.EC0. It is important to inject all methods into their original scope.Now, we add SMBR, SMBW, ECSB, and TACH:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; // patched methods Scope (_SB.PCI0) &#123; Scope (BAT0) &#123; Method (FBST, 4, NotSerialized) &#123; And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) &#123; Store (One, Local0) &#125; If (Local0) &#123; If (CHGS (Zero))&#123; Store (0x02, Local0)&#125;Else&#123; Store (Zero, Local0)&#125; &#125; Else &#123; Store (One, Local0) &#125; If (BLLO) &#123; ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) &#125; If (And (^^LPCB.EC0.EB0S, 0x08)) &#123; ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) &#125; If (LGreaterEqual (Local1, 0x8000)) &#123; Subtract (0xFFFF, Local1, Local1) &#125; Store (Arg2, Local2) If (LEqual (PUNT, Zero)) &#123; Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) &#125; And (Local0, 0x02, Local3) If (LNot (Local3)) &#123; Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) &#123; Store (LFCC, Local2) &#125; &#125; Else &#123; Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) &#123; Store (Local4, Local2) &#125; &#125; If (LNot (^^LPCB.EC0.ACAP ())) &#123; Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) &#123; Store (Local4, Local1) &#125; &#125; Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) &#125; Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended &#123; If (LNot (^^LPCB.EC0.BATP (Zero))) &#123; Return (NBIX) &#125; If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) &#123; Return (NBIX) &#125; _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) &#123; Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) &#125; Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) &#125; &#125; &#125; Scope (_SB.PCI0.LPCB.EC0) &#123; Method (BIFA, 0, NotSerialized) &#123; If (ECAV ()) &#123; If (BSLF) &#123; Store (B1B2(B1S0,B1S1), Local0) &#125; Else &#123; Store (B1B2(B0S0,B0S1), Local0) &#125; &#125; Else &#123; Store (Ones, Local0) &#125; Return (Local0) &#125; Method (SMBR, 3, Serialized) &#123; Store (Package (0x03) &#123; 0x07, Zero, Zero &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, RDBL)) &#123; If (LNotEqual (Arg0, RDWD)) &#123; If (LNotEqual (Arg0, RDBT)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; If (LNotEqual (Arg0, RDQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; ShiftLeft (Arg1, One, Local3) Or (Local3, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, RDQK)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; Store (Arg2, CMDB) &#125; &#125; WRBA(Zero) Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) If (LEqual (DerefOf (Index (Local0, Zero)), Zero)) &#123; If (LEqual (Arg0, RDBL)) &#123; Store (BCNT, Index (Local0, One)) Store (RDBA(), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDWD)) &#123; Store (0x02, Index (Local0, One)) Store (B1B2(T2B0,T2B1), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RCBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; &#125; &#125; Release (MUEC) Return (Local0) &#125; Method (SMBW, 5, Serialized) &#123; Store (Package (0x01) &#123; 0x07 &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, WRBL)) &#123; If (LNotEqual (Arg0, WRWD)) &#123; If (LNotEqual (Arg0, WRBT)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; If (LNotEqual (Arg0, WRQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; WRBA(Zero) ShiftLeft (Arg1, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, WRQK)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; Store (Arg2, CMDB) &#125; &#125; If (LEqual (Arg0, WRBL)) &#123; Store (Arg3, BCNT) WRBA(Arg4) &#125; If (LEqual (Arg0, WRWD)) &#123; Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1) &#125; If (LEqual (Arg0, WRBT)) &#123; Store (Arg4, DAT0) &#125; If (LEqual (Arg0, SDBT)) &#123; Store (Arg4, DAT0) &#125; Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) &#125; Release (MUEC) Return (Local0) &#125; Method (ECSB, 7, NotSerialized) &#123; Store (Package (0x05) &#123; 0x11, Zero, Zero, Zero, Buffer (0x20)&#123;&#125; &#125;, Local1) If (LGreater (Arg0, One)) &#123; Return (Local1) &#125; If (ECAV ()) &#123; Acquire (MUEC, 0xFFFF) If (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; Store (Zero, Local2) While (LNotEqual (Local0, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local1, Zero)) Store (Zero, Local0) &#125; ElseIf (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; If (LEqual (Arg0, Zero)) &#123; Store (Arg2, ADDR) Store (Arg3, CMDB) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCNT) WRBA(DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DAT0) Store (Arg5, DAT1) &#125; Store (Arg1, PRTC) &#125; Else &#123; Store (Arg2, ADD2) Store (Arg3, CMD2) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCN2) WRBB(DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DA20) Store (Arg5, DA21) &#125; Store (Arg1, PRT2) &#125; Store (0x7F, Local0) If (LEqual (Arg0, Zero)) &#123; While (PRTC) &#123; Sleep (One) Decrement (Local0) &#125; &#125; Else &#123; While (PRT2) &#123; Sleep (One) Decrement (Local0) &#125; &#125; If (Local0) &#123; If (LEqual (Arg0, Zero)) &#123; Store (SSTS, Local0) Store (DAT0, Index (Local1, One)) Store (DAT1, Index (Local1, 0x02)) Store (BCNT, Index (Local1, 0x03)) Store (RDBA(), Index (Local1, 0x04)) &#125; Else &#123; Store (SST2, Local0) Store (DA20, Index (Local1, One)) Store (DA21, Index (Local1, 0x02)) Store (BCN2, Index (Local1, 0x03)) Store (RDBB(), Index (Local1, 0x04)) &#125; And (Local0, 0x1F, Local0) If (Local0) &#123; Add (Local0, 0x10, Local0) &#125; Store (Local0, Index (Local1, Zero)) &#125; Else &#123; Store (0x10, Index (Local1, Zero)) &#125; &#125; Release (MUEC) &#125; Return (Local1) &#125; Method (TACH, 1, Serialized) &#123; If (ECAV ()) &#123; Switch (Arg0) &#123; Case (Zero) &#123; Store (B1B2(TH00,TH01), Local0) Break &#125; Case (One) &#123; Store (B1B2(TH10,TH11), Local0) Break &#125; Default &#123; Return (Ones) &#125; &#125; Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) &#123; Divide (0x0041CDB4, Local0, Local1, Local0) Return (Local0) &#125; Else &#123; Return (Ones) &#125; &#125; Else &#123; Return (Ones) &#125; &#125; &#125; Method (B1B2, 2, NotSerialized) &#123; Return (Or (Arg0, ShiftLeft (Arg1, 8))) &#125; // added methods (group 2) Scope (_SB.PCI0.LPCB) &#123; Scope (EC0) &#123; Method (RDBA, 0, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) &#125; Method (WRBA, 1, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) &#125; Method (RDBB, 0, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) &#125; Method (WRBB, 1, Serialized) &#123; Name (TEMP, Buffer(0x20) &#123; &#125;) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) &#125; &#125; &#125;&#125;With all the nodes expanded in MaciASL, our work looks like this:Resolving errorsNow we need to start resolving errors by using External or defining the patched EC fields as necessary.We can use the compiler to help.Clicking Compile will show the first error: “3, 6085, Object not found or not accessible from scope (_SB.PCI0)”It is at this line:Scope (_SB.PCI0) The compiler is indicating that _SB.PCI0 is not declared, so you can’t use it in a Scope operator.We need to declare it with External, as the scope is actually defined in another file (DSDT.aml):Add it to the top of the file:123456DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; External(_SB.PCI0, DeviceObj) Scope (_SB.PCI0) &#123;...Now the next error is at “Scope(BAT0)”, so, again:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) Scope (_SB.PCI0) { Scope (BAT0) { ... The next error is “13, 6085, Object not found or not accessible from scope (^^LPCB.EC0.ACAP)”We can tell from the code referencing ACAP that it is a method:If (^^LPCB.EC0.ACAP ()) Note: Method calls are indicated by the “()” (in this case, an empty parameter list).So, we know we can add an External as MethodObj:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) ... } Note: The path ^^LPCB.EC0.ACAP is equivalent to _SB.PCI0.LPCB.EC0.ACAP because the reference was in scope _SB.PCI0.BAT0.FBST (the path of the FBST method). Each ^ (parent of) operator walks up the current scope by one item, so ^ is _SB.PCI0.BAT0, and ^^ is _SB.PCI0.In some cases, you need to look at the DSDT to find the path and/or type of a given identifier. For example, the next error has to do with CHGS. Again, we know it is a method as it is the target of a method call, but for the path, we must refer to the DSDT:Code (Text):Scope (\\) { Method (CHGS, 1, Serialized) { Store (\\_SB.PCI0.LPCB.EC0.BCHG (Arg0), Local0) Return (Local0) } So, it is in the root:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) ... The next undefined symbol, BLLO, is something other than a method:If (BLLO) { Looking in DSDT, we find it is defined with Name (and it happens to be in root scope):Name (BLLO, Zero) Which makes it an IntObj:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) ... Fixing all the errors in the FBST method:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) ... And now continue with the same process.Eventually, you will have:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) ... And will come to an error with XC30/XC31: “153, 6085, Object not found or not accessible from scope (^^LPCB.EC0.XC30)”This is one of the 16-bit fields that was broken into two.And this is where it is necessary to create the EC overlay.To do this, we use another OperationRegion within EC scope, that has a different name than what we find in DSDT:External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { } } And from DSDT_patched.dsl, we can get the various patched fields (again refer to the diffmerge).This is the entire set from ECOR in the DSDT_patched.dslOffset (0x04), CMD1, 8, CDT1, 8, CDT2, 8, CDT3, 8, Offset (0x80), Offset (0x81), Offset (0x82), Offset (0x83), EB0R, 8, EB1R, 8, EPWF, 8, Offset (0x87), Offset (0x88), Offset (0x89), Offset (0x8A), HKEN, 1, Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, TSTP, 8, Offset (0x9C), CDT4, 8, CDT5, 8, Offset (0xA0), Offset (0xA1), Offset (0xA2), Offset (0xA3), EACT, 8, TH1R, 8, TH1L, 8, TH0R, 8, TH0L, 8, Offset (0xB0), B0PN, 16, Offset (0xB4), Offset (0xB6), Offset (0xB8), Offset (0xBA), Offset (0xBC), Offset (0xBE), B0TM, 16, B0C1, 16, B0C2, 16, XC30,8,XC31,8, B0C4, 16, Offset (0xD0), B1PN, 16, Offset (0xD4), Offset (0xD6), Offset (0xD8), Offset (0xDA), Offset (0xDC), Offset (0xDE), B1TM, 16, B1C1, 16, B1C2, 16, YC30,8,YC31,8, B1C4, 16, Offset (0xF0), Offset (0xF2), Offset (0xF4), B0S0,8,B0S1,8, Offset (0xF8), Offset (0xFA), Offset (0xFC), B1S0,8,B1S1,8 And if we strip the unpatched identifiers, but keep the offsets correct (very important!):Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xBE), /*B0TM*/, 16, /*B0C1*/, 16, /*B0C2*/, 16, XC30,8,XC31,8, Offset (0xDE), /*B1TM*/, 16, /*B1C1*/, 16, /*B1C2*/, 16, YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 The same thing can be written as follows:Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 So, into our SSDT:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } } And then on to fixing more errors, we add some more External:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { ... And then we have errors with T2B0 and T2B1. These are again broken down 16-bit EC fields that need to be defined in our EC overlay. In fact, might as well define the rest we know we need (from diffmerge data).There is patched data in SMBX:OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) So, we create a similar overlay, with a unique name: OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } And similar withe SMB2 region: OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } And the T2B0 and T2B1 that are in orginal SMBX, but now RMB1:Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } And now we have:External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } } Then continue on with fixing more errors with External (it ends eventually!), by adding these External declarations:External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.WRBL, IntObj) External(_SB.PCI0.LPCB.EC0.WRWD, IntObj) External(_SB.PCI0.LPCB.EC0.WRBT, IntObj) External(_SB.PCI0.LPCB.EC0.SDBT, IntObj) External(_SB.PCI0.LPCB.EC0.WRQK, IntObj) External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj) Note: With DAT0, don’t be confused at the “other” DAT0 in a different scope!At this point, the SSDT compiles without any errors:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0) { External(_SB.PCI0, DeviceObj) External(_SB.PCI0.BAT0, DeviceObj) External(_SB.PCI0.LPCB.EC0.ACAP, MethodObj) External(CHGS, MethodObj) External(BLLO, IntObj) External(_SB.PCI0.LPCB.EC0.EB0S, FieldUnitObj) External(_SB.PCI0.BAT0.PUNT, IntObj) External(_SB.PCI0.LPCB.EC0.B0DV, FieldUnitObj) External(_SB.PCI0.BAT0.LFCC, IntObj) External(MBLF, IntObj) External(_SB.PCI0.BAT0.PBST, PkgObj) External(_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(_SB.PCI0.BAT0.NBIX, PkgObj) External(_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(_SB.PCI0.BAT0._BIF, MethodObj) External(_SB.PCI0.BAT0.PBIF, PkgObj) External(_SB.PCI0.BAT0.BIXT, PkgObj) External(_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(BSLF, IntObj) External(_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.WRBL, IntObj) External(_SB.PCI0.LPCB.EC0.WRWD, IntObj) External(_SB.PCI0.LPCB.EC0.WRBT, IntObj) External(_SB.PCI0.LPCB.EC0.SDBT, IntObj) External(_SB.PCI0.LPCB.EC0.WRQK, IntObj) External(_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj) External(_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj) External(_SB.PCI0.LPCB, DeviceObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) Scope(_SB.PCI0.LPCB.EC0) { OperationRegion (ERM2, EmbeddedControl, Zero, 0xFF) Field(ERM2, ByteAcc, NoLock, Preserve) { Offset (0x93), TH00,8,TH01,8, TH10,8,TH11,8, Offset (0xc4), XC30,8,XC31,8, Offset (0xe4), YC30,8,YC31,8, Offset (0xF4), B0S0,8,B0S1,8, Offset (0xFC), B1S0,8,B1S1,8 } OperationRegion (RMB1, EmbeddedControl, 0x18, 0x28) Field (RMB1, ByteAcc, NoLock, Preserve) { /* Note: disabling these fields (already defined in DSDT, referenced with External if needed, but keeping the correct offset! (very important!) */ */ PRTC, 8, SSTS, 5, , 1, ALFG, 1, CDFG, 1, ADDR, 8, CMDB, 8, */ Offset(4), // the data above is 4 bytes offset from the start of this region! //BDAT, 256, BA00,8,BA01,8,BA02,8,BA03,8, BA04,8,BA05,8,BA06,8,BA07,8, BA08,8,BA09,8,BA0A,8,BA0B,8, BA0C,8,BA0D,8,BA0E,8,BA0F,8, BA10,8,BA11,8,BA12,8,BA13,8, BA14,8,BA15,8,BA16,8,BA17,8, BA18,8,BA19,8,BA1A,8,BA1B,8, BA1C,8,BA1D,8,BA1E,8,BA1F,8 } OperationRegion(RMB2, EmbeddedControl, 0x40, 0x28) Field (RMB2, ByteAcc, NoLock, Preserve) { /* PRT2, 8, SST2, 5, , 1, ALF2, 1, CDF2, 1, ADD2, 8, CMD2, 8, */ Offset(4), //BDA2, 256, BB00,8,BB01,8,BB02,8,BB03,8, BB04,8,BB05,8,BB06,8,BB07,8, BB08,8,BB09,8,BB0A,8,BB0B,8, BB0C,8,BB0D,8,BB0E,8,BB0F,8, BB10,8,BB11,8,BB12,8,BB13,8, BB14,8,BB15,8,BB16,8,BB17,8, BB18,8,BB19,8,BB1A,8,BB1B,8, BB1C,8,BB1D,8,BB1E,8,BB1F,8 } Field (RMB1, ByteAcc, NoLock, Preserve) { Offset (0x04), T2B0,8,T2B1,8 } } Scope (_SB.PCI0) { Scope (BAT0) { Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) If (^^LPCB.EC0.ACAP ()) { Store (One, Local0) } If (Local0) { If (CHGS (Zero)) { Store (0x02, Local0) } Else { Store (Zero, Local0) } } Else { Store (One, Local0) } If (BLLO) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (And (^^LPCB.EC0.EB0S, 0x08)) { ShiftLeft (One, 0x02, Local2) Or (Local0, Local2, Local0) } If (LGreaterEqual (Local1, 0x8000)) { Subtract (0xFFFF, Local1, Local1) } Store (Arg2, Local2) If (LEqual (PUNT, Zero)) { Multiply (Local1, ^^LPCB.EC0.B0DV, Local1) Multiply (Local2, 0x0A, Local2) } And (Local0, 0x02, Local3) If (LNot (Local3)) { Subtract (LFCC, Local2, Local3) Divide (LFCC, 0xC8, Local4, Local5) If (LLess (Local3, Local5)) { Store (LFCC, Local2) } } Else { Divide (LFCC, 0xC8, Local4, Local5) Subtract (LFCC, Local5, Local4) If (LGreater (Local2, Local4)) { Store (Local4, Local2) } } If (LNot (^^LPCB.EC0.ACAP ())) { Divide (Local2, MBLF, Local3, Local4) If (LLess (Local1, Local4)) { Store (Local4, Local1) } } Store (Local0, Index (PBST, Zero)) Store (Local1, Index (PBST, One)) Store (Local2, Index (PBST, 0x02)) Store (Arg3, Index (PBST, 0x03)) } Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended { If (LNot (^^LPCB.EC0.BATP (Zero))) { Return (NBIX) } If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) { Return (NBIX) } _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) { Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) } Store (B1B2(^^LPCB.EC0.XC30,^^LPCB.EC0.XC31), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) } } } Scope (_SB.PCI0.LPCB.EC0) { Method (BIFA, 0, NotSerialized) { If (ECAV ()) { If (BSLF) { Store (B1B2(B1S0,B1S1), Local0) } Else { Store (B1B2(B0S0,B0S1), Local0) } } Else { Store (Ones, Local0) } Return (Local0) } Method (SMBR, 3, Serialized) { Store (Package (0x03) { 0x07, Zero, Zero }, Local0) If (LNot (ECAV ())) { Return (Local0) } If (LNotEqual (Arg0, RDBL)) { If (LNotEqual (Arg0, RDWD)) { If (LNotEqual (Arg0, RDBT)) { If (LNotEqual (Arg0, RCBT)) { If (LNotEqual (Arg0, RDQK)) { Return (Local0) } } } } } Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) } Else { Store (PRTC, Local1) } } If (LLessEqual (Local2, 0x03E8)) { ShiftLeft (Arg1, One, Local3) Or (Local3, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, RDQK)) { If (LNotEqual (Arg0, RCBT)) { Store (Arg2, CMDB) } } WRBA(Zero) Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) If (LEqual (DerefOf (Index (Local0, Zero)), Zero)) { If (LEqual (Arg0, RDBL)) { Store (BCNT, Index (Local0, One)) Store (RDBA(), Index (Local0, 0x02)) } If (LEqual (Arg0, RDWD)) { Store (0x02, Index (Local0, One)) Store (B1B2(T2B0,T2B1), Index (Local0, 0x02)) } If (LEqual (Arg0, RDBT)) { Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) } If (LEqual (Arg0, RCBT)) { Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) } } } Release (MUEC) Return (Local0) } Method (SMBW, 5, Serialized) { Store (Package (0x01) { 0x07 }, Local0) If (LNot (ECAV ())) { Return (Local0) } If (LNotEqual (Arg0, WRBL)) { If (LNotEqual (Arg0, WRWD)) { If (LNotEqual (Arg0, WRBT)) { If (LNotEqual (Arg0, SDBT)) { If (LNotEqual (Arg0, WRQK)) { Return (Local0) } } } } } Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) } Else { Store (PRTC, Local1) } } If (LLessEqual (Local2, 0x03E8)) { WRBA(Zero) ShiftLeft (Arg1, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, WRQK)) { If (LNotEqual (Arg0, SDBT)) { Store (Arg2, CMDB) } } If (LEqual (Arg0, WRBL)) { Store (Arg3, BCNT) WRBA(Arg4) } If (LEqual (Arg0, WRWD)) { Store(Arg4,T2B0) Store(ShiftRight(Arg4,8),T2B1) } If (LEqual (Arg0, WRBT)) { Store (Arg4, DAT0) } If (LEqual (Arg0, SDBT)) { Store (Arg4, DAT0) } Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) } Release (MUEC) Return (Local0) } Method (ECSB, 7, NotSerialized) { Store (Package (0x05) { 0x11, Zero, Zero, Zero, Buffer (0x20){} }, Local1) If (LGreater (Arg0, One)) { Return (Local1) } If (ECAV ()) { Acquire (MUEC, 0xFFFF) If (LEqual (Arg0, Zero)) { Store (PRTC, Local0) } Else { Store (PRT2, Local0) } Store (Zero, Local2) While (LNotEqual (Local0, Zero)) { Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) { Store (SBBY, Index (Local1, Zero)) Store (Zero, Local0) } ElseIf (LEqual (Arg0, Zero)) { Store (PRTC, Local0) } Else { Store (PRT2, Local0) } } If (LLessEqual (Local2, 0x03E8)) { If (LEqual (Arg0, Zero)) { Store (Arg2, ADDR) Store (Arg3, CMDB) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) { Store (DerefOf (Index (Arg6, Zero)), BCNT) WRBA(DerefOf (Index (Arg6, One))) } Else { Store (Arg4, DAT0) Store (Arg5, DAT1) } Store (Arg1, PRTC) } Else { Store (Arg2, ADD2) Store (Arg3, CMD2) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) { Store (DerefOf (Index (Arg6, Zero)), BCN2) WRBB(DerefOf (Index (Arg6, One))) } Else { Store (Arg4, DA20) Store (Arg5, DA21) } Store (Arg1, PRT2) } Store (0x7F, Local0) If (LEqual (Arg0, Zero)) { While (PRTC) { Sleep (One) Decrement (Local0) } } Else { While (PRT2) { Sleep (One) Decrement (Local0) } } If (Local0) { If (LEqual (Arg0, Zero)) { Store (SSTS, Local0) Store (DAT0, Index (Local1, One)) Store (DAT1, Index (Local1, 0x02)) Store (BCNT, Index (Local1, 0x03)) Store (RDBA(), Index (Local1, 0x04)) } Else { Store (SST2, Local0) Store (DA20, Index (Local1, One)) Store (DA21, Index (Local1, 0x02)) Store (BCN2, Index (Local1, 0x03)) Store (RDBB(), Index (Local1, 0x04)) } And (Local0, 0x1F, Local0) If (Local0) { Add (Local0, 0x10, Local0) } Store (Local0, Index (Local1, Zero)) } Else { Store (0x10, Index (Local1, Zero)) } } Release (MUEC) } Return (Local1) } Method (TACH, 1, Serialized) { If (ECAV ()) { Switch (Arg0) { Case (Zero) { Store (B1B2(TH00,TH01), Local0) Break } Case (One) { Store (B1B2(TH10,TH11), Local0) Break } Default { Return (Ones) } } Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) { Divide (0x0041CDB4, Local0, Local1, Local0) Return (Local0) } Else { Return (Ones) } } Else { Return (Ones) } } } Method (B1B2, 2, NotSerialized) { Return (Or (Arg0, ShiftLeft (Arg1, 8))) } Scope (_SB.PCI0.LPCB) { Scope (EC0) { Method (RDBA, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BA00, Index(TEMP, 0x00)) Store (BA01, Index(TEMP, 0x01)) Store (BA02, Index(TEMP, 0x02)) Store (BA03, Index(TEMP, 0x03)) Store (BA04, Index(TEMP, 0x04)) Store (BA05, Index(TEMP, 0x05)) Store (BA06, Index(TEMP, 0x06)) Store (BA07, Index(TEMP, 0x07)) Store (BA08, Index(TEMP, 0x08)) Store (BA09, Index(TEMP, 0x09)) Store (BA0A, Index(TEMP, 0x0A)) Store (BA0B, Index(TEMP, 0x0B)) Store (BA0C, Index(TEMP, 0x0C)) Store (BA0D, Index(TEMP, 0x0D)) Store (BA0E, Index(TEMP, 0x0E)) Store (BA0F, Index(TEMP, 0x0F)) Store (BA10, Index(TEMP, 0x10)) Store (BA11, Index(TEMP, 0x11)) Store (BA12, Index(TEMP, 0x12)) Store (BA13, Index(TEMP, 0x13)) Store (BA14, Index(TEMP, 0x14)) Store (BA15, Index(TEMP, 0x15)) Store (BA16, Index(TEMP, 0x16)) Store (BA17, Index(TEMP, 0x17)) Store (BA18, Index(TEMP, 0x18)) Store (BA19, Index(TEMP, 0x19)) Store (BA1A, Index(TEMP, 0x1A)) Store (BA1B, Index(TEMP, 0x1B)) Store (BA1C, Index(TEMP, 0x1C)) Store (BA1D, Index(TEMP, 0x1D)) Store (BA1E, Index(TEMP, 0x1E)) Store (BA1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBA, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BA00) Store (DerefOf(Index(TEMP, 0x01)), BA01) Store (DerefOf(Index(TEMP, 0x02)), BA02) Store (DerefOf(Index(TEMP, 0x03)), BA03) Store (DerefOf(Index(TEMP, 0x04)), BA04) Store (DerefOf(Index(TEMP, 0x05)), BA05) Store (DerefOf(Index(TEMP, 0x06)), BA06) Store (DerefOf(Index(TEMP, 0x07)), BA07) Store (DerefOf(Index(TEMP, 0x08)), BA08) Store (DerefOf(Index(TEMP, 0x09)), BA09) Store (DerefOf(Index(TEMP, 0x0A)), BA0A) Store (DerefOf(Index(TEMP, 0x0B)), BA0B) Store (DerefOf(Index(TEMP, 0x0C)), BA0C) Store (DerefOf(Index(TEMP, 0x0D)), BA0D) Store (DerefOf(Index(TEMP, 0x0E)), BA0E) Store (DerefOf(Index(TEMP, 0x0F)), BA0F) Store (DerefOf(Index(TEMP, 0x10)), BA10) Store (DerefOf(Index(TEMP, 0x11)), BA11) Store (DerefOf(Index(TEMP, 0x12)), BA12) Store (DerefOf(Index(TEMP, 0x13)), BA13) Store (DerefOf(Index(TEMP, 0x14)), BA14) Store (DerefOf(Index(TEMP, 0x15)), BA15) Store (DerefOf(Index(TEMP, 0x16)), BA16) Store (DerefOf(Index(TEMP, 0x17)), BA17) Store (DerefOf(Index(TEMP, 0x18)), BA18) Store (DerefOf(Index(TEMP, 0x19)), BA19) Store (DerefOf(Index(TEMP, 0x1A)), BA1A) Store (DerefOf(Index(TEMP, 0x1B)), BA1B) Store (DerefOf(Index(TEMP, 0x1C)), BA1C) Store (DerefOf(Index(TEMP, 0x1D)), BA1D) Store (DerefOf(Index(TEMP, 0x1E)), BA1E) Store (DerefOf(Index(TEMP, 0x1F)), BA1F) } Method (RDBB, 0, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (BB00, Index(TEMP, 0x00)) Store (BB01, Index(TEMP, 0x01)) Store (BB02, Index(TEMP, 0x02)) Store (BB03, Index(TEMP, 0x03)) Store (BB04, Index(TEMP, 0x04)) Store (BB05, Index(TEMP, 0x05)) Store (BB06, Index(TEMP, 0x06)) Store (BB07, Index(TEMP, 0x07)) Store (BB08, Index(TEMP, 0x08)) Store (BB09, Index(TEMP, 0x09)) Store (BB0A, Index(TEMP, 0x0A)) Store (BB0B, Index(TEMP, 0x0B)) Store (BB0C, Index(TEMP, 0x0C)) Store (BB0D, Index(TEMP, 0x0D)) Store (BB0E, Index(TEMP, 0x0E)) Store (BB0F, Index(TEMP, 0x0F)) Store (BB10, Index(TEMP, 0x10)) Store (BB11, Index(TEMP, 0x11)) Store (BB12, Index(TEMP, 0x12)) Store (BB13, Index(TEMP, 0x13)) Store (BB14, Index(TEMP, 0x14)) Store (BB15, Index(TEMP, 0x15)) Store (BB16, Index(TEMP, 0x16)) Store (BB17, Index(TEMP, 0x17)) Store (BB18, Index(TEMP, 0x18)) Store (BB19, Index(TEMP, 0x19)) Store (BB1A, Index(TEMP, 0x1A)) Store (BB1B, Index(TEMP, 0x1B)) Store (BB1C, Index(TEMP, 0x1C)) Store (BB1D, Index(TEMP, 0x1D)) Store (BB1E, Index(TEMP, 0x1E)) Store (BB1F, Index(TEMP, 0x1F)) Return (TEMP) } Method (WRBB, 1, Serialized) { Name (TEMP, Buffer(0x20) { }) Store (Arg0, TEMP) Store (DerefOf(Index(TEMP, 0x00)), BB00) Store (DerefOf(Index(TEMP, 0x01)), BB01) Store (DerefOf(Index(TEMP, 0x02)), BB02) Store (DerefOf(Index(TEMP, 0x03)), BB03) Store (DerefOf(Index(TEMP, 0x04)), BB04) Store (DerefOf(Index(TEMP, 0x05)), BB05) Store (DerefOf(Index(TEMP, 0x06)), BB06) Store (DerefOf(Index(TEMP, 0x07)), BB07) Store (DerefOf(Index(TEMP, 0x08)), BB08) Store (DerefOf(Index(TEMP, 0x09)), BB09) Store (DerefOf(Index(TEMP, 0x0A)), BB0A) Store (DerefOf(Index(TEMP, 0x0B)), BB0B) Store (DerefOf(Index(TEMP, 0x0C)), BB0C) Store (DerefOf(Index(TEMP, 0x0D)), BB0D) Store (DerefOf(Index(TEMP, 0x0E)), BB0E) Store (DerefOf(Index(TEMP, 0x0F)), BB0F) Store (DerefOf(Index(TEMP, 0x10)), BB10) Store (DerefOf(Index(TEMP, 0x11)), BB11) Store (DerefOf(Index(TEMP, 0x12)), BB12) Store (DerefOf(Index(TEMP, 0x13)), BB13) Store (DerefOf(Index(TEMP, 0x14)), BB14) Store (DerefOf(Index(TEMP, 0x15)), BB15) Store (DerefOf(Index(TEMP, 0x16)), BB16) Store (DerefOf(Index(TEMP, 0x17)), BB17) Store (DerefOf(Index(TEMP, 0x18)), BB18) Store (DerefOf(Index(TEMP, 0x19)), BB19) Store (DerefOf(Index(TEMP, 0x1A)), BB1A) Store (DerefOf(Index(TEMP, 0x1B)), BB1B) Store (DerefOf(Index(TEMP, 0x1C)), BB1C) Store (DerefOf(Index(TEMP, 0x1D)), BB1D) Store (DerefOf(Index(TEMP, 0x1E)), BB1E) Store (DerefOf(Index(TEMP, 0x1F)), BB1F) } } } } //EOF The resulting file can be saved as AML (suggested name: SSDT-BATT.aml), and placed in ACPI/patched.But you can’t expect battery status to work with native DSDT yet!Renaming existing methodsFor now, there are duplicate methods in DSDT and this SSDT-BATT.aml. For each method in DSDT that the SSDT-BATT.aml version will replace, we must rename the method in DSDT to something else, which will allow the SSDT version to override.Just as in post #1, this part follows the “Rename/Replace” pattern.The methods that need replacements are FBST, _BIX, BIFA, SMBR, SMBW, ECSB, and TACH.For this step, it is useful to create a mixed bytecode listing for the native DSDT.aml.It can be created with: “iasl -l -dl DSDT.aml”, which creates a mixed listing in DSDT.dslFor the FBST method:Method (FBST, 4, NotSerialized) { And (Arg1, 0xFFFF, Local1) Store (Zero, Local0) FF74: 14 43 12 46 42 53 54 04 7B 69 0B FF FF 61 70 00 // .C.FBST.{i...ap. FF84: 60 A potential rename patch (FBST-&gt;XBST):12Find: &lt;46 42 53 54 04&gt;Replace: &lt;58 42 53 54 04&gt;It is a good idea to verify that there is only one match for the Find hex data by searching for it in a hex editor such as Hex Fiend. Because the patch should ONLY apply to the method definition, not other code that may be present in the DSDT (or native SSDTs).The target name you choose must be unique within the scope that the method resides. Creating a duplicate method will cause kernel panic. Changing the first letter to ‘X’ is usually ok, but no guarantee.Patches for the rest of the methods:123_BIX-&gt;XBIX:Find: &lt;5F 42 49 58 00&gt;Replace: &lt;58 42 49 58 00&gt;123BIFA-&gt;XIFA:Find: &lt;42 49 46 41 00&gt;Replace: &lt;58 49 46 41 00&gt;123SMBR-&gt;XMBR:Find: &lt;53 4D 42 52 0B&gt;Replace: &lt;58 4D 42 52 0B&gt;123SMBW-&gt;XMBW:Find: &lt;53 4D 42 57 0D&gt;Replace: &lt;58 4D 42 57 0D&gt;123ECSB-&gt;XCSB:Find: &lt;45 43 53 42 07&gt;Replace: &lt;58 43 53 42 07&gt;123TACH-&gt;XACH:Find: &lt;54 41 43 48 09&gt;Replace: &lt;58 41 43 48 09&gt;After adding those patches to config.plist/ACPI/DSDT/Patches, the methods in native DSDT will be renamed by Clover. And as a result of the renaming, the patched methods defined in SSDT-BATT.aml will override.ConclusionHotpatching for battery status is one of the most complex hotpatch tasks possible. The process of writing all the ‘External’ refernences is tedious and boring.It will take some time (several hours into the text you’re reading here). Do not rush it.Disabling discrete/switched GPU with HotpatchThis third post is dedicated to hotpatching required for disabling the discrete GPU in a switched dual-GPU laptop, using the same example ACPI fils as the static patch guide.https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/You should download the ACPI/origin files that are attached to that guide, so you can follow along.As in the static patch guide, the goal is relatively simple: call the _OFF method (from an _INI method) for the discrete GPU during ACPI initialization. But the details make it more complex due to the fact that _OFF can contain EC related code which needs to be executed in _REG instead of _INI.Building the replacement _INI/_OFF/_REG methodsIn the example, the target _INI method is in SSDT-7, _OFF is in SSDT-8. The path of the discrete device is _SB.PCI0.RP05.PEGP. In the example files, _OFF contains EC related code that must be moved to _REG. To complete this patching process, we need to replace _INI, _OFF, and _REG, therefore each will need to be renamed to XINI, XOFF, and XREGNote: The methods you need to patch may in fact be different. It all depends on the code within the _OFF path. For example, with other ACPI sets, it happens that SGOF (may be some other name) has EC related code that must be moved to _REG. In that case, you would need to use rename/replace for the SGOF, and perhaps not the _OFF method. Analyze your existing code carefully.The Clover config.plist patches will be worked out later. For now, lets look at the SSDT for the replacement methods.The SSDT will consist of the patched methods:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;D-GPU&quot;, 0) { External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } At this point, the code won’t compile, as some of the symbols referenced in _OFF are not available.Just like the battery patching guide, we must add the appropriate External declarations.Use the compiler errors to determine which symbols you need to find, then add the appropriate External declartions. In the example case:External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) The resulting SSDT:DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;D-GPU&quot;, 0) { External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } } Now it compiles without error, but there is one warning: “39, 3079, _REG has no corresponding Operation Region”. And this warning is important. The _REG will not be called unless we add a dummy EC OperationRegion.We can add it:... Scope(_SB.PCI0.LPCB.EC0) { OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) { ... Resulting complete SSDT:External(_SB.PCI0.RP05.PEGP, DeviceObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.RP05.PEGP.XOFF, MethodObj) External(_SB.PCI0.RP05.PEGP.XINI, MethodObj) External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.LPCB.EC0.SPIN, MethodObj) External(_SB.PCI0.RP05.PEGP.CTXT, IntObj) External(_SB.PCI0.RP05.PEGP.GPRF, IntObj) External(_SB.PCI0.RP05.PEGP.VGAR, FieldUnitObj) External(_SB.PCI0.RP05.PEGP.VGAB, BuffObj) External(_SB.PCI0.RP05.PEGP.SGOF, MethodObj) Scope(_SB.PCI0.RP05.PEGP) { Method(_INI) { XINI() // call original _INI, now renamed XINI _OFF() // call (patched) _OFF } Method(_OFF, 0, Serialized) { If (LEqual (CTXT, Zero)) { /* \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) */ If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } SGOF () } } Scope(_SB.PCI0.LPCB.EC0) { OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) { XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? { \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) // code that was removed from _OFF } } } At this point, you can save the SSDT (suggestion: SSDT-DGPU.aml).It is ready to go to ACPI/patched.But we still need to rename the original methods in native ACPI.Renaming the methodsAs mentioned earlier, the following methods need renaming:_SB.PCI0.RP05.PEGP._INI -&gt; XINI_SB.PCI0.RP05.PEGP._OFF -&gt; XOFF_SB.PCI0.LPCB.EC0._REG -&gt; XREGTo determine the binary patches needed, we need a mixed listing of DSDT.aml, SSDT-7.aml, and SSDT-8.aml.Create with:1iasl -dl -l DSDT.aml SSDT-7.aml SSDT-8.amlThe resulting mixed listing is in DSDT.dsl, SSDT-7.dsl, and SSDT-8.dsl.Here is the mixed listing for _REG in DSDT.dsl:Code (Text): Method (_REG, 2, NotSerialized) // _REG: Region Availability { D2B8: 14 12 5F 52 45 47 02 // .._REG. If (LEqual (Arg0, 0x03)) { D2BF: A0 0B 93 68 0A 03 // ...h.. Store (Arg1, ECFL) } } } } D2C5: 70 69 45 43 46 4C The patch used should rename only this _REG, not other _REG methods in the ACPI set. We can rename it by grabbing the name/header plus a few bytes from the code.This pattern grabs enough bytes to be unique for sure:12Find: &lt;5F 52 45 47 02 A0 0B 93 68 0A 03 70 69 45 43 46 4C&gt;Replace: &lt;58 52 45 47 02 A0 0B 93 68 0A 03 70 69 45 43 46 4C&gt;And the mixed listing for the target _INI in SSDT-7.dsl: Method (_INI, 0, NotSerialized) // _INI: Initialize { 03D1: 14 1F 5F 49 4E 49 00 // .._INI. Store (Zero, \\_SB.PCI0.RP05.PEGP._ADR) } 03D8: 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 // p.\\/._SB_PCI0RP0 03E8: 35 50 45 47 50 5F 41 44 52 // 5PEGP_ADR ​Resulting patch…12Find: &lt;5F 49 4E 49 00 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 35 50 45 47 50&gt;Replace: &lt;58 49 4E 49 00 70 00 5C 2F 05 5F 53 42 5F 50 43 49 30 52 50 30 35 50 45 47 50&gt;And the _OFF in SSDT-8.dsl: Method (_OFF, 0, Serialized) // _OFF: Power Off { 032B: 14 45 04 5F 4F 46 46 08 // .E._OFF. If (LEqual (CTXT, Zero)) { \\_SB.PCI0.LPCB.EC0.SPIN (0x96, Zero) 0333: A0 39 93 43 54 58 54 00 5C 2F 05 5F 53 42 5F 50 // .9.CTXT.\\/._SB_P 0343: 43 49 30 4C 50 43 42 45 43 30 5F 53 50 49 4E 0A // CI0LPCBEC0_SPIN. 0353: 96 00 The patch…12Find: &lt;5F 4F 46 46 08 A0 39 93 43 54 58 54&gt;Replace: &lt;58 4F 46 46 08 A0 39 93 43 54 58 54&gt;Note: Each of these patches could probably be reduced, but you would need to check carefully in all native DSDT and SSDTs for the Find pattern as you don’t want to match on any methods but the target methods. Because _REG, _INI and _OFF are very common names for methods in other scopes, we need to be careful.A simple exampleThe files for the ASUS mentioned above were complex due to the need to patch _OFF, _INI, and _REG.But let’s take a look at an example that is much simpler. The files are for an Asus K550VX-DM406T, and they are attached to this post. Please download them so you can follow along.When we look at the _OFF method in SSDT-14, there is no EC related code. And it calls PGOF, but the PGOF method, defined in SSDT-3, also has no EC related code:Method (_OFF, 0, Serialized) // _OFF: Power Off { If (LEqual (CTXT, Zero)) { If (LNotEqual (GPRF, One)) { Store (VGAR, VGAB) } Store (One, CTXT) } PGOF (Zero) } This means _OFF can be called directly from an _INI.If you look at all the _INI methods in the ACPI set, you will find there is no _INI at the path of _OFF (_SB.PCI0.PEG0.PEGP). Which means we can simply add an SSDT that has an _INI at the correct path, and that _INI simply calls _OFF.It is a one-liner method:12345DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _OFF() &#125;&#125;Just as mentioned in the main discrete disable guide (static patch), sometimes you need to call _PS3 instead of _OFF. It is a trial and error process to determine which is best.Same code as above, but calling _PS3:12345DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._PS3, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _PS3() &#125;&#125;Save it as SSDT-DGPU.aml and the Nvidia should be disabled.The simple example turned not so simpleAlthough the method mentioned above will usually work in this scenario (even with other laptops that present the same scenario: no EC access in _OFF path, no existing _INI at the path), this specific laptop needed additional patching in order to turn off the dedicated Nvidia fan.A little investigation was needed. As we can see by looking at the _OFF code, it calls PGOF(Zero) to do most of the work. And if we search for other examples of PGOF being called with Arg0==Zero, we find this code in SSDT-3.dsl:ElseIf (LAnd (LGreater (OSYS, 0x07D9), PEGS ())) { FAOF () PGOF (Zero) ... Note the call to FAOF. Could that be for “FAN OFF”? Seems likely.And look, we have FAOF and FAON in SSDT-3:Method (FAON, 0, Serialized) { \\_SB.PCI0.LPCB.EC0.WRAM (0x052B, 0x9E) \\_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x8B) Store (\\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) Or (Local0, 0x20, Local0) \\_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) } Method (FAOF, 0, Serialized) { Store (\\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) \\_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) \\_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x89) \\_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) \\_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) } And you can see it does a bunch of EC manipulations. Typically the EC controls the system fans, so this seems to confirm these methods are for “FAN ON”, and “FAN OFF”.Since these methods manipulate the EC, we cannot call FAOF without the EC being ready. To do that, we need to patch _REG.So, adding the necessary code to our SSDT:1234567891011121314151617181920DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DGPU&quot;, 0)&#123; External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj) Method(_SB.PCI0.PEG0.PEGP._INI) &#123; _OFF() &#125; External(_SB.PCI0.LPCB.EC0, DeviceObj) External(_SB.PCI0.LPCB.EC0.XREG, MethodObj) External(_SB.PCI0.PEG0.FAOF, MethodObj) Scope(_SB.PCI0.LPCB.EC0) &#123; OperationRegion(RME3, EmbeddedControl, 0x00, 0xFF) Method(_REG, 2) &#123; XREG(Arg0, Arg1) // call original _REG, now renamed XREG If (3 == Arg0 &amp;&amp; 1 == Arg1) // EC ready? &#123; \\_SB.PCI0.PEG0.FAOF() // turn dedicated Nvidia fan off &#125; &#125; &#125;&#125;And the patch we need to rename _REG to XREG (again, based on a mixed listing of DSDT.aml):12Find: &lt;5F 52 45 47 02 A0 0B 93 68 0A 03&gt;Replace: &lt;58 52 45 47 02 A0 0B 93 68 0A 03&gt;With the patch in config.plist, EC0._REG is renamed XREG. The eventual call to _REG by the system lands in our modified _REG, which, in turn, calls the original _REG (renamed to XREG) and calls FAOF to turn the fan off.ConclusionHotpatching discrete GPU disable code is a bit simpler than battery status, but involves similar concepts.Creditshttps://github.com/RehabMan/OS-X-Clover-Laptop-Confighttps://www.tonymacx86.com/threads/guide-using-clover-to-hotpatch-acpi.200137/","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"SSDT","slug":"SSDT","permalink":"https://iamzhl.top/tags/SSDT/"},{"name":"hotpatch","slug":"hotpatch","permalink":"https://iamzhl.top/tags/hotpatch/"},{"name":"ACPI","slug":"ACPI","permalink":"https://iamzhl.top/tags/ACPI/"}]},{"title":"ASUS-X455LD-i5-4210u","slug":"ASUS-X455LD-i5-4210u","date":"2017-12-13T06:51:34.000Z","updated":"2019-03-11T16:21:49.881Z","comments":true,"path":"ASUS-X455LD-i5-4210u.html","link":"","permalink":"https://iamzhl.top/ASUS-X455LD-i5-4210u.html","excerpt":"Install macOS High Sierra on ASUS X455LD i5 4210u","text":"Install macOS High Sierra on ASUS X455LD i5 4210uLaptop Configuration123456789101112131415161718Computer model Asus F455LD NotebookCPU Intel Core i5-4210uOperate System Windows10 Education 64bit + macOS High Sierra 17B25c + Windows7 Ultimate + ElementaryOS base on Ubuntu 16.04Main board Asus X455LD Intel Haswell-ULT - Lynx Point-LPDiscret egraphics Nvidia GeForce 820M 2G Integrated graphics HD4400Audio Realtek @ Intel Lynx Point-LP High Definition Audio (CX20751)Ethernet Realtek RTL8168/8111/8112 Gigabit Ethernet Controller / AsusWireless network adapter Atheros AR956XWorkingNotesAbout ALCPlugFixFirstly，Unzip ALCPlugFix to your desktop after you have installed Hackintosh。Secondly，open terminal：123$ cd ~/Desktop/ALCPlugFix/alc_fix$ chmod +x install.sh$ ./install.shThe script can fix your audio with good input and switch。About 一键开启HIDPI并注入EDIDJust double click 双击.command，and input your password。Then it can working as Macintosh。Clover EFI bootloaderASUS-F455LD-i5-4210uFinallyPlease respect the author’s work and please indicate the address of the original post if you want reprint the repo!","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"X455LD","slug":"X455LD","permalink":"https://iamzhl.top/tags/X455LD/"}]},{"title":"回溯法求子集和问题","slug":"Solve-problem-of-subset-sum-with-backtracking-method","date":"2017-12-12T06:12:40.000Z","updated":"2019-03-11T16:21:49.901Z","comments":true,"path":"Solve-problem-of-subset-sum-with-backtracking-method.html","link":"","permalink":"https://iamzhl.top/Solve-problem-of-subset-sum-with-backtracking-method.html","excerpt":"","text":"问题描述子集和问题的一个实例为&lt;S,t&gt;。其中，S={x1,x2,x3,&hellip;,xn}是一个正整数的集合，c是一个正整数。子集和问题判定是否存在S的一个子集S1，使得 S1中的所有元素之和等于c。试设计一个解子集和问题的回溯法。输入第1行有2个正整数n和c，n表示S的大小，c是子集和的目标值。接下来的1行中，有n个正整数，表示集合S中的元素。输出输出子集和问题的解。当问题无解时，输出No solution!。样例输入125 102 2 6 5 4样例输出12 2 6代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// main.c// subset-sum//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include &lt;stdio.h&gt;#define n 5#define c 10int array[n]=&#123;2,2,6,5,4&#125;;int a[n]=&#123;0&#125;;int sum=0;int flag=0;void traceback(int t)&#123; if(t==n)&#123; if(sum==c)&#123; flag=1; for(int i=0;i&lt;n;i++)&#123; if(a[i])&#123; printf(\"%3d\",array[i]); &#125; &#125; printf(\"\\n\"); return; &#125; &#125; else&#123; sum+=array[t]; a[t]=1; traceback(t+1); a[t]=0; sum-=array[t]; traceback(t+1); &#125;&#125;int main()&#123; traceback(0); if(!flag)&#123; printf(\"No Solutions!\\n\"); &#125; return 0;&#125;结果输出","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"子集和问题","slug":"子集和问题","permalink":"https://iamzhl.top/tags/子集和问题/"},{"name":"回溯","slug":"回溯","permalink":"https://iamzhl.top/tags/回溯/"}]},{"title":"笔记本原版黑苹果安装教程","slug":"Install-macOS-on-laptop","date":"2017-12-11T16:28:15.000Z","updated":"2019-03-11T16:21:49.894Z","comments":true,"path":"Install-macOS-on-laptop.html","link":"","permalink":"https://iamzhl.top/Install-macOS-on-laptop.html","excerpt":"","text":"前言Clover支持两种启动方式，启动过程如下：基于BIOS的电脑（老式主板）BIOS -&gt; MBR -&gt; PBR -&gt; boot -&gt; CLOVERX64.efi -&gt; OSLoader基于UEFI的电脑（新式主板）UEFI -&gt; CLOVERX64.efi -&gt; OSLoader对于支持UEFI的机器，我们通常用CLOVER引导原版安装，这种方式最大的优点就是有恢复分区可以正常升级，当然前提要把引导做好。前期知识储备CLOVER的目录结构CLOVER正常工作需要的完整目录包括config.plist、CLOVERX64.efi两个文件以及ACPI、drivers64UEFI、kexts、和themes几个目录，如图所示：其中，config.plist是最核心的文件—-配置文件，CLOVER所实现的多数功能都是通过这个文件进行配置的，对其进行配置修改的最好用的工具就是Clover Configurator，主页面如下：详细的配置方法下面会有介绍。另外一个文件是CLOVERX64.efi，这个文件用以启动CLOVER引导，通过EasyUEFI或者BIOS对启动项进行添加操作时，就是指向的这个文件。ACPI是用以存放机器ACPI表单的，全称是”高级配置和电源管理接口”(Advanced Configuration and Power Interface)，其子目录由origin、patched、WINDOWS构成，其中origin用以保存通过在CLOVER引导界面按F4或Fn F4提取的原始表单，此目录的所有表文件是不加载的，需要对其进行编译得到.dsl文件，然后对其进行修改拍错，最后保存成.aml文件保存至patched目录才会在启动时加载，而WINDOWS目录则可以忽略不计。在黑果中，我们用到的表单文件只有SSDT和DSDT，其中DSDT主要是对各种设备的描述，而SSDT则主要是用以实现某个功能。drivers64UEFI是由各种EFI驱动组成，在笔记本黑果需要用到的有FSInject-64.efi、HFSPlus-64.efi、OsxAptioFixDrv-64.efi、APFS.efi以及OsxFatBinaryDrv-64.efi，在新版CLOVER中只需要FSInject-64.efi、HFSPlus-64.efi、OsxAptioFixDrv-64.efi、以及APFS.efikexts主要用于存储各种驱动(OS X称为内核扩展)themes用以存储CLOVER引导界面的主题根据机器配置定制kextkext在EFI的配置中是相当重要的，好的kext配置可以弥补config的不足，不好的kext配置也会让本应完美的config发挥不出作用。FakeSMC.kext:FakeSMC是现今的⿊黑苹果过程中唯⼀一的”必要性”内核扩展程序。对于⿊黑苹果有着⽆与伦比的重要性，但是很多⼈并不知道FakeSMC为什么重要，只是知道必须有它才⾏行，。简⽽而⾔言之就是: FakeSMC是⽤用于将PC主板上的各种控制芯⽚片伪装成Mac独有的硬件控制芯片SMC以骗过系统从⽽而是系统正常启动的⼀一个内核扩展(其实很复杂,这⾥里不多说了)。在系统启动的阶段，FakeSMC负责告知系统有关主板上SMC芯⽚片(伪装出来的)的各种加密信息，欺骗系统。也就是说呢，无论你笔记本是什么配置，此驱动是必须的。ApplePS2SmartTouchPad.kext、VoodooI2C.kext和VoodooPS2Controller.kext:此驱动用以驱动键盘鼠标以及触摸板，两者选择一个即可，两者区别就是适用的类型不一样，有PS/2、Synaptics、alps、i2c等等，其中Synaptics、alps用ApplePS2SmartTouchPad.kext适配性好一些，VoodooI2C.kext比较麻烦，仅适用于i2c触摸板。具体怎么确定走的总线类型，大家参考百度就好了，这里就不再赘述。FakePCIID.kext:这个kext的目的是与IOPCIDevice设备建立连接，以便当另一个驱动程序连接到同一设备时，它可以提供备用的PCI ID。也就是说，如果用到Fake-PCI-ID中的其他任何kext的话，此驱动都是必要的。FakePCIID_Intel_HD_Graphics.kext:此驱动主要用于核显HD4200 HD4400 HD4600 P4600、Iris 540 Iris 550 Iris Pro 580、HD510 HD515 HD520 HD530 P530（多数530不需要这个）、P4000、P6300 - 162a、UHD620 KabyLake-R、UHD630 CoffeeLake。FakePCIID_Intel_HDMI_Audio.kext:其目的是为不支持的HDAU提供支持(通常称为B0D3，但需要将其重命名为HDAU，以满足Apple的期望值)在Haswell以上的系统中提供HDMI-audio的设备。FakePCIID_BCM57XX_as_BCM57765.kext:这个kext将与众多不受支持的BCM57XX以太网设备建立连接，以使本机驱动程序为兼容的更广泛的BCM以太网芯片组工作。FakePCIID_Intel_GbX.kext:这个kext将与一些Intel以太网设备建立连接，以使基于Intel芯片组的驱动程序工作。FakePCIID_XHCIMux.kext:将会连接到8086:1e31, 8086:9c31, 8086:9cb1, 8086:9c31, 8086:8cb1这个注入器是正常的FakePCIID任务的一部分。它实际上并没有伪造任何PCI id。相反，它将某些值强加于Intel XHCI USB3控制器上的XUSB2PR (PCI配置偏移0xD0)。其效果是将任何USB2设备与XHC端口上的USB2引脚连接到EHC1。换句话说，使用USB2驱动而不是USB3驱动程序(AppleUSBEHCI vs AppleUSBXHCI)处理USB2设备。FakePCIID_AR9280_as_AR946x:这是FakePCIID.kext的特殊应用，是在一个AR9280被重新命名为其他设备的情况下使用的。例如，在联想u430中，将一个AR9280作为AR946x重新命名是很有用的，因为该设备可以被BIOS白名单所允许，而AR9280不是。通过使用FakePCIID，我们可以将PCI id重新映射回AR9280 (168c:002a)，即使该设备本身报告的是168c:0034。FakePCIID_Broadcom_WiFi.kext:这个kext将连接到14e4:43b1, 14e4:4357, 14e4:4331, 14e4:4353, 14e4:432b, 14e4 . 432b, 14e4:43a3，或14e4:43a0。以及106b:4e, 14e4:4312, 14e4:4313, 14e4:4318, 14e4:431a, 14e4:4320, 14e4:4324, 14e4:4324, 14e4:4328, 14e4:432d。最初是为BCM94352Z创建的，这个特殊的FakePCIID应用程序。在使用多种支持的Broadcom WiFi设备时，kext被用来模拟真正的Apple Airport(苹果无线网卡)。ACPIBatteryManager.kext:用以使笔记本正确显示电量，但通常需要配合DSDT的patch才能发挥作用。VoodooHDA.kext:万能声卡驱动，用以禁用AppleHDA来驱动声卡。AppleALC.kext:通过对AppleHDA的动态patch实现对AppleHDA的完整加载。Lilu.kext:一个开放源码的内核扩展，为macOS系统提供了一个任意的kext、库和程序补丁的平台。IntelGraphicsDVMTFixup.kext:修复因BIOS显存分配不足造成的KP。建议broadwell+平台使用。IntelGraphicsFixup.kext:动态修复核显的各种问题(例如腾讯视频死机，开机二阶段花屏等)，建议Haswell+平台使用。CoreDisplayFixup.kext:为不受支持的4K机器(非Iris)开启高分辨率支持。AzulPatcher4600.kext:针对HD4600的额外修复，仅推荐HD4600使用。HibernationFixup.kext:修复睡眠，以支持某些机器在3和28休眠模式下的正常休眠。NvidiaGraphicsFixup.kext:修复某些n卡的黑屏。WhateverGreen.kext:用以驱动A卡。RealtekRTL8111.kext:用以驱动RealtekRTL8111.kext以太网卡设备。AppleIGB.kext、IntelMausiEthernet.kext:用以驱动Intel板载网卡设备。根据机器配置定制configClover 可以根据硬件进行自动配置，但是自动配置组件并不总是完美的。这也是保留用户可以自定义配置的原因。用户可以修改配置文件config.plist中的配置参数，或者基于GUI的配置界面进行修改配置。配置文件是基于XML的，可以以文本文件来处理。它可以用纯文本编辑器进行编辑，也可以用plist编辑器进行编辑，如PlistEdit。配置文件 (config.plist) 必须放在EFI/CLOVER目录下。这里遵循一个原则，尽可能简单的设置config，不知道具体作用的就让他空着好了，如果你不知道参数的需求值是什么，就从配置文件中排除！不要用没有值的参数。正所谓前人种树，后人乘凉，很多黑果的热心朋友已经为我们做好了教程，这里我直接拿来用了。ACPI-1ACPI-2BOOTCPUDeviceDisable DriversGUIGraphicsKernel and Kext PatchesRt VariablesSMBIOSSystem Parameters不敢下手的没关系，我给一个最简单的模板，全按这个来就足可以装上最常见的。敢下手了，没有Mac环境？没关系，送你们在线编辑器，点这里传送门。里面目前加入了一些常见的配置，帮你完成一部分工作。了解drivers64UEFI各个.EFI文件的作用，精简引导BIOS启动过程中要用到drivers32或drivers64目录，UEFI启动过程中则使用drivers64UEFI目录。它们的内容会根据配置和BIOS版本而有所不同。必须要提的一点是这些驱动程序只在bootloader运行时有效，不会影响最终启动的操作系统。至于到底要使用哪些驱动程序由用户来决定。NTFS.efiNTFS文件系统驱动程序。用于启动Windows EFI系统。HFSPlus.efiHFS+文件系统驱动程序。这个驱动对于10.13之前的系统版本来启动Mac OS X是必须的。APFS.efiAPFS文件系统驱动程序。这个驱动对于在10.13的系统版本通过APFS装的黑果来启动Mac OS X是必须的。VBoxHFS.efiHFSPlus.efi的替代品，性能要差一点。VBoxExt2.efiEXT2/3文件系统驱动。用于启动Linux EFI系统。VBoxExt4.efiEXT4文件系统驱动。用于启动Linux EFI系统。FSInject.efi控制文件系统注入kext到系统的可能性。PartitionDxe.efi已经存在于在CloverEFI和UEFI中，但没有为Apple分区优化，也没有为GPT/MBR优化。OsxFatBinaryDrv.efi允许加载FAT模块比如boot.efi。OsxAptioFixDrv.efi修复AMI Aptio EFI内存映射。如果没有就不能启动OS X。OswLowMemFix.efi是OsxAptioFixDrv的简化版。两个不能同时使用。DataHubDxe.efi已经存在于在CloverUEFI中。建议还是使用它，不会产生冲突。CsmVideoDxe.efi比UEFI里提供更多分辨率的显卡驱动。看了这么多，千万不要崩溃，我告诉大家一个经验，一般Drivers64UEFI目录只需要下面几个.EFI驱动就够了。)进攻ACPI，完美黑苹果(进阶篇)论坛贡献会员daxuexinsheng已经翻译了RehabMan的DSDT教程，可以说是非常详细，可以直接参考:使用补丁修改DSDT/SSDT，以及RehabMan的原贴。如果你喜欢hotpatch，可以参考我的翻译帖Clover-ACPI-hotpatch，不过由于我太懒还没翻译完哈哈。当然还是推荐RehabMan的原贴。准备工作集成CLOVER的原版镜像链接:https://pan.baidu.com/s/1gfTmRj9 密码:s3dvTransmac链接:https://pan.baidu.com/s/1oAn79Zc 密码:yafneasyUEFI链接:https://pan.baidu.com/s/1nwqbnMp 密码:gxocClover Configurator四叶草助手链接:https://pan.baidu.com/s/1ht2wFQW 密码:tbceDiskGenius链接:https://pan.baidu.com/s/1cVyULo 密码:pfrm鲁大师/AIDA64(推荐)/也可以用设备管理器自行度娘安装步骤利用Transmac将原版镜像写入u盘打开TransMac,右键选择欲制作的USB盘符，选择Restore with Disk Image,选择下载好的dmg文件,会弹出窗口,提示将要格式化USB磁盘,点击OK按钮继续，耐心等待写盘的完成。写入完成，若弹出对话框提示将其格式化，点击取消。利用鲁大师等软件查看自己机器的配置信息，来定制config和需要用的kext这一步想必不用我多说，大家利用鲁大师或者AIDA64看一下自己配置好了。有一点提示，尽量在安装过程中不考虑各种kext，尽量用少的驱动去安装，安装完成后再完善驱动，这样可以减少许多安装中的错误，也利于排错，但需要注意的必备的驱动一定要放，例如FakeSMC.kext、还有就是键盘驱动。当然老鸟无所谓了，直接把需要用到的都放上就OK了。以我自己机器为例，配置如下：1234567891011主板 Asus X455LD Intel Haswell-ULT - Lynx Point-LP独立显卡 Nvidia GeForce 820M 2G 核心显卡 HD4400声卡 Realtek @ Intel Lynx Point-LP High Definition Audio (CX20751)以太网卡 Realtek RTL8168/8111/8112 Gigabit Ethernet Controller / Asus无线网卡 Atheros AR956X按照上面的驱动简要说明，我以太网卡是RTL8111，那么需要RTL8111.kext、核心显卡是HD4400，就需要FakePCIID.kext、FakePCIID_Intel_HD_Graphics.kext，声卡比较麻烦，暂时不考虑，无线网卡是Atheros AR956X，那么我需要ATH9KFixup.kext，又要依赖Lilu.kext，所以需要Lilu.kext，四代低压机器，我需要IntelGraphicsFixup.kext来解决腾讯视频死机的问题，所以放上这个。暂时只考虑这些驱动吧，下面就进入安装阶段。重启利用U盘启动选择安装盘开机按esc键进入启动项列表，不同厂商热键不同，参考下图：选择U盘进入，这里就不介绍太多了，大家玩黑果的想必对BIOS不会陌生，不过需要注意的是需要将BIOS中的安全启动关掉。接下来就会进入CLOVER引导界面通过键盘方向键选中Boot OS X Install from ***，***代表你的镜像名字，然后回车。等待进入安装界面。这里选择自己擅长的语言好啦。磁盘工具分区选择磁盘工具，并继续选择显示所有设备选择SSD Media,点击抹掉按钮,选择默认的Mac OS扩展(日志型)，在10.13中如果装在SSD上，也可以选择APFS,将名称修改为Macintosh HD（名字随意啦，自己喜欢就好，但要是英文）,点击抹掉按钮，抹掉完成后，点击完成按钮。然后退出磁盘工具，到这里，磁盘工具的动作就已经结束了。退出磁盘工具，选择安装macos选中刚才抹掉的分区开始安装选择安装macOS，并继续接下来按照提示一步一步来就好了，有一步需要注意的就是选择安装分区时，选择自己之前抹掉的那个分区。接下来静静等待，会有一次自动重启，依然用U盘启动，注意这次会在引导界面多出一个图标，选择除第一次选的图标外的另一个图标。然后继续等待系统安装完成后,重启进入系统设置向导，接下来根据下面的图一步一步设置就好了这里选择现在不传输任何信息这里注意，一定不要选择加密！！！转移CLOVER到硬盘ESP，摆脱U盘引导这里用到前期准备的EasyUEFI，在Windows下安装打开此软件，添加CLOVER启动项，并置顶。具体操作参考：黑苹果安装从0开始—-clover优盘引导改硬盘引导篇后期的驱动安装以及优化屏蔽无用的独显降低温度参考我之前的帖子：Disable the discrete GPU in laptop摆脱万能声卡，利用AppleALC加载原生声卡参考我之前的帖子：Driver-audio-for-hackintosh还有这个帖子：自己动手用上AppleALC，使用原生AppleHDA通过对DSDT打补丁完善电池显示参考pcbetadaxuexinsheng的帖子tonymacx86RehabMan的帖子加载x86实现变频和原生电源管理，完善节能器信息对于Haswell以及Broadwell平台，利用ssdtPRGen生成SSDT，在config中drop掉CpuPm和Cpu0Ist两个表，并利用FakeSMC或DSDT或hotpatch加载AppleLPC对于Skylake及以上平台，选择支持HWP的合适的机型，并勾选HWPEnable。注入HiDPI和显示器信息完善唤醒后的花屏、闪屏、撕裂屏问题参考：macOS Sierra 10.12下 开启HiDPI 傻瓜式开启教程写在最后本帖多处引用现成帖子，只是将整个流程做个陈述，意在整理思路，以便大家更好地理解实践。本人水平有限，帖子中的不正确之处希望大家积极批评指出，一起完善。楼主真的是懒到蜕皮(手动滑稽哈哈)帖子中图片很多是出自黑果小兵的博客：macOS安装教程兼小米Pro安装过程记录。感谢各位黑果前辈的好帖子，引用太多，文中也有说明，就不一一列出了。待续……","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"}]},{"title":"利用 AppleALC 驱动声卡","slug":"Driver-audio-for-hackintosh","date":"2017-11-05T16:00:00.000Z","updated":"2019-03-11T16:21:49.889Z","comments":true,"path":"Driver-audio-for-hackintosh.html","link":"","permalink":"https://iamzhl.top/Driver-audio-for-hackintosh.html","excerpt":"","text":"前言在vit9696推出AppleALC后，经过越来越多人仿冒声卡得到的数据的提交整理，AppleALC的数据越来越集中，也使声卡驱动变得越来越简单。本文提供使用AppleALC驱动声卡的思路以及常见错误和驱动后的问题进行修复。前期准备需要下载Xcode在AppleStore下载下载AppleALC通过终端执行下面的命令，会下载到你的用户根目录1$ git clone https://github.com/vit9696/AppleALC下载Lilu在下面的网址下载DEBUG和RELEASE1https://github.com/vit9696/Lilu/releases提取Codec这一步需要用到Linux环境，首先下载Ubuntu镜像，我个人提供一个1链接:http://pan.baidu.com/s/1i47I0jN 密码:de4v当然也可以去官网下载，下载好镜像之后，将U盘格式化为Fat32，然后将镜像解压到U盘，重启以U盘启动，选择试用进入Ubuntu系统界面，打开终端输入1$ cat /proc/asound/card0/codec#0 &gt; ~/Desktop/Codec.txt执行完后会将Codec.txt提取到桌面，将其保存到U盘PS: 一般来说提取的Codec会有10k左右大小，如果大小不够，很有可能提取错误，可以尝试以下命令1$ cat /proc/asound/card0/codec#1 &gt; ~/Desktop/Codec.txt或者1$ cat /proc/asound/card0/codec#2 &gt; ~/Desktop/Codec.txt或者1$ cat /proc/asound/card1/codec#0 &gt; ~/Desktop/Codec.txtCodec.txt的数据整理记录Address和Vendor Id值Codec.txt开头部分提取节点信息搜索Pin Default记录Node和节点描述，以我的为例PS: N/A节点无效无需整理记录HP Out at Ext Left节点的tag和enable值PS: Unsolicited Response的设定是为了解决耳机和外放切换的问题。需设定 HP Out at Ext 所在的节点，并且节点信息中有Unsolicited: tag=xx, enabled=1 这一行。设定命令为Address+NodeID+708+&lt;设定值&gt;设定值是8位的一个二进制数，记作a7 a6 a5 a4 a3 a2 a1 a0，推算出此二进制数之后，四四拆分转换为2位的十进制数加1即为此设定值a7表示enabled。a6=0，没具体应用，不用管。a5~a0，存放tag。**记录Mic at Ext节点的Pin-ctls值PS: Pin Control Widget的设定是为了解决耳机杂音的。需要设定的是 Mic at Ext 所在的节点，设定的值可以从codec dump中读取。设定命令是 Address+NodeID+707+Pin-ctls值。整理完后，会得到如下所示的数据集合PS: 常见的节点设备描述如下：Mic at Ext–线路输入(耳麦)Mic at In–内建输入HP Out–耳机扬声器Speaker–内建扬声器(外放)至此，Codec 数据的整理到此结束AppleALC中数据的筛选依次打开下载的AppleALC源码里面/AppleALC/Resources/PinConfigs.kext/Contents下的Info.plist搜索之前记录的CodecID记录搜索到的所有的ID中的configdata，如下整理每一行的每一串的第一个字符代表Address值每一行的第三串倒数第二个字符代表这个节点的设备描述，具体对应关系如下根据上图设备对应关系和Address值排除掉无效的ID数据开工将下载的Debug的Lilu.kext放进 AppleALC 源码根目录；删除/AppleALC/Resources中多余文件夹，只留下你的声卡型号文件夹、Pinconfigs.kext以及四个plist文件，以cx20751这个声卡为例剩下如下文件然后打开计算器，显示为编程器打开你整理的Codec，找到Vendor Id，拷贝后面的字符串，在计算器选中十六进制，粘贴这个字符串然后选中十进制，就换转换成十进制形式拷贝这个十进制数，打开/AppleALC/Resources/CX20751_2/Info.plist(此处的CX20751_2需要换成你的声卡型号)，把codecid换成刚才拷贝的十进制数保存退出，右键PinConfigs.kext显示包内容，打开里面的Info.plist，搜索刚才拷贝的十进制数，记下LayoutID数据，有几个记几个，都记下来，然后将IOKitPersonalities-&gt;HDA Hardware Config Resource-&gt;HDAConfigDefault中的其他型号删除，(为避免出错，这里的删除可以不操作，删除只是为了精简做出来的AppleALC)，保存退出。然后双击打开 AppleALC 中的工程文件：按图示操作点击右面的Distribute ContentnextExport As填上桌面，点export就生成AppleALC在桌面上了，一层一层打开它，将其中的AppleALC.kext放到clover驱动目录，注意之前下载的Release的Lilu也要放到clover驱动目录，最后不要忘了注入LayoutID：如果重启后你的声卡不能驱动，或者已驱动但是没有输入或输出，这时很有可能是该LayoutID对应的configdata数据有错误，这时就挨个尝试刚才记录的所有ID。至此， AppleALC 驱动声卡部分结束。关于解决耳机与内建输入的切换如果驱动工作完成后，声卡可以工作，但不能自动切换，请接着往下看打开终端，输入1git clone https://github.com/goodwin/ALCPlugFix回车就将ALCPlugFix下载到了你的用户目录，打开此目录中的ALCPlugFix中的main.m下拉到最下方，注意这一部分：下载CodecCommander12345$ git clone https://github.com/athlonreg/ALCPlugFix.git$ git clone https://github.com/RehabMan/EAPD-Codec-Commander.git$ cp ALCPlugFix/alc_fix/hda-verb /usr/local/bin/$ cd EAPD-Codec-Commander$ ./widget_dump.sh回车找到nid = 0x19和nid = 0x1a，这里我的19为 line in，1a为mic in，记录下最后两位，我的是04和24就这么改PS: 这里需要设定的节点数据分别是line in和mic in，其他节点无效，思想就是捕获系统在不插耳机时由于其输入输出正常的这两个节点的输出值，然后就可以知道插耳机正常应该输出的值，进而利用AppleALC守护进程动态守护。如果出现插耳机正常，不插无效的情况，请按照这个思路反过来操作，思想都是一样的。其中图上的高亮处最上面一部分是默认情况，中间是耳机移除，最下面是耳机插入，请结合自身使用情况合理设定保存退出，双击按照AppleALC的编译方法编译这个然后将生成的ALCPlugFix替换alc_fix中的ALCPlugFix，终端cd到alc_fix目录，执行1$ ./install.sh耳机就可以自动切换了，三节点的朋友运气好的话杂音应该也解决了，这时插入耳机在执行1$ ./widget_dump.sh就可以发现之前的19和1a后面的数据反过来了(我这里是修复好的，就不再演示了。。。)其实这里的数据就是侦测耳机插拔状态，向系统发送相关指令来做到切换正常需要设定的就是两个节点Mic at Ext(有时是Line In)和Mic at InMic at Ext(有时是Line In)表示线路输入，即耳麦，多为0x19节点Mic at In为内建输入如果不行重启一次应该就好了。至此，解决耳机与内建输入的切换部分结束。关于唤醒无声可以先尝试下面两个驱动CodecCommanderEAPDFix 提取密码:w4yrPS: 关于CodecCommander，可以点击这里参考RehabMan的说明另外四叶草助手中也提供了相关选项(ResetHDA和dartweak)，但是本人没有亲自尝试，大家可以自行尝试这些组合：本人对唤醒无声研究不多，至此，解决耳机与内建输入的切换部分结束，欢迎补充。关于万能声卡很多人不喜欢万能声卡，说万能有杂音(但是有一些人的AppleALC也可能有杂音)，甚至说用万能声卡是不完美的表现，其实我认为不然，万能是一种很好的渠道，有不少人用万能声卡，他们的切换、输入甚至HDMI都能很好的输出，而且杂音也是可以减小的。这里我给出官方的项目地址，有兴趣的可以试一下https://sourceforge.net/projects/voodoohda/PS: 需要注意的是有人用的是VoodooHDA.pkg安装的，这种情况需要将AppleHDADisabler.kext放到Clover的驱动目录来禁用AppleHDA，否则很有可能会造成KP五果，所以我建议直接用kext，让Clover注入器注入即可。关于完整仿冒前言声卡型号众多，虽然AppleALC让数据更集中了，但还是有些声卡不在目前的AppleALC支持的列表里面，对于这种情况来说，我们只能完整制作仿冒声卡。接下来以我的CX20751为例简述仿冒声卡制作过程。完整制作仿冒声卡思路整理Codec，提取所有有效Node值将整理出的所有Node的Pin Default值进行转换得出需要的值根据某些规律或者规则得出ConfigDataPathMap的获取和整理知识普及每一个Node的ConfigData值都是由四个八位的字符串组成，这四个串的最后两位分别是一个八位的设定值的1 2、3 4、5 6、7 8位，这四个八位的字符串的设定规则分别是是Address+Node+71C+1 2位设定值、Address+Node+71D+3 4位设定值、Address+Node+71E+5 6位设定值、Address+Node+71F+7 8位设定值。这里需要注意，有两个不同的八位被提及，其中一个八位(这八位每一位都有特定的含义，也是仿冒成功最关键的地方，在后面我称之为设定值)是被均分四份从而放到ConfigData的各个节点所对应的四个串的七八位而这个八位的设定值每一位的含义如下：第一位：代表节点设定值(Address)，一般不需要改变；第二位：同组装置的优先顺序，一般为 0~3，不可出现字母；第三位：插口颜色，笔记本忽略，不作处理；第四位：插孔侦测，0为开启(外设基本为0)，1为关闭(内建基本为1)；第五位：装置类型，笔记本忽略；第六位：连接类型，圆口为1，内接为0，基本可以忽略；第七位：代表是否有插孔及插孔位置0=外接，9=内建，耳机扬声器和耳麦均为外接；第八位：代表插孔所在位置，0=内建，1=外接；开始整理Codec，提取所有有效Node值与上面利用AppleALC的思路不同，这里我们需要提取的数据有设备描述、Node值和Pin Default值。具体提取方法上文已有说明，这里不再赘述，下面是我的CX20751提取的数据：将整理出的所有Node的Pin Default值进行转换修正得出需要的设定值对于Pin Default值，我们的处理方法为八位四分、二二逆置，例如0x16节点，首先得出40 10 21 03，同理得出：12340x16: 40 10 21 030x17: 10 01 17 900x19: 30 10 A1 030x1a: 20 01 A7 95根据八位设定值的规则描述，对上面得出的设定值进行修正。拿0x16为例，这是一个耳机扬声器节点。第1、2、3位没什么好说的保持不变；第4位插孔侦测，耳机设备属于外接设备，所以应当是0，这里是0不用动；第5位装置类型笔记本忽略；第6位连接类型，插口为圆口，所以是1，这里是1，保持不变；第7位代表是否有插孔，耳机是外接设备，所以是0，这里是0，保持不变；第8位插孔所在位置，耳机是外接设备，所以是1；其他Node节点也是如此设定；修正后的数据如下：12340x16: 40 10 21 010x17: 10 01 17 900x19: 30 10 81 010x1a: 20 01 A0 90根据规律或者规则得出ConfigData根据上面得出的设定值，我可以得出以下ConfigData值：123401671C40 01671D10 01671E21 01671F0101771C10 01771D01 01771E17 01771F9001971C30 01971D10 01971E81 01971F0101a71C20 01a71D01 01a71EA0 01a71F90PS: 搜索一下codec里面有没有EAPD这个字符串，有的话就在ConfigData的最后面加上一串01470C02这组数字。PathMap的获取和整理在声卡仿冒的过程中这一步是最麻烦的。有几个需要注意的地方。对于声音节点来说，节点路径的推断遵循一个规律：输入是从后往前推断节点，输出是从前往后推。首先利用codecgraph得到路径图，该操作需要安装graphviz，这里我推荐利用终端npm install graphviz安装即可，然后执行下面的命令下载codecgraph1$ git clone https://github.com/athlonreg/codecgraph.git这样就下载到了你的用户根目录，将你的Codec.txt拷贝到下载的codecgraph目录下，然后12$ cd codecgraph$ ./codecgraph Codec.txt就在codecgraph目录下生成了你的声卡路径图，格式为svg，用safari即可打开，当然也可以转换为其他格式，例如我的可以看到0x16节点只连接了0x10，HP Out为输出，从前往后推，转换为十进制得到0x22 -&gt; 0x16;0x17节点只连接了0x11，Speaker为输出，从前往后推，转换为十进制得到0x23 -&gt; 0x17;0x19节点只连接了0x14，Mic at Int为输入，从后往前推，转换为十进制得到0x20 -&gt; 0x25;0x1a节点只连接了0x13，Mic at Ext为输入，从后往前推，转换为十进制得到0x19 -&gt; 0x26;整理得到路径如下：设备名称有效节点路径HP Out0x160x22-&gt;0x16Speaker Out0x170x23-&gt;0x17Mic In0x1a0x26&lt;-0x19 0x26&lt;-0x20Line In0x190x25&lt;-0x20 0x26&lt;-0x19PS: 我的声卡比较奇葩，对于多数声卡来说，输入一般为0x8 -&gt; 0x35 -&gt; 0x18，输出一般为0x33 -&gt; 0x13 -&gt; 0x3AppleHDA 修改Creditvit9696goodwinRehabManDolnordalianskyVoodooHDA写在最后码字不易，如果觉得文章不错，欢迎打赏，你们的支持是我最大的动力。","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"}]},{"title":"实现 MAC 原生读写 NTFS 分区","slug":"RW-NTFS-partition-natively-on-macOS","date":"2017-10-26T16:00:00.000Z","updated":"2019-03-11T16:21:49.899Z","comments":true,"path":"RW-NTFS-partition-natively-on-macOS.html","link":"","permalink":"https://iamzhl.top/RW-NTFS-partition-natively-on-macOS.html","excerpt":"","text":"实现 MAC 原生读写 NTFS 分区打开终端，输入命令1$ diskutil list输入命令1$ sudo vim /etc/fstab编辑内容如下1LABEL=Win\\040Ntfs\\040Drive none ntfs rw,auto,nobrowse注意**Win\\040Ntfs\\040Drive 这串字符中\\040代表空格，Win\\040Ntfs\\040Drive 这一串出现在diskutil list那个屏幕里面最后一步1$ sudo ln -s /Volumes ~/Desktop/VolumesCredit转自爱情守望者转载请注明原帖地址","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"},{"name":"NTFS","slug":"NTFS","permalink":"https://iamzhl.top/tags/NTFS/"}]},{"title":"修改 launchpad 图标布局","slug":"Change-launchpad-icon-grid-layout-in-macOS","date":"2017-10-26T01:32:26.000Z","updated":"2019-03-11T16:21:49.884Z","comments":true,"path":"Change-launchpad-icon-grid-layout-in-macOS.html","link":"","permalink":"https://iamzhl.top/Change-launchpad-icon-grid-layout-in-macOS.html","excerpt":"","text":"prefaceLaunchpad is the quick application launcher available from the Mac OS X Dock and a keystroke that looks quite a bit like the Homescreen of iOS. By default, the Launchpad app grid usually displays icons in 7 rows and 5 columns of apps, but with a little adjustment from the command line of OS X you can switch and customize the Launchpad icon grid to any number of apps you’d like to see on the Mac.This uses the command line and defaults strings to customize the Launchpad grid layout, if you’re not comfortable with Terminal you’re probably better off leaving this alone and enjoying the default Launchpad app icon grid. We’ll combine the commands into a single syntax string for ease of use first, but you can break them apart as we show you a bit further below.How to Adjust the Icon Grid Count of Launchpad in Mac OS XOpen the Terminal found in /Applications/Utilities/ and enter the following command syntax, replacing the X numbers for the appropriate columns and grid icon counts1$ defaults write com.apple.dock springboard-columns -int X;defaults write com.apple.dock springboard-rows -int X;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockIt is:$ defaults write com.apple.dock springboard-columns -int X;defaults write com.apple.dock springboard-rows -int X;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockFor example, to set the Launchpad grid to 6×7 you’d use the following syntax:1$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 6;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockIt is:$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 6;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockHit Return and wait for the Dock and Launchpad to refreshOpen Launchpad as usual to see the layout changeThe settings change is immediate after the Dock refreshes:How to return to the default settingIf you want to return to the default setting, just change the column and row counts back to what yours was originally. The default on my MacBook Pro Retina display is a 5 x 7 grid, but yours may be different depending on screen size and screen resolution.1$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 5;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockIt is:$ defaults write com.apple.dock springboard-columns -int 7;defaults write com.apple.dock springboard-rows -int 5;defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall DockThe commands for customizing the Launchpad layout can also be split apart if desired like so:Set the Launchpad Column Icon Count1$ defaults write com.apple.dock springboard-columns -int 3Set the Launchpad Row App Icon Count1$ defaults write com.apple.dock springboard-rows -int 4Reset Launchpad1$ defaults write com.apple.dock ResetLaunchPad -bool TRUE;Relaunch the Dock with killall1$ killall DockCredit:Original Source: OSXDaily","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"launchpad","slug":"launchpad","permalink":"https://iamzhl.top/tags/launchpad/"}]},{"title":"MAC 常用快捷键整理","slug":"Common-Keyboard-shortcut-in-macOS","date":"2017-10-26T00:14:21.000Z","updated":"2019-03-11T16:21:49.886Z","comments":true,"path":"Common-Keyboard-shortcut-in-macOS.html","link":"","permalink":"https://iamzhl.top/Common-Keyboard-shortcut-in-macOS.html","excerpt":"","text":"写在前面苹果 Mac 系统常用快捷键有很多，但是很多童鞋对于这些 Mac 快捷键都不是很熟悉，今天小编为大家整理了一份 Mac 系统常用快捷键大全，大家快收藏起来吧!平时在使用 Mac 系统的时候可以提高不少工作效率哦!本文转自 Xclient.info，转载请注明原出处小普及Mac中主要有四个修饰键，分别是 Command，Control，Option 和 Shift。这四个键分别有自己的图案，他们经常出现在Mac应用程序中的菜单栏里，方便你随时学习新的快捷键。如下正文通用快捷键Command 是 Mac 里最重要的修饰键，在大多数情况下相当于 Windows 下的 Ctrl，黑果通常是 Alt 键。Command + Z 撤销。Command + X 剪切。Command + C 拷贝(Copy)。Command + V 粘贴。Command + A 全选(All)。Command + S 保存(Save)。Command + F 查找(Find)。系统快捷键Option 开机后立即按下，将显示启动管理器。Command + R 开机后立即按下，可打开OS X 的恢复功能。Command + Option + P + R 开机后立即按下，重置 NVRAM。有些时候电脑会出现些小问题，重置 NVRAM 是你除了重新启动，尝试修复的第一选择。Command + Option + Control + Power 退出所有应用程序，允许你进行文稿储存，然后关机。按住 Power 按钮 5 秒 强制 Mac 关机。截图Command + Shift + 3 截取全部屏幕到文件。Command + Shift + Control + 3 截取全部屏幕到剪贴板。Command + Shift + 4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口。Command + Shift + Control + 4 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗口。文件管理器Command + Shift + N (New) 新建文件夹。Command + Shift + G (Go) 调出窗口，可输入绝对路径直达文件夹。return 这个其实不算快捷键，点击文件，按下可重命名文件。Command + O 打开所选项。在 Mac 里打开文件不像 Windows 里直接按 Enter。Command + Option + V 作用相当于Windows里的文件剪切。在其它位置上对文件复制(Command-C)，在目的位置按下这个快捷键，文件将被剪切到此位置。Command + ↑ 打开包含当前文件夹的文件夹，相当于 Windows 里的“向上”。Command + Delete 将文件移至废纸篓。Command + Shift + Delete 清倒废纸篓。Space 快速查看选中的文件，也就是预览功能。切换Command + Tab 在应用程序间切换。Command + Shift + Tab 在应用程序间切换(反向)。Command + ~ 在各应用中的窗口间切换。浏览器Command + L 光标直接跳至地址栏。Control + Tab 转向下一个标签页。Control + Shift + Tab 转向上一个标签页。Command + ‘+’或’=’ 放大页面。Command + ‘-‘ 缩小页面。应用程序中Command + H 隐藏(Hide)当前正在运行的应用程序窗口。Command + Option + H 隐藏(Hide)其他应用程序窗口。Command + Q 退出(Quit)最前面的应用程序。Command + Shift + Z 重做，也就是撤销的逆向操作。Command + Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于 Windows 中(Alt+Tab)。Command + Option + esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出。文本处理Command + B 切换所选文字粗体(Bold)显示。fn + Delete 相当于 PC 全尺寸键盘上的 Delete，也就是向后删除。fn + ↑ 向上滚动一页(Page Up)。fn + ↓ 向下滚动一页(Page Down)。fn + ← 滚动至文稿开头(Home)。fn + → 滚动至文稿末尾(End)。Command + → 将光标移至当前行的行尾。Command + ← 将光标移至当前行的行首。Command + ↓ 将光标移至文稿末尾。Command + ↑ 将光标移至文稿开头。Option + → 将光标移至下一个单词的末尾。Option + ← 将光标移至上一个单词的开头。Control + A 移至行或段落的开头。更多快捷键如果你还想学习更多快捷键，请点击这里查看苹果官方的快捷键帮助文档。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"https://iamzhl.top/tags/快捷键/"},{"name":"Mac","slug":"Mac","permalink":"https://iamzhl.top/tags/Mac/"}]},{"title":"多设备之间同步 hexo 搭建的 blog","slug":"Sync-your-hexo-with-several-terminal","date":"2017-10-14T15:35:54.000Z","updated":"2019-03-11T16:21:49.903Z","comments":true,"path":"Sync-your-hexo-with-several-terminal.html","link":"","permalink":"https://iamzhl.top/Sync-your-hexo-with-several-terminal.html","excerpt":"","text":"准备工作首先在 GitHub 建立一个分支用于存储 hexo 本地源文件本地 hexo 源上到 GitHub在本地博客根目录下使用 git 指令上传项目到 GitHub 的 hexo 分支123456$ git init $ git remote add origin 仓库地址 $ git checkout -b hexo $ git add . $ git commit -m \"\" $ git push origin hexo其它设备同步建立同步目录1$ mkdir blog同步 hexo 源1234$ cd blog/$ git init$ git remote add origin 仓库地址$ git pull -r origin hexo本地搭建 hexo 环境需要安装 Git 和 Node.js12$ npm install hexo --save$ npm install第一次运行需要验证 GitHub 和 coding 账号 ( 取决于你用什么部署的 blog )12$ git config --global user.email &quot;you@example.com&quot;$ git config --global user.name &quot;Your Name&quot;完工做完上面的步骤就可以在这一台设备继续发博文了1234$ hexo new post &quot;新建博客名字&quot; $ hexo clean $ hexo g$ hexo d -g","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"git","slug":"git","permalink":"https://iamzhl.top/tags/git/"},{"name":"同步","slug":"同步","permalink":"https://iamzhl.top/tags/同步/"},{"name":"github","slug":"github","permalink":"https://iamzhl.top/tags/github/"}]},{"title":"Hotpatch 屏蔽独显","slug":"Disable-the-discrete-GPU-in-laptop","date":"2017-10-03T16:00:00.000Z","updated":"2019-03-11T16:21:49.888Z","comments":true,"path":"Disable-the-discrete-GPU-in-laptop.html","link":"","permalink":"https://iamzhl.top/Disable-the-discrete-GPU-in-laptop.html","excerpt":"","text":"写在前面最近我根据 RehabMan 的 hotpatch 添加了一些路径做了一个屏蔽独显得 hotpatch 来屏蔽独显解决一些升级 10.13 后因为 nv_disable 参数失效而卡在 Window Server Service only ran for 0 seconds 的错误，发现有些成功，有些失败。于是把我琢磨到的一种方法分享给大家！希望该帖子能帮助到各位！感谢：PCBETA (远景论坛) yearjinheng 版主的帖子tonymacx86.com Rehabman 的帖子转载请注明 原贴地址屏蔽独显方法不一：第一种：直接在 DSDT SSDT 上做修改第二种：手动制作一个适合自己机器的 hotpatch 屏蔽独显达到屏蔽独显的作用开工本帖主要采用第二种方法，大致思路如下：提取 ACPI 原始表单反编译这些文件搜索一个名为 _OFF 的方法检查文件的结果以确定 _OFF 的路径修改 RehabMan 的 hotpatch 加入自己的路径提取 ACPI 原始表单并提取 _OFF 路径打开电脑进入四叶草引导界面，按下 F4 或者 FN+F4 即可提取原始表单到 /EFI/CLOVER/ACPI/origin ，然后进入 MAC 将 origin 拷贝到桌面删掉除 SSDT DSDT 之外的所有 aml 文件，打开终端：1234$ cd ~/Desktop/origin $ iasl -da -dl *.aml $ rm *.aml $ grep -l Method.*_OFF *.dsl以我修改的一个机器为例，上一条命令得到的结果如下1234DSDT.dslSSDT-7.dslSSDT-8.dslSSDT-9.dsl依次打开这四个表单搜索 _OFF ，找到一个类似于下面这个函数：图片左下角的路径就是我们最终所需要的:1_SB.PCI0.RP05.PEGP修改 RehabMan 的 hotpatch 添加这个路径首先去 RehanMan 的 GitHub 下载 hotpatch 包1https://github.com/RehabMan/OS-X-Clover-Laptop-Config.git我们只需要 SSDT-Disable_DGPU 这个文件，编译成 aml 文件1$ iasl SSDT-Disable_DGPU.dsl打开编译后得到的 aml 文件按照这个格式修改为自己的路径保存放到 /EFI/CLOVER/ACPI/patched一个注意点如果在 Config.plist 中使用了 SortedOrder (通常 Clover 安装后默认没有设置)，需要在其内添加 SSDT-Disable_DGPU.aml 这一项。因为如果指定了 SortedOrder ，则 Clover 只加载其中指定的 SSDT 。如果没有出现在列表中,即使在 ACPI/patched 中，它也不会加载。完工","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"},{"name":"Hackintosh","slug":"Hackintosh","permalink":"https://iamzhl.top/tags/Hackintosh/"},{"name":"Window Server Service only ran for 0 seconds","slug":"Window-Server-Service-only-ran-for-0-seconds","permalink":"https://iamzhl.top/tags/Window-Server-Service-only-ran-for-0-seconds/"},{"name":"Disable DGPU","slug":"Disable-DGPU","permalink":"https://iamzhl.top/tags/Disable-DGPU/"},{"name":"屏蔽独显","slug":"屏蔽独显","permalink":"https://iamzhl.top/tags/屏蔽独显/"}]},{"title":"利用 git 实现本地和远程之间代码的同步","slug":"Sync-the-codes-between-native-and-remote-by-git","date":"2017-09-27T14:54:26.000Z","updated":"2019-03-11T16:21:49.902Z","comments":true,"path":"Sync-the-codes-between-native-and-remote-by-git.html","link":"","permalink":"https://iamzhl.top/Sync-the-codes-between-native-and-remote-by-git.html","excerpt":"","text":"代码放到 git 仓库，然后本地修改同步至仓库，这在生活中是很常见的，下面是一个最简单的案例远程仓库内容同步到本地仓库新建一个本地仓库用于后续工作123$ cd ~/Desktop/$ mkdir test $ cd test初始化这个本地目录1$ git init关联到远程仓库(以我新建的 Test 这个仓库为例)1$ git remote add origin https://github.com/athlonreg/Test.git合并远程仓库的文件到本地1$ git pull --rebase origin master修改本地仓库并推送到远程仓库对本地仓库的一些修改123$ mkdir inner $ cd inner $ touch a.txt现在将我新建的 inner 目录和 a.txt 文档推送到远程仓库git add 命令添加新建目录与文件1$ git add .git commit 提交修改，引号内为修改的概要1$ git commit -m &quot;add some files&quot;这里会提示配置用户身份(两条命令的引号内分别为你 github 账号绑定的邮箱和用户名)12$ git config --global user.email &quot;15563836030@163.com&quot; $ git config --global user.name &quot;athlonreg&quot;这是继续提交修改就可以了1$ git commit -m &quot;add some files&quot;推送修改后的本地仓库到远程仓库1$ git push -u origin master这时终端会让你输入你的 github 用户名和密码，根据提示输入完，就推送完成了，再去 github 网页端就发现仓库已经更新至和本地相同了。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"git","slug":"git","permalink":"https://iamzhl.top/tags/git/"},{"name":"同步","slug":"同步","permalink":"https://iamzhl.top/tags/同步/"},{"name":"github","slug":"github","permalink":"https://iamzhl.top/tags/github/"}]},{"title":"派遣敢死队问题","slug":"Problem-about-Sending-out-death-squads","date":"2017-09-17T16:00:00.000Z","updated":"2019-03-11T16:21:49.898Z","comments":true,"path":"Problem-about-Sending-out-death-squads.html","link":"","permalink":"https://iamzhl.top/Problem-about-Sending-out-death-squads.html","excerpt":"","text":"问题描述​ G将军有一支训练有素的军队，这个军队除开G将军外，每名士兵都有一个直接上级（可能是其他士兵，也可能是G将军）。现在G将军将接受一个特别的任务，需要派遣一部分士兵（至少一个）组成一个敢死队，为了增加敢死队队员的独立性，要求如果一名士兵在敢死队中，他的直接上级不能在敢死队中。​ 请问，G将军有多少种派出敢死队的方法。注意，G将军也可以作为一个士兵进入敢死队。​ 输入格式:​ 输入的第一行包含一个整数n，表示包括G将军在内的军队的人数。军队的士兵从1至n编号，G将军编号为1。接下来n-1个数，分别表示编号为2, 3, …, n的士兵的直接上级编号，编号i的士兵的直接上级的编号小于i。​ 输出格式:​ 输出一个整数，表示派出敢死队的方案数。由于数目可能很大，你只需要输出这个数除10007的余数即可。​ 样例输入1:​ 3​ 1 1​ 样例输出1:​ 4​ 样例说明:​ 这四种方式分别是：选1；选2；选3；选2, 3。样例输入2:71 1 2 2 3 3样例输出2:40数据规模与约定对于20%的数据，n ≤ 20；对于40%的数据，n ≤ 100；对于100%的数据，1 ≤ n ≤ 100000。资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 2000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。思路1、首先将所有士兵直属上级的编号放于数组a；2、每个人有两种选择，去和不去，用0和1表示，转换为二进制放于数组b；3、最后判断每个士兵是不是与其直属上级同时执行任务，进而对count进行统计。代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// main.c// 派遣敢死队问题//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123; int number; int count=0; int flag; scanf(\"%d\",&amp;number);//派遣的人数 int i,j; int temp; int a[number],b[number];//a a[0]=0;//将军 for(i=1;i&lt;number;i++)&#123; scanf(\"%d\",&amp;a[i]);//每个人的直属上级 &#125; for(i=1;i&lt;pow(2,number);i++)&#123; temp=i; for(j=0;j&lt;number;j++)&#123; //遍历所有情况 b[j]=temp%2; temp/=2; &#125; flag=1; for(j=1;j&lt;number;j++)&#123; //将军没有上级，不用判断 if(b[j]==1&amp;&amp;b[a[j]-1]==1)&#123; //判断是否士兵和上级同时执行任务 //b[j]为编号为j+1的士兵去不去 //b[a[j]-1]为编号为j+1的士兵的直接上级去不去 flag=0; break; &#125; &#125; if(flag==1) count++; &#125; printf(\"%d\\n\",count); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"派遣敢死队","slug":"派遣敢死队","permalink":"https://iamzhl.top/tags/派遣敢死队/"}]},{"title":"警匪110问题","slug":"Problem-about-police-and-gangster-110","date":"2017-09-17T16:00:00.000Z","updated":"2019-03-11T16:21:49.899Z","comments":true,"path":"Problem-about-police-and-gangster-110.html","link":"","permalink":"https://iamzhl.top/Problem-about-police-and-gangster-110.html","excerpt":"","text":"问题描述​ 匪警请拨110,即使手机欠费也可拨通！​ 为了保障社会秩序，保护人民群众生命财产安全，警察叔叔需要与罪犯斗智斗勇，因而需要经常性地进行体力训练和智力训练！某批警察叔叔正在进行智力训练：12 3 4 5 6 7 8 9 =110; ​ 请看上边的算式，为了使等式成立，需要在数字间填入加号或者减号（可以不填，但不能填入其它符号）。之间没有填入符号的数字组合成一个数，例如：12+34+56+7-8+9 就是一种合格的填法；123+4+5+67-89 是另一个可能的答案。​ 请你利用计算机的优势，帮助警察叔叔快速找到所有答案。每个答案占一行。形如： 12+34+56+7-8+9123+4+5+67-89思路1、一共九个数字，八个操作符；2、每个操作符有三种情况，即留空、加或者减，分别用0、1和2表示；3、共有 3^8 种情况，遍历每种情况判断输出；4、需要注意的是留空和’+’、’-‘需要分开处理，因为留空之后需要将其前后的数据连在一起。5、以12+34+56+7-8+9为例，给和sum赋初值为0，第一次循环操作符为留空，需要先加上第一位的1，然后进行这一次运算，即1x10+2，然后下一次循环操作符为+，需要计算的就是12+3，同理在3、4之间的空需要计算的是3x10+4，而不是（12+3）x10+4，所以需要一个临时变量来记录上次的操作数，还需要一个变量来记录上次的操作符将上次的结果进行统计处理，原因就在于我们无法确定下次的操作符是不是留空。6、由于我们在统计和时，只有在下一次循环才能处理最后一个操作数，所以需要将9最后单独处理。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() &#123; int a[9]=&#123;1,2,3,4,5,6,7,8,9&#125;; int sum; int temp; int oper,lastoper; int number; int i,j; for(i=0;i&lt;pow(3,8);i++) &#123; sum=0; temp=1; lastoper=1; number=i; for(j=1;j&lt;=8;j++) &#123; //操作八次 oper=number%3; number=number/3; if (!oper) temp=temp*10+a[j]; //留空单独处理 if (oper==1) &#123; //当前操作符 if(lastoper==1)&#123; //前一次操作符 sum=sum+temp; temp=a[j]; &#125; if(lastoper==2)&#123; sum=sum-temp; temp=a[j]; &#125; lastoper=oper; //更新上次操作符 &#125; if(oper==2)&#123; if(lastoper==1)&#123; sum=sum+temp; temp=a[j]; &#125; if(lastoper==2)&#123; sum=sum-temp; temp=a[j]; &#125; lastoper=oper; &#125; &#125; if(lastoper==1) //第九次操作单独处理 sum=sum+temp; if(lastoper==2) sum=sum-temp; if(sum==110) &#123; number=i; for(j=1;j&lt;=8;j++) &#123; printf(\"%d\",a[j-1]); oper=number%3; number=number/3; if(oper==1) printf(\"+\"); if(oper==2) printf(\"-\"); else continue; &#125; printf(\"9\\n\"); &#125; &#125; return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"警匪110","slug":"警匪110","permalink":"https://iamzhl.top/tags/警匪110/"}]},{"title":"价牌翻转问题","slug":"Problem-about-rollover-price-tag","date":"2017-09-17T16:00:00.000Z","updated":"2019-03-11T16:21:49.899Z","comments":true,"path":"Problem-about-rollover-price-tag.html","link":"","permalink":"https://iamzhl.top/Problem-about-rollover-price-tag.html","excerpt":"价牌翻转问题","text":"价牌翻转问题问题描述​ 小李的店里专卖其它店中下架的样品电视机，可称为：样品电视专卖店。​ 其标价都是4位数字（即千元不等）。​ 小李为了标价清晰、方便，使用了预制的类似数码管的标价签，只要用颜色笔涂数字就可以了。​ 这种价牌有个特点，对一些数字，倒过来看也是合理的数字。如：1 2 5 6 8 9 0 都可以。这样一来，如果牌子挂倒了，有可能完全变成了另一个价格，比如：1958 倒着挂就是：8561，差了几千元啊!!​ 当然，多数情况不能倒读，比如，1110 就不能倒过来，因为0不能作为开始数字。​ 有一天，悲剧终于发生了。某个店员不小心把店里的某两个价格牌给挂倒了。并且这两个价格牌的电视机都卖出去了!庆幸的是价格出入不大，其中一个价牌赔了2百多，另一个价牌却赚了8百多，综合起来，反而多赚了558元。思路1、已知是一个四位数，那么共有1001-9999种情况；2、一个数颠倒之后，数字顺序颠倒并且每个数字颠倒，例如1269颠倒之后就是6921；3、0不能是第一位也不能是最后一位。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// main.c// rollover-price-tag//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include&lt;stdio.h&gt;#include&lt;math.h&gt;int array[4]=&#123;0&#125;;int inverse(int a)&#123;//求一个数颠倒之后的结果 int b=0; int arr[4]=&#123;0&#125;; for(int i=0;i&lt;4;i++)&#123; arr[i]=(int)(a/pow(10,3-i))%10; if(arr[i]==9) b+=6*pow(10,i); else if(arr[i]==6) b+=9*pow(10,i); else b+=arr[i]*pow(10,i); &#125; return b;&#125;int main()&#123; int i,j; int k=0,l=0; int temp; int flag; int up[50]=&#123;0&#125;,down[50]=&#123;0&#125;;//分别存放赚钱和赔钱的价牌 for(i=1001;i&lt;10000;i++)&#123; temp=i; flag=1; for(j=0;j&lt;4;j++)&#123; array[j]=(int)(temp/pow(10,3-j))%10; if(array[j]==3||array[j]==4||array[j]==7)&#123;//分割数字排除不能翻转的数字 flag=0; break; &#125; &#125; if(flag)&#123; if(array[0]==0 || array[3]==0)//0不能位于第一位和最后一位 continue; if(inverse(i)-i&gt;800&amp;&amp;inverse(i)-i&lt;900) up[k++]=i; if(i-inverse(i)&gt;200&amp;&amp;i-inverse(i)&lt;300) down[l++]=i; &#125; &#125; for(i=0;i&lt;50;i++)&#123;//依次输出赚钱的原价，颠倒价、赚的钱、赔钱的原价、颠倒价、赔的钱 for(j=0;j&lt;50;j++)&#123; if((inverse(up[i])-up[i])-(down[j]-inverse(down[j]))==558)&#123; printf(\"%d\\t%d\\t%d\\t\",up[i],inverse(up[i]),inverse(up[i])-up[i]); printf(\"%d\\t%d\\t%d\\n\",down[j],inverse(down[j]),down[j]-inverse(down[j])); &#125; &#125; &#125; return 0;&#125;运行结果：","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"价牌翻转","slug":"价牌翻转","permalink":"https://iamzhl.top/tags/价牌翻转/"}]},{"title":"macOS 启用任何来源","slug":"Allow-apps-downloaded-from-anywhere-in-macOS","date":"2017-09-15T13:16:31.000Z","updated":"2019-03-11T16:21:49.882Z","comments":true,"path":"Allow-apps-downloaded-from-anywhere-in-macOS.html","link":"","permalink":"https://iamzhl.top/Allow-apps-downloaded-from-anywhere-in-macOS.html","excerpt":"","text":"Allow apps downloaded from anywhere on许多朋友升级到 macOS Sierra 后在”安全性与隐私”中找不到”任何来源”选项，这里我教给大家怎么打开”任何来源”。打开终端，输入以下代码回车：1sudo spctl --master-disable会提示输入密码，根据提示输入密码回车之后就可以在”安全性与隐私”中打开”任何来源”选项了，如下图所示：","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"},{"name":"终端","slug":"终端","permalink":"https://iamzhl.top/tags/终端/"},{"name":"任何来源","slug":"任何来源","permalink":"https://iamzhl.top/tags/任何来源/"}]},{"title":"Hexo 主题 NexT 使用详解","slug":"Config-NexT-to-beautify-your-blog-with-hexo","date":"2017-09-14T11:04:36.000Z","updated":"2019-03-11T16:21:49.887Z","comments":true,"path":"Config-NexT-to-beautify-your-blog-with-hexo.html","link":"","permalink":"https://iamzhl.top/Config-NexT-to-beautify-your-blog-with-hexo.html","excerpt":"","text":"前言Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。下载主题在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开站点配置文件， 找到 theme 字段，并将其值更改为 next。启用 NexT 主题1theme: next验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug 。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：1INFO hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。成功安装并启用了 NexT 主题后。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：123Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。选择 Pisces Scheme123#scheme: Muse#scheme: Mistscheme: Pisces设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：1language: zh-Hans目前 NexT 支持的语言如以下表格所示：语言代码示例Englishenlanguage: en简体中文zh-Hanslanguage: zh-HansFrançaisfr-FRlanguage: fr-FRPortuguêsptlanguage: pt or language: pt-BR繁體中文zh-hk 或者 zh-twlanguage: zh-hkРусский языкrulanguage: ruDeutschdelanguage: de日本語jalanguage: jaIndonesianidlanguage: idKoreankolanguage: ko设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。编辑 主题配置文件，修改以下内容：设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。菜单示例配置1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html若你的站点运行在子目录中，请将链接前缀的 / 去掉NexT 默认的菜单项有键值设定值显示文本homehome: /主页archivesarchives: /archives归档页categoriescategories: /categories分类页tagstags: /tags标签页aboutabout: /about关于页面commonwealcommonweal: /404.html公益 4042.设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项：123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料3.设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 ? 作为图标。请注意键值（如 home）的大小写要严格匹配设置 侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。1.设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：12left - 靠左放置right - 靠右放置目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。12sidebar: position: left2.设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：post默认行为，在文章页面（拥有目录列表）时显示always在所有页面中都显示hide在所有页面中都隐藏（可以手动展开）remove完全移除12sidebar: display: post已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。设置 头像编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：地址值完整的互联网URIhttp://example.com/avatar.png站点内的地址将头像放置主题目录下的 source/uploads/ (新建 uploads 目录若不存在)，配置为：avatar: /uploads/avatar.png；或者 放置在 source/images/ 目录下，配置为：avatar: /images/avatar.png头像设置示例1avatar: http://example.com/avatar.png设置作者昵称编辑站点配置文件， 设置 author 为你的昵称。站点描述编辑站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名 : )主题配置设置 RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值：123false： 禁用 RSS，不在页面上显示 RSS 连接。留空： 使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。具体的链接地址：适用于已经烧制过 Feed 的情形。添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子：12345title: 标签测试文章tags: - Testing - Another Tag---请参阅 Hexo 的分类与标签文档，了解如何为文章添加标签或者分类。新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ：12$ cd your-hexo-site$ hexo new page tags设置页面类型编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;---在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下:1234menu: home: / archives: /archives tags: /tags注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如：禁用评论示例12345title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;comments: false---添加「分类」页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子：123title: 分类测试文章categories: Testing---请参阅 Hexo 的分类与标签文档，了解如何为文章添加标签或者分类。新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：12$ cd your-hexo-site$ hexo new page categories设置页面类型编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;---修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:1234menu: home: / archives: /archives categories: /categories注意：如果有集成评论服务，页面也会带有评论。 若需要关闭的话，请添加字段 comments 并将值设置为 false，如：禁用评论示例12345title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false---设置字体注意： 此特性在版本 5.0.1 中引入，要使用此功能请确保所使用的 NexT 版本在此之后为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是：123456789全局字体：定义的字体将在全站范围使用标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6）文章字体：文章所使用的字体Logo字体：Logo 所使用的字体代码字体： 代码块所使用的字体各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组：非代码类字体：Fallback 到 &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif代码类字体： Fallback 到 consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, monospace另外，每一项都有一个额外的 external 属性，此属性用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。配置示例12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如：高亮主题设置示例1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。1.链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。配置示例1234567# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name2.设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。配置示例1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo开启打赏功能 由 habren 贡献越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。打赏功能配置示例123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image友情链接 由 iamwent 贡献编辑 主题配置文件 添加：友情链接配置示例12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。配置示例1since: 2013设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果设置「背景动画」NexT 自带两种背景动画效果编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：注意： three_waves 在版本 5.1.1 中引入。只能同时开启一种背景动画效果。canvas_nest 配置示例1234567# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画three_waves 配置示例# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画腾讯公益 404 页面 由 xirong 贡献腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下：123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;CreditsNexT基本使用转自官方说明文档","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"静态博客","slug":"静态博客","permalink":"https://iamzhl.top/tags/静态博客/"},{"name":"NexT","slug":"NexT","permalink":"https://iamzhl.top/tags/NexT/"},{"name":"hexo","slug":"hexo","permalink":"https://iamzhl.top/tags/hexo/"}]},{"title":"黑苹果无线网卡 BCM94352z 驱动教程","slug":"Enable-BCM94352z-on-hacintosh","date":"2017-09-12T16:00:00.000Z","updated":"2019-03-11T16:21:49.889Z","comments":true,"path":"Enable-BCM94352z-on-hacintosh.html","link":"","permalink":"https://iamzhl.top/Enable-BCM94352z-on-hacintosh.html","excerpt":"","text":"添加仿冒 ID 启用蓝牙：1config.plist -&gt; Device -&gt; FakeID -&gt; WIFI 中填写 0x43a014e4在 Clover 的配置文件 config.plist -&gt; Kernel and Kext Patches 添加以下代码块12345678910111213141516&lt;dict&gt; &lt;key&gt;Comment&lt;/key&gt; &lt;string&gt;10.11+-BT4LE-Handoff-Hotspot-lisai9093&lt;/string&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Find&lt;/key&gt; &lt;data&gt; SIX/dEdIiwc= &lt;/data&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;IOBluetoothFamily&lt;/string&gt; &lt;key&gt;Replace&lt;/key&gt; &lt;data&gt; Qb4PAAAA60Q= &lt;/data&gt;&lt;/dict&gt;下载并安装驱动1234https://github.com/vit9696/Lilu/releaseshttps://bitbucket.org/RehabMan/os-x-fake-pci-id/downloads/ https://bitbucket.org/RehabMan/os-x-brcmpatchram/downloads/https://sourceforge.net/projects/airportbrcmfixup/files/?source=navbar将以下驱动拷贝到 CLOVER/EFI/CLOVER/kexts/Other 文件夹下(由于 AirportBrcmFixup.kext 是依赖于 Lilu 运行的插件，所以还需要确保该目录下必须存在 Lilu.kext)123456AirportBrcmFixup.kext FakePCIID.kext FakePCIID_Broadcom_WiFi.kext BrcmPatchRAM2.kext BrcmFirmwareData.kextLilu.kext重建缓存123sudo rm -rf /System/Library/Caches/com.apple.kext.caches/Startup/kernelcachesudo rm -rf /System/Library/PrelinkedKernels/prelinkedkernelsudo touch /System/Library/Extensions/ &amp;&amp; sudo kextcache -u /重启","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"Hacintosh","slug":"Hacintosh","permalink":"https://iamzhl.top/tags/Hacintosh/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/tags/黑苹果/"},{"name":"BCM94352z","slug":"BCM94352z","permalink":"https://iamzhl.top/tags/BCM94352z/"}]},{"title":"低碳生活答题问题","slug":"Problem-about-low-carbon-lifestyle-answering","date":"2017-09-11T16:00:00.000Z","updated":"2019-03-11T16:21:49.899Z","comments":true,"path":"Problem-about-low-carbon-lifestyle-answering.html","link":"","permalink":"https://iamzhl.top/Problem-about-low-carbon-lifestyle-answering.html","excerpt":"","text":"问题描述某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：​1、每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。​2、每位选手都有一个起步的分数为10分。 某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？​3、如果把答对的记为1，答错的记为0，则10个题目的回答情况可以用仅含有1和0的串来表示。例如：0010110011 就是可能的情况。​4、你的任务是算出所有可能情况。每个答案占一行。解题思路一共十个问题，每个问题两种情况，要么对要么错，那么结果就会有 0000000000 ~ 1111111111 = pow（2，10）种，就可以用暴力搜索将所有情况枚举出来然后判断符合要求的情况；​分数的控制可以直接利用遍历所有情况的 for 循环分别判断两种情况；​如果用输出 1 代表回答正确， 0 代表错误，不难想到任何一个正整数对 2 取余结果只有 1 和 0 两种情况， 输出的时候也就成了进制转换问题；代码实现1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() &#123; int i,j; int score,temp; for(i=0;i&lt;pow(2,10);i++)&#123; temp=i; score=10; for(j=0;j&lt;10;j++)&#123; if(temp%2 == 1) score*=2; else score-=j+1; temp/=2; &#125; if(score==100)&#123; temp=i; for(j=0;j&lt;10;j++)&#123; printf(\"%d \", temp%2); temp/=2; &#125; printf(\"\\n\"); &#125; &#125; return 0;&#125;运行结果1231 0 1 1 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 1 1","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"低碳生活答题问题","slug":"低碳生活答题问题","permalink":"https://iamzhl.top/tags/低碳生活答题问题/"}]},{"title":"最简单的客户机与服务器案例演示","slug":"The-simplest-case-demo-about-client-and-server","date":"2017-09-06T16:00:00.000Z","updated":"2019-03-11T16:21:49.904Z","comments":true,"path":"The-simplest-case-demo-about-client-and-server.html","link":"","permalink":"https://iamzhl.top/The-simplest-case-demo-about-client-and-server.html","excerpt":"","text":"EchoClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package athlonreg.top;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;/** * * @author athlonreg */ public class EchoCilent &#123; /** * @param args the command line arguments */ public static void main(String[] args) &#123; // TODO code application logic here Socket clientSocket = null; BufferedReader in = null; BufferedWriter out = null; try &#123; //1.创建客户机套接字 clientSocket = new Socket(); SocketAddress remoteAddr=new InetSocketAddress(\"localhost\",5000); System.out.println(\"1.创建客户机套接字成功！\"); //2.连接服务器 clientSocket.connect(remoteAddr); System.out.println(\"2.客户机连接服务器localhost端口5000成功！\"); System.out.println(\"客户机使用的地址和端口：\"+clientSocket.getLocalSocketAddress()); //与服务器会话 in = new BufferedReader( new InputStreamReader( clientSocket.getInputStream())); out = new BufferedWriter( new OutputStreamWriter( clientSocket.getOutputStream())); String sendStr=\"有朋自远方来\"; out.write(sendStr); //向服务器发送字符串 out.newLine(); out.flush(); System.out.println(\"3.1向服务器发送字符串成功!\"+sendStr); String recvStr=in.readLine(); //从服务器接收字符串 System.out.println(\"3.2从服务器接收回送字符串成功！\"+recvStr); &#125; catch (IOException ex) &#123; System.out.println(\"异常信息：\"+ex.getMessage()); &#125; //关闭套接字和流 try &#123; if (in != null) in.close(); if (out != null) out.close(); if (clientSocket != null) clientSocket.close(); System.out.println(\"4.关闭套接字和流成功！\"); &#125; catch (IOException ex) &#123; System.out.println(\"异常信息：\"+ex.getMessage()); &#125; &#125; &#125;EchoServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package athlonreg.top;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketAddress;/** * * @author athlonreg */ public class EchoServer &#123; /** * @param args the command line arguments * @throws java.io.IOException */ public static void main(String[] args) throws IOException &#123; // TODO code application logic here //1.启动服务器 ServerSocket listenSocket = null; Socket clientSocket = null; BufferedReader in = null; BufferedWriter out = null; try &#123; listenSocket = new ServerSocket(); SocketAddress serverAddr=new InetSocketAddress(&quot;localhost&quot;,5000); listenSocket.bind(serverAddr); System.out.println(&quot;1.服务器启动成功！开始在localhost的5000端口侦听连接...&quot;); //2.处理连接 clientSocket = listenSocket.accept(); System.out.println(&quot;2.客户机连接成功！客户机地址和端口：&quot;+clientSocket.getRemoteSocketAddress()); //3.与客户机会话 in = new BufferedReader( new InputStreamReader( clientSocket.getInputStream())); out = new BufferedWriter( new OutputStreamWriter( clientSocket.getOutputStream())); String recvStr=in.readLine(); //从客户机接收字符串 System.out.println(&quot;3.1 服务器收到字符串：&quot;+recvStr); out.write(recvStr); //向客户机回送字符串 out.newLine(); out.flush(); System.out.println(&quot;3.2 服务器回送字符串成功：&quot;+recvStr); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息：&quot;+ex.getMessage()); &#125; //4.关闭套接字和流 try &#123; if (in != null) in.close(); if (out != null) out.close(); if (listenSocket != null) listenSocket.close(); if (clientSocket != null) clientSocket.close(); System.out.println(&quot;4.关闭套接字和流成功！&quot;); &#125; catch (IOException ex) &#123; System.out.println(&quot;异常信息&quot;+ex.getMessage()); &#125; &#125; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://iamzhl.top/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"https://iamzhl.top/tags/网络编程/"},{"name":"客户机与服务器","slug":"客户机与服务器","permalink":"https://iamzhl.top/tags/客户机与服务器/"}]},{"title":"xcode-select 命令详解","slug":"How-to-use-xcode-select-in-terminal","date":"2017-09-02T16:00:00.000Z","updated":"2019-03-11T16:21:49.892Z","comments":true,"path":"How-to-use-xcode-select-in-terminal.html","link":"","permalink":"https://iamzhl.top/How-to-use-xcode-select-in-terminal.html","excerpt":"","text":"It’s not uncommon developers to have multiple versions of Xcode installed. For example, I typically have the latest beta as well as the most current production release installed.However, there are times when you may want various tools, such as xcodebuild, to point to a specific Xcode folder. To faciliate this, you can use xcode-select. A common use case is if you use scripts and/or makefiles to build your projects.Once you set the Xcode folder, xcodebuild will be invoked from the folder you specified.The command line options are below:1234xcode-select [-help]xcode-select [-switch xcode_folder_path]xcode-select [-print-path]xcode-select [-version]Here is how to print the current Xcode path:12$ xcode-select --print-path/Developer/Applications/Xcode.appLine number 2 shows the current version of Xcode that is ‘active.’ If you are accessing xcodebuild or other related tools from a script, –print-path is the preferred means to determine the current Xcode location.Use the -switch option to change to another version of Xcode on your system:1$ sudo xcode-select --switch /Applications/Xcode-beta.app/Contents/DeveloperThis changes to the Xcode-beta 9 on my system. Note that root access is required to set the Xcode location, thus I have used sudo to execute the command as root.Printing the path now looks as follows:12$ xcode-select --print-path/Applications/Xcode-beta.app/Contents/DeveloperTo switch back to Xcode installed in the /Applications directory:1$ sudo xcode-select -switch /Applications/Xcode.app/You can read more about xcode-select by view the man page from a terminal:1$ man xcode-select","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"终端","slug":"终端","permalink":"https://iamzhl.top/tags/终端/"},{"name":"Mac","slug":"Mac","permalink":"https://iamzhl.top/tags/Mac/"},{"name":"Xcode","slug":"Xcode","permalink":"https://iamzhl.top/tags/Xcode/"}]},{"title":"金币阵列问题","slug":"Problem-about-coin-array","date":"2017-09-02T16:00:00.000Z","updated":"2019-03-11T16:21:49.898Z","comments":true,"path":"Problem-about-coin-array.html","link":"","permalink":"https://iamzhl.top/Problem-about-coin-array.html","excerpt":"","text":"问题描述有m*n枚金币在桌面上排列成一个m行n列的金币阵列。每一枚金币或正面朝上，或背面朝上。用数字表示金币状态，0表示正面朝上，1表示背面朝上。金币阵列游戏的规则1、每次将任一行金币翻过来放在原来的位置上;2、每次可以任选2列，交换这2列金币的位置.任务给定金币的初始状态和目标状态，编程计算按金币游戏规则，将金币排列从初始状态变换到目标状态所需的最少变换次数。思路本例的实质是将一个二进制矩阵从一种形式利用相应规则变换到另一种形式。提供的规则有两种：1、将某一行的金币翻转;2、将某两列进行交换。在这两种操作中，第一种操作可能会影响到某一行或者某一列中已经排列好的相关元素，因此，首先利用该规则进行变换，而后续的操作则不再利用该规则。​那么在程序中应该如下操作：1、将矩阵中的每一列作为第1列，并利用第一个规则将第1列中的相关元素与目标矩阵中第1列的元素进行配对，如果不相同，则利用每1个规则进行翻转；​2、从第2列开始，将处理后的列与目标列进行比较，如果相同，则转下一列；如果不同，看是否可以通过列的交换完成，如果可以，则继续扫描，否则无解。​代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// main.c// coin-array//// Created by Canvas on 2018/12/31.// Copyright © 2018 Canvas. All rights reserved.//#include &lt;stdio.h&gt;#define row 4#define col 3int source[row][col] = &#123;1,0,1,0,0,0,1,1,0,1,0,1&#125;; //sourceint target[row][col] = &#123;1,0,1,1,1,1,0,1,1,1,0,1&#125;; //targetint temparr[row][col];int number = 0; //转换的次数int minnum = 9999;void raw_change(int i) &#123; //行翻转 int j; for(j=0; j&lt;col; j++) &#123; temparr[i][j] = 1-temparr[i][j]; &#125; number++;&#125;void col_exchange(int i, int j) &#123; //列交换 int temp, k; for(k=0; k&lt;row; k++) &#123; temp = temparr[k][i]; temparr[k][i] = temparr[k][j]; temparr[k][j] = temp; &#125; if(i != j) number++;&#125;int judge(int i, int j) &#123; //temparr的i列是否和target的j列相同 int flag = 0; for(int k=0; k&lt;row; k++) &#123; flag=1; if(temparr[k][i] != target[k][j]) &#123; flag=0; break; &#125; &#125; return flag;&#125;int main() &#123; // insert code here... int i,j,k; for(i=0; i&lt;col; i++) &#123; //代表source的列 for(j=0; j&lt;row; j++) &#123; for(k=0; k&lt;col; k++) &#123; temparr[j][k] = source[j][k]; //给替身数组赋值 &#125; &#125; number=0; col_exchange(0,i); //temparr数组的列先做交换，把其他列放到第一列的位置 for(j=0; j&lt;row; j++) &#123; //判断temparr的0号列和target的0号列是否相同，不同则翻转 if(temparr[j][0] != target[j][0]) &#123; raw_change(j); //如果第1列不匹配，那么行全部翻转 &#125; &#125; int found = 0; for(j=0; j&lt;col; j++) &#123; //代表target，从第2行开始，到最后一行 found=0; for(k=j; k&lt;col; k++) &#123; //代表temparr，从第2行开始，直到最后一行 if(judge(k, j)) &#123; found=1; col_exchange(k, j); break; &#125; &#125; if(!found) &#123; break; &#125; &#125; if(found) &#123; minnum=number; &#125; &#125; if(minnum&lt;9999) &#123; printf(\"一共变换%d次！\\n\", minnum); &#125; else&#123; printf(\"无解！\\n\"); &#125; return 0;&#125;运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"金币阵列","slug":"金币阵列","permalink":"https://iamzhl.top/tags/金币阵列/"}]},{"title":"字典序问题","slug":"Problem-about-dictionary-order","date":"2017-08-30T16:00:00.000Z","updated":"2019-03-11T16:21:49.898Z","comments":true,"path":"Problem-about-dictionary-order.html","link":"","permalink":"https://iamzhl.top/Problem-about-dictionary-order.html","excerpt":"","text":"问题描述在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写字母组成。该字母表产生的升序字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表中产生的所有长度不超过6的升序字符串，计算它在字典中的编码。思路首先判断字符串长度为3，先算长度为1和2的所有情况，即从26个字母中选1个或两个字母，因为是升序，即sum=C（26，1）+C（26，2）；之后再看字符串的第一个字符，为’d’,之前有以a,b,c开头的长度为3的字符串，以a开头，后边2位需要在25个字母中选择（除了a），以b开头的后2位需要在24个字母中选择（除了a,b），以c开头的在23个字母（除了a,,b,c）中选择，即sum+=(C(25,2)+C(24,2)+C(23,2));然后再看下一个字母’g’，d与g之间有e,f,需要算以de开头以及以df开头的所有情况，即sum+=(C(21,1)+C(20,1))；最后再加上h-‘a’+1;代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string.h&gt;int getCombinatorialNumber(int m, int n) &#123; int n_Product=1, m_Product=1; int i; for(i=1; i&lt;=n; i++) n_Product*=i; for(i=m; i&gt;m-n; i--) &#123; m_Product*=i; return m_Product/n_Product; &#125;&#125;int main(int argc, const char * argv[]) &#123; int number; //要统计字符串的个数 int sum; //存放字符串的序号 int length; char str[10]; //存放字符串 int a[10]; //存放字符串的每一位字符的值 int i, j; scanf(&quot;%d&quot;, &amp;number); while(number--) &#123; getchar(); sum=1; scanf(&quot;%s&quot;, str); length=(int)strlen(str); for(i=1; i&lt;length; i++) &#123; sum += getCombinatorialNumber(26, i); //小于字符串长度的字符串个数 &#125; for(i=0; i&lt;length; i++) &#123; a[i]=str[i]-96; //计算每个字符从a开始的序号数值, a~z分别对应1~26 //printf(&quot;%d &quot;, a[i]); &#125; //printf(&quot;%d\\n&quot;, f(26, 2)); int temp=1; for(i=length; i&gt;0; i--) &#123; for(j=temp; j&lt;a[length-i]; j++) &#123; sum += getCombinatorialNumber(26-j, i-1); //依次扫描字符，计算所有情况 &#125; temp=a[length-i]+1; &#125; printf(&quot;%d\\n&quot;, sum); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"字典序","slug":"字典序","permalink":"https://iamzhl.top/tags/字典序/"}]},{"title":"DSDT SSDT 简单提取修复","slug":"Extract-and-fix-DSDT-SSDT-simply","date":"2017-08-29T16:00:00.000Z","updated":"2019-03-11T16:21:49.890Z","comments":true,"path":"Extract-and-fix-DSDT-SSDT-simply.html","link":"","permalink":"https://iamzhl.top/Extract-and-fix-DSDT-SSDT-simply.html","excerpt":"DSDT SSDT 简单提取修复","text":"DSDT SSDT 简单提取修复开工准备工作首先在 CLOVER 引导界面按 F4 或者 FN + F4 提取原始表单，然后进入 Mac ，利用 Clover Configurator 挂载ESP分区，提取的表单就在 /EFI/CLOVER/ACPI/origin ,将 origin 整个拷贝到桌面，并删除 origin 中除 DSDT SSDT 以外的所有文件然后下载要用到的工具12iasl：https://bitbucket.org/RehabMan/acpica/downloads/MaciASL：https://github.com/acidanthera/MaciASL/releases将 iasl 放到 /usr/bin1$ sudo cp /path/to/iasl /usr/bin/然后安装 MaciASL 并添加补丁源：Rehabman 补丁源：12Name：RehabMan Laptop URL：http://raw.github.com/RehabMan/Laptop-DSDT-Patch/master打开终端，输入：1cd ~/Desktop/origin回车进入 origin 目录然后输入:1iasl –da –dl *.aml回车这时打开桌面的 origin 文件夹会发现多出了很多 .dsl 文件，我们要用到的就是这些文件先不要急，终端继续执行1rm –rf *.aml回车然后执行:1rm –rf *x.dsl回车，这时就会发现终端只剩下了不带 x 的 dsl 文件开始操作然后用 MaciASL 打开 DSDT.dsl点 Compile 编译后会弹出错误的窗口：点这些错误就会定位到错误的代码位置这里说一下常见的错误修复方法:1、 PARSEOP_ZERO 错误，定位后会发现一堆 zero 代码，直接将他们删掉即可2、 Unexpected ‘}’ 错误：​定位后是这样：我们会发现这个错误位于 ADBG 的方法下，这时只需打个补丁即可：​点Patch找到 Fix ADBG Error 点一下，然后 Apply 应用即可，这时我们会发现再编译就没有错误了(警告可以不用管)，然后保存成aml文件Save 即可，其他 SSDT 文件也是一样的操作修改完成在修改完所有表单的错误并保存成aml格式后，将这些 aml 文件放到 /EFI/CLOVER/ACPI/patched 就可以了完工","categories":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://iamzhl.top/categories/黑苹果/"}],"tags":[{"name":"DSDT","slug":"DSDT","permalink":"https://iamzhl.top/tags/DSDT/"},{"name":"SSDT","slug":"SSDT","permalink":"https://iamzhl.top/tags/SSDT/"},{"name":"编译","slug":"编译","permalink":"https://iamzhl.top/tags/编译/"}]},{"title":"统计数字问题","slug":"Statistical-problem","date":"2017-08-28T16:00:00.000Z","updated":"2019-03-11T16:21:49.902Z","comments":true,"path":"Statistical-problem.html","link":"","permalink":"https://iamzhl.top/Statistical-problem.html","excerpt":"","text":"问题描述一本书的页码从自然数 1 开始计数，直到自然数 n 。书的页码按照通常的习惯编排，每个页码都不包含多余的前导数字 0 。例如，第 6 页用数字 6 表示，而不是 06 或 006 等。数字计数问题要求对给定书的总页码 n ，计算出书的全部页码中分别用到多少次数字 0，1，2，…，9 。思路:暴力求解。本题关键在于将每一页码的数字进行分解，这种方式可以利用整数的除法和对10取余计算。代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;math.h&gt; int main(int argc, const char * argv[]) &#123; // insert code here... int array[10] = &#123;0&#125;; //存放0~9出现的次数 int low, temp, high; //以temp为分割点 将页数分为三部分 high和low分别代表高位和低位的数值 int paginations; //存放总页数 int i, j; printf(&quot;一共多少页: &quot;); scanf(&quot;%d&quot;, &amp;paginations); int count = 0; //存放除去最高位后总页码的位数 count = (int)log10(paginations); for(i = count; i &gt;= 0; i --) &#123; //i表示低位（low）的位数 low = paginations % (int)pow(10, i); //计算low的数值 temp = paginations / (int)pow(10, i) % 10; //计算temp的数值 high = paginations / (int)pow(10, i + 1); //计算high的数值 for(j = 0; j &lt; temp; j ++) array[j] += (high + 1) * pow(10, i); //计算 0&lt;中间位&lt;temp 出现的次数 array[temp] += high * pow(10, i) + low + 1; //计算 中间位=temp 出现的次数 for(j = temp + 1; j &lt; 10; j ++) //计算 temp&lt;中间位&lt;9 出现的次数 array[j] += high * pow(10, i); &#125; for(i = count; i &gt;= 0; i --) //除去多统计的a[0]出现的次数 array[0] -= pow(10, i); printf(&quot;0~9分别出现的次数为:\\n&quot;); for(i = 0; i &lt; 10; i ++) //打印0~9分别出现的次数 printf(&quot;%d\\n&quot;, array[i]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://iamzhl.top/tags/算法/"},{"name":"C语言","slug":"C语言","permalink":"https://iamzhl.top/tags/C语言/"},{"name":"统计数字","slug":"统计数字","permalink":"https://iamzhl.top/tags/统计数字/"}]},{"title":"macOS 搭建 JDK 开发环境","slug":"Install-jdk-on-macOS","date":"2017-08-27T16:00:00.000Z","updated":"2019-03-11T16:21:49.893Z","comments":true,"path":"Install-jdk-on-macOS.html","link":"","permalink":"https://iamzhl.top/Install-jdk-on-macOS.html","excerpt":"","text":"安装 jdkMac系统自带jdk，但是版本比较老，我们可以去官网下载最新的Jdk，安装比较简单，这里不再赘述。配置 jdk 环境变量打开终端输入 vim ~/.bash_profile 回车，然后按i进入编辑模式，在最后面输入以下内容：1234567JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH按下 esc ，然后输入 :wq 回车，保存退出然后输入 source ~/.bash_profile 回车文件修改就生效了。输入 java -version 回车可以查看 Java 版本，whereis java 可以查看 Java 位置，echo $JAVA_HOME 可以打印出 JAVA_HOME 。安装eclipse为了更方便的进行开发工作，我们还需要安装Eclipse，去官网下载完成后解压，把.app文件拖进应用程序(Application)就可以了，然后创建一个workspace，也就是工作目录，用来存放工作代码。","categories":[{"name":"学习","slug":"学习","permalink":"https://iamzhl.top/categories/学习/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://iamzhl.top/tags/Mac/"},{"name":"Java","slug":"Java","permalink":"https://iamzhl.top/tags/Java/"},{"name":"搭建","slug":"搭建","permalink":"https://iamzhl.top/tags/搭建/"},{"name":"环境","slug":"环境","permalink":"https://iamzhl.top/tags/环境/"}]}]}